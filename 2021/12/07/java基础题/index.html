<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":100000},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"auto","trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<link rel="stylesheet" href="/js/prism/prism.css">

  <meta name="description" content="题目：1、列举出四种及以上Java的容器类（即集合类）？Set、List、Queue、Map、ArrayList、HashSet、HashMap 2、简单说说Java事件处理由哪四部分组成？Java事件由四部分组成：事件源：产生事件的对象，例如：各个组件事件对象：事件类监听器：监听器接口(里面定义了响应事件的抽象方法)“注册”：产生事件的对象，通过调用一个方法，通知“监听器”。 3、Java网络编">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2021/12/07/java%E5%9F%BA%E7%A1%80%E9%A2%98/index.html">
<meta property="og:site_name" content="Myblog">
<meta property="og:description" content="题目：1、列举出四种及以上Java的容器类（即集合类）？Set、List、Queue、Map、ArrayList、HashSet、HashMap 2、简单说说Java事件处理由哪四部分组成？Java事件由四部分组成：事件源：产生事件的对象，例如：各个组件事件对象：事件类监听器：监听器接口(里面定义了响应事件的抽象方法)“注册”：产生事件的对象，通过调用一个方法，通知“监听器”。 3、Java网络编">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-07T14:37:16.649Z">
<meta property="article:modified_time" content="2021-12-07T14:36:26.651Z">
<meta property="article:author" content="pty">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/12/07/java%E5%9F%BA%E7%A1%80%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础 | Myblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Myblog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Myblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">少年，你渴望力量吗</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/07/java%E5%9F%BA%E7%A1%80%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="pty">
      <meta itemprop="description" content="努力最坏的结果不过是大器晚成">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Myblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-07 22:37:16 / 修改时间：22:36:26" itemprop="dateCreated datePublished" datetime="2021-12-07T22:37:16+08:00">2021-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>题目：<br>1、列举出四种及以上Java的容器类（即集合类）？<br>Set、List、Queue、Map、ArrayList、HashSet、HashMap</p>
<p>2、简单说说Java事件处理由哪四部分组成？<br>Java事件由四部分组成：<br>事件源：产生事件的对象，例如：各个组件<br>事件对象：事件类<br>监听器：监听器接口(里面定义了响应事件的抽象方法)<br>“注册”：产生事件的对象，通过调用一个方法，通知“监听器”。</p>
<p>3、Java网络编程主要基于两个协议，是哪两个协议，其作用各是什么？（7分）<br>答：是TCP协议和UDP协议（1分）<br>    TCP协议：是面向连接的传输层协议。 进程（应用程序）在使用TCP协议之前，必须先建立连接，在数据传输完毕后要释放已建立的连接。（3分）<br>    UDP协议：是无连接的传输层协议。进程（应用程序）使用UDP无须建立连接，当然，数据传输结束时也没有连接需要释放。因此，用UDP能减少开销和发送数据之前的时延。（3分）</p>
<p>4、X公司承接了一个软件项目，目前正在做可行性分析。项目经理偏向于采用Java语言开发此项目，但有少数员工提出也可以用其他语言开发如C++或C#等，为统一思想。项目经理委托小张收集数据，并给大家分析下Java的特点或优势。（请列举Java的特点至少6点，并简单进行分析说明）<br>答：简单、面向对象、支持分布式(即网络功能)、健壮性（少出低级错误）、安全（被破解的可能性）、体系结构中立（跨平台）、可移植性、解释执行、高性能、多线程、动态</p>
<p>5、Java相对于C、C++语言，更适合应用型软件的开发，这主要是Java语言本身就相对C++语言作出了一些变化，请分析出至少Java相对C++语言在语法上6个及更多的不同点。<br>答：1）全局变量：Java中没有全局变量。2）指针：Java不支持指针，但对象变量实际上都是指针。3）数据类型的支持：Java在不同平台上数据类型都统一。4）类型转换：Java有类型相容性检查。5）结构和联合：Java只支持类。6）多重继承：Java用接口实现类似多重继承的功能。7）内存管理：Java自动回收无用内存。8）头文件：Java支持包引入import。9）宏定义和预处理：Java不支持宏定义。</p>
<p>6、什么是JDBC，在什么时候会用到它？<br>答、JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<p>7、列举出任意四个JDBC连接数据库相关的Java类？<br>答：DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等</p>
<p>8、JDBC操作数据库的步骤？<br>答：注册数据库驱动。<br>建立数据库连接。<br>操作数据库：包括创建一个Statement，执行SQL语句，处理结果集等。<br>关闭数据库连接</p>
<p>9、有哪些不同类型的JDBC驱动，每种驱动的特点是什么？<br>答：有四类JDBC驱动。<br>1） JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。<br>2） Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。<br>3） Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。<br>4） Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。</p>
<p>10、JDBC是如何实现Java程序和JDBC驱动的松耦合的？<br>答：JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。在这里可以看到更多JDBC的使用示例。</p>
<p>11、JDBC的DriverManager是用来做什么的？<br>答：JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p>
<p>=======================================================<br>论述题：</p>
<p>对Java中JDBC的分析和理解？<br>   （1、可以从JDBC的含义；JDBC连接数据库相关的常用Java类；当前主要使用哪种类型的JDBC驱动；JDBC是如何实现Java程序和JDBC驱动的松耦合的；JDBC的DriverManager是用来做什么的；JDBC的DriverManager的理解等等角度进行分析（但不限于这些角度）<br>     2、能正确答出3个及以上点，且字数超过200字，则得满分<br>    ）。<br>答：<br>  1、JDBC的含义<br>  JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p>
<p>  2、JDBC连接数据库相关的常用Java类包括（列举4个及以上，并可以简单说说列举的类的作用或含义）：<br>  DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等  </p>
<p>  3、主要使用的JDBC驱动类型<br>  Direct-to-Database Pure Java Driver：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQLConnector/J是MySQL数据库的驱动。</p>
<p>  4、JDBC如何实现Java程序和JDBC驱动的松耦合的<br>JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。</p>
<p>  5、JDBC的DriverManager<br>JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager. getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p>
<p>=======================================================</p>
<p>12、在Java程序中，如何获取数据库服务器的相关信息？<br>答：使用DatabaseMetaData可以获取到服务器的信息。当和数据库的连接成功建立了之后，可以通过调用getMetaData()方法来获取数据库的元信息。DatabaseMetaData里面有很多方法，通过它们可以获取到数据库的产品名称，版本号，配置信息等。相关代码为：<br>DatabaseMetaData metaData = con.getMetaData();<br>String dbProduct = metaData.getDatabaseProductName();</p>
<p>13、JDBC的Statement是什么？<br>答：Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法我们可以生成一个Statement对象。我们可以通过调用它的execute()，executeQuery()，executeUpdate()方法来执行静态SQL查询。由于SQL语句是程序中传入的，如果没有对用户输入进行校验的话可能会引起SQL注入的问题。<br>另外，默认情况下，一个Statement同时只能打开一个ResultSet。如果想操作多个ResultSet对象的话，需要创建多个Statement。Statement接口的所有execute方法开始执行时都默认会关闭当前打开的ResultSet。</p>
<p>14、execute，executeQuery，executeUpdate的区别是什么？<br>答：1）execute方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。<br>2）executeQuery方法用来执行查询(select)，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。<br>3）executeUpdate方法用来执行添删改操作，即insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。<br>4）只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p>
<p>15、JDBC的PreparedStatement是什么？<br>答：PreparedStatement对象代表的是一个预编译的SQL语句。用它提供的setter方法可以传入查询的变量。<br>由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。由于PreparedStatement自动对特殊字符转义，避免了SQL注入攻击，因此应当尽量的使用它。</p>
<p>16、PreparedStatement中如何注入NULL值？<br>答：可以使用它的setNull方法来把null值绑定到指定的变量上。setNull方法需要传入参数的索引以及SQL字段的类型，像这样：<br>ps.setNull(10, java.sql.Types.INTEGER);.</p>
<p>17、Statement中的getGeneratedKeys方法有什么用？<br>答：有的时候表会生成主键，这时候就可以用Statement的getGeneratedKeys()方法来获取这个自动生成的主键的值了。</p>
<p>18、相对于Statement，PreparedStatement的优点是什么？<br>答：它和Statement相比优点在于：<br>1）PreparedStatement有助于防止SQL注入，因为它会自动对特殊字符转义。<br>2）PreparedStatement可以用来进行动态查询。<br>3）PreparedStatement执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。<br>4）使用PreparedStatement的setter方法更容易写出面向对象的代码，而Statement的话，我们得拼接字符串来生成查询语句。如果参数太多了，字符串拼接看起来会非常难看并且容易出错。</p>
<p>19、JDBC中大数据量的分页解决方法?<br>答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。<br>mysql语法：<br>    SELECT *<br>    FROM 表名<br>    LIMIT [START], length;<br>oracle语法：<br>    SELECT *FROM (<br>        SELECT 列名,列名,ROWNUM rn<br>        FROM 表名<br>        WHERE ROWNUM&lt;=(currentPage*lineSize)) temp<br>    WHERE temp.rn&gt;(currentPage-1)*lineSize;</p>
<p>简答和分析题集</p>
<p>20 java中有几种类型的流?JDK为每种类型的流提供了一些抽象类以提供继承，请说出他们分别是哪些类？<br>答：<br>（1）字节流，字符流。<br>（2）字节流继承于InputStream，OutputStream。<br>（3）字符流继承于Reader Writer。</p>
<p>21 使用处理流的优势有哪些？如何识别所使用的流是处理流还是节点流？<br>答：<br>优势：对开发人员来说，使用处理流进行输入/输出操作更简单。使用处理流的执行效率更高。<br>识别：处理流的构造器的参数不是一个物理节点，而是已经存在的流。而节点流都是直接以物理 IO 及节点作为构造器参数的。</p>
<p>22 什么是标准的IO流？<br>答：在java语言中用stdin表示键盘，用stdout表示监视器。它们被封装在System类的类变量 in 和 out 中，对应系统调用System,in 和 System,out。这样的两个流加上System.err统称为标准流。<br>System类中声明的3个类变量：<br>（1）public static InputStream in;<br>（2）public static PrinStream out;<br>（3）public static PriStram err;</p>
<p>23  什么能被序列化？什么不能被序列化？<br>答：<br>能被序列化：<br>（1）属性<br>（2）类型；<br>不能被序列化：<br>（1）static的属性；<br>（2）方法，<br>（3）加了transient修饰符的属性。</p>
<p>24 什么是java序列化，如何实现java序列化？<br>答：<br>（1）序列化而就是一种处理对象流的机制，所谓对象流也就是对象的内容进行流化。<br>（2）实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputSream对象，接着使用ObjectOutputSream对象的writeObject方法就可以将参数obj对象写出，要恢复的话则使用输入流。</p>
<p>1.抽象：<br>　答：<br>  抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p>2.继承：<br>　答：<br>  继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>
<p>3.封装：<br>　答：<br>   封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<ol start="4">
<li>多态性：<br> 答：<br> 　多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li>
</ol>
<p>5、String是最基本的数据类型吗?<br>　答：<br>  基本数据类型有8个，包括byte、short、int、long、char、float、double和boolean。<br>　java.lang.String是类，不属于基本数据类型。</p>
<p>6、int 和 Integer 有什么区别<br>　Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。</p>
<p>小张到X软件公司实习，第一天程序员老李为摸底，问了他一个问题：Java中的有8个基本数据类型，这破坏了面向对象的思想，为此Java提供了封装类，那么这些封装类具体有哪些？请代小张回答（至少回答出其中六个即可得满分）</p>
<p>Java为每个原始类型提供了封装类。<br>原始类型       封装类<br>boolean      Boolean<br>char          Character<br>byte          Byte<br>short          Short<br>int          Integer<br>long          Long<br>float          Float<br>double      Double<br>　引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p>
<p>7、实习程序员小张，接到X项目组经理命令完成某模块代码开发。在设计中，该模块算法中特别提到将有大量字符串的拼接。编码过程中，小张准备使用自己熟悉的String对象类完成这段代码，并向程序员老王征求意见，谁知老王否定了小张用String类型的方案，并建议他此处使用StringBuffer对象更合适，这令小张有些困惑。请帮小张分析下为何此处要用StringBuffer？<br>  即回答：String 和StringBuffer的区别<br>　答：<br>  JAVA平台提供了两个类：String和StringBuffer。<br>  String不是简单类型，而是一个类，它被用来表示字符序列。String的特点是一旦赋值，便不能更改其指向的字符对象，如果更改，则会生成一个新的字符串对象。<br>  StringBuffer是一个具有对象引用传递特点的字符串对象。StringBuffer对象可以调用其方法动态的进行增加、插入、修改和删除操作，从而实现多次插入字符，而不用担心像String类那样不断产生新对象而消耗内存，因而在字符串变化较多的操作中，效率更高。</p>
<p>9、&amp;和&amp;&amp;的区别。<br>   答： &amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p>
<p>10、final, finally的区别。<br>　　答：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改（相当于常量）。被声明为final的方法也同样只能使用，不能覆盖。<br>    finally是异常处理语句结构的一部分，表示总是执行。一般在异常处理时提供 finally 块来执行任何清除操作。</p>
<p>11、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?<br>　  答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<p>12、error和exception有什么区别?<br>　 答：error 表示恢复不是不可能但很困难的情况下的一种严重问题，是一种系统性的错误，程序本身不能处理这样的情况，比如说内存溢出。<br>      exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，是不会发生这种错误的。</p>
<p>13、abstract class和interface有什么区别?<br>　  答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。     Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>　   接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<p>14、GC是什么? 为什么要有GC?<br>　　答：1）GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或错误的内存回收会导致程序或系统的不稳定，甚至崩溃；2）Java提供的垃圾回收机制（GC）可以自动监测对象是否超过作用域从而达到自动回收内存的目的；3）Java不提供显示释放已分配内存的操作方法。</p>
<p>15、分析题<br>    1）short s1 = 1; s1 = s1 + 1;有什么错?<br>    答：short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，int数据1给short型变量s1，需要强制转换类型）<br>    2）short s1 = 1; s1 += 1;有什么错?<br>    答：本题无措short s1 = 1; s1 += 1;（可以正确编译）</p>
<p>16、分析题：Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>    答：Math.round(11.5)==12<br>        Math.round(-11.5)==-11<br>        round方法返回与参数最接近的长整数，参数加1/2后求其floor.</p>
<p>17、String s = new String(“xyz”);创建了几个String Object?<br>    答：两个对象，一个是在字符串池中的对象“xyx”,引用对象s指向的堆空间的对象“xyx”。其中，堆空间的对象“xyz”是字符串池中字符串“xyz”的副本。    </p>
<p>18、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?<br>　  答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。</p>
<p>19、数组有没有length()这个方法? String有没有length()这个方法？<br>　  答：数组没有length()这个方法，只有length的属性，用来得到数组元素个数。<br>        String有length()这个方法，用来得到字符串长度。</p>
<p>20、构造器Constructor是否可被override?<br>　  答：构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。</p>
<p>21、是否可以继承String类?<br>　  答：String类是final类，故不可以继承。</p>
<p>22、swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?<br>　  答：switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。<br>       long,string 都不能作用于swtich。</p>
<p>23、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?<br>　  答：会执行，在return前执行。</p>
<p>24、编程题: 用最有效率的方法算出2乘以8等於几?<br>    答：用位运算符“&lt;&lt;”，语句写为：2 &lt;&lt; 3;</p>
<p>25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>　  答：<br>    是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p>
<p>26、Java中的异常处理机制的简单原理和应用。<br>　   答：<br>     当JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。</p>
<p>27、描述一下JVM加载class文件的原理机制?<br>　  答：JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<p>28、char型变量中能不能存贮一个中文汉字?为什么?<br>　  答：能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的</p>
<p>29、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?<br>    答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>    同步的实现方面有两种，分别是synchronized,wait与notify</p>
<p>30、线程的基本概念、线程的基本状态以及状态之间的关系<br>　 答：<br>   线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。<br>   Java中的线程有四种状态分别是：运行、就绪、挂起、结束。 </p>
<p>=============================================<br>论述题<br>31、谈谈对Java语言中异常处理的理解？（<br>    1）可以从异常处理包含哪些关键字；每个关键字的含义或作用；引用异常处理后对开发有哪些帮助；异常处理机制的类体系结构；异常处理实现的底层机制等角度进行分析（但不限于这些角度）；<br>    2）能正确答出3个及以上点，且字数超过200字，则得满分。答案仅供参考，不唯一<br>   ）<br>    答：<br>    1、基本概念<br>    Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p>
<pre><code>2、5个主要关键字的作用
用try来指定一块预防所有&quot;异常&quot;的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的&quot;异常&quot;的类型。
finally为确保一段代码不管发生什么&quot;异常&quot;都被执行一段代码。
throw语句用来明确地抛出一个&quot;异常&quot;。
throws用来标明一个成员函数可能抛出的各种&quot;异常&quot;。

3、实现的机制
Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。
4、采用异常处理机制的好处
可以提高Java语言的处理错误能力；可以帮助程序员调试程序，发现开发中的问题，提高开发效率；可以让Java程序有健壮性，程序不容易崩溃；</code></pre>
<p>===========================================================</p>
<p>32、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>   答：1）可以。<br>       2）只有一个类的类名能与Java程序的该源文件名相同。</p>
<p>33、java中实现多态的机制是什么（Java借助什么实现多态性）？<br>　 答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。<br>      重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。</p>
<p>34、在JAVA中，如何跳出当前的多重嵌套循环？<br>    答：用break; return 方法。</p>
<p>35、Java是从（  B  ）语言改进重新设计而发展来的？<br>A. Ada    B. C++    C.Pascal  D.BASIC<br>分析：Java是从C、C++发展过来的</p>
<p>36、研究下面Java代码<br>public class TestException{<br>    public static void main(String args[]){<br>        try{<br>            System.out.println(“hello,jr”);<br>            System.exit(0);<br>        }finally{<br>            System.out.println(“88”);<br>        }<br>    }<br>}<br>输出结果为：（  A  ）<br>A. hello,jr<br>B. 88<br>C. hello,jr后是88<br>D. 不能编译<br>分析：System.exit(0);会中断程序，即使是finally都无法被执行</p>
<p>37、下面说法正确的有（  C   ）<br>A. class中的contructor不可省略<br>B. contructor必须与class同名，但方法不能与class同名<br>C. contructor在一个对象被new时执行<br>D. 一个class只能定义一个contructor</p>
<p>分析：contructor就是指的构造方法，普通方法也可以和类同名</p>
<p>38、在java中，已定义两个接口B和C，要定义一个实现这两个接口的类，以下语句正确的是（  C  ）<br>A. interface A extends B,C<br>B. interface A implements B,C<br>C. class A implements B,C<br>D. class A implements B,implements C</p>
<p>分析：类实现接口的基本语法</p>
<p>39、当编译并允许下面程序时，会发生什么结果？（   D   ）<br>public class Demo{<br>    protected Demo(){<br>        for(int i=0;i&lt;10;i++){<br>            System.out.println(i);<br>        }<br>    }</p>
<pre><code>public static void main(String args[])&#123;
    Demo d=new Demo();
&#125;</code></pre>
<p>}<br>A. 编译错误，构造方法不能被声明为protected<br>B. 允许错误，构造方法不能被声明为protected<br>C. 编译并运行输出0到10<br>D. 编译并运行输出0到9</p>
<p>分析：本题程序无错误可正常运行，构造方法是可以定义为protected的。</p>
<p>40、当编译和运行下面程序时，哪项描述可以最准确的表达发生了什么事情（   B    ）<br>public class MyAr{</p>
<pre><code>public void amethod()&#123;
    int i;
    System.out.println(i);    
&#125;

public static void main(String args[])&#123;
    MyAr m=new MyAr();
    m.amethod();
&#125;</code></pre>
<p>}<br>A. 编译并输出0<br>B. 编译错误<br>C. 编译并输出null<br>D. 运行错误</p>
<p>分析： 方法amethod()中定义的变量：int i; 是一个方法级别的变量，必须手动赋予初值，否则编译错误。<br>       注意：成员变量系统给默认值，如果不显示手动赋值，依然是正确的。</p>
<p>41、给定java代码如下，关于super的用法，以下描述正确的是（    C   ）<br>class C extends B{<br>    public C(){<br>        super();<br>    }<br>}<br>A. 用来调用类B中定义的super()方法<br>B. 用来调用类C中定义的super()方法<br>C. 用来调用类B中的无参构造方法<br>D. 用来调用类B中第一个出现的构造方法</p>
<p>分析：super()的含义是用来调用父类（B）中不带参数的构造方法。super()的用法，一般出现在子类构造方法中第一行。</p>
<p>42、下列语句正确的是（   A  ）<br>A) 形式参数可被视为local variable<br>B) 形式参数可被字段修饰符修饰<br>C) 形式参数为方法被调用时，真正被传递的参数<br>D) 形式参数不可以是对象</p>
<p>分析：B项无此说法，C中被真正传递的是实参，D中形参可以使对象</p>
<p>43、以下代码输出结果为（  C    ）<br>public class Test{<br>    public static String output=””;</p>
<pre><code>public static void foo(int i)&#123;
    try&#123;
        if(i==1)
            throw new Exception();

        output+=&quot;1&quot;;            
    &#125;catch(Exception e)&#123;
        output+=&quot;2&quot;;
        return ;
    &#125;finally&#123;
        output+=&quot;3&quot;;
        output+=&quot;4&quot;;
    &#125;
&#125;

public static void main(String args[])&#123;
    foo(0);
    foo(1);
    System.out.println(output);
&#125;</code></pre>
<p>}<br>A. 1342        B. 123        C. 134234    D. 13423</p>
<p>分析：本题中，foo(0)时，if语句if(i==1)throw new Exception();不满足条件，不会抛出异常，因此此时output值为“134”；<br>      紧接着执行foo(1)时，if语句if(i==1)throw new Exception();满足条件，抛出异常，执行catch语句，output值变成“1342”；<br>      最难点在于此时碰到了return，是否还会执行finally语句，答案是会执行，因此最后output值变成“134234”；答案为C。</p>
<p>44、在Java中，下列（  D    ）类不能派生出子类？<br>A) public class MyClass{ … }<br>B) class MyClass{ … }<br>C) abstract class MyClass{ … }<br>D) final class MyClass{    … }</p>
<p>分析：类前面可以有public和默认两种权限，一般都能被子类继承，因此A、B答案可以派生子类<br>      C答案是抽象类，也可以被继承<br>      D答案是final修饰的类，是最终类，不允许被继承。</p>
<p>45、编译和运行下面代码时显示结果是（     ）<br>public class Conv{<br>    public static void main(String argv[]){<br>            Conv c=new Conv();<br>            String s=new String(“ello”);<br>            c.amethod(s);<br>    }<br>    public void amethod(String s){<br>            char c=’H’;<br>            c+=s;<br>            System.out.println(c);<br>    }<br>}<br>A、Hello<br>B、ello<br>C、elloH<br>D、编译错误<br>解答：D<br>分析：c是字符类型，s是字符串类型，字符型无法自动转换成字符串类型，因此语句c+=s;类型不兼容，有语法错误，故答案是D<br>修改方案：将char c=’H’;语句变为String c=”H”;</p>
<p>46、当下列程序执行时，其输出结果是（     ）。<br>int i=9;<br>switch (i) {<br> default:<br> System.out.println(“default”);<br> case 0:<br> System.out.println(“zero”);<br> break;<br> case 1:<br> System.out.println(“one”);<br> case 2:<br> System.out.println(“two”);<br>}<br>A、default<br>B、default, zero<br>C、错误： default 子句没有定义<br>D、没有输出结果<br>解答：Ｂ<br>原因：程序开始遇到default关键字，会执行其语句块中语句，输出“default”；<br>由于default语句块中没有结束switch语句的关键字break;<br>所以程序会继续执行其他case块中语句，并且无需验证case的值匹配；运行到case 0语句块时，首先输出“zero”，最后碰到break语句，结束整个switch语句块。<br>故最后输出结果：<br>default<br>zero</p>
<p>47、阅读下列代码，其正确的结果是（     ）。<br>publicclass Test2 {<br>    static boolean foo(char c) {<br>       System.out.print(c);<br>       return true;<br>    }<br>    Public static void main(String[] argv) {<br>       int i = 0;<br>       //for(65;88&amp;&amp;(i&lt;2);67)<br>       for (foo(‘A’); foo(‘B’) &amp;&amp; (i &lt; 2); foo(‘C’)) {<br>           i++;<br>           foo(‘D’);<br>       }<br>    }<br>}<br>A. ABDCBDCB<br>B. ABCDABCD<br>C. Compilation fails.<br>D. An exception is thrown at runtimeB、1<br>解答：A</p>
<p>48、有以下程序段：<br>class MyThread extends Thread {<br>    public static void main(String args[]) {<br>        MyThread t = new MyThread();<br>        MyThread s = new MyThread();<br>        t.start();<br>        System.out.print(“one.”);<br>        s.start();<br>        System.out.print(“two.”);<br>    }<br>    public void run() {<br>        System.out.print(“Thread”);<br>    }<br>}<br>则下列选项说法正确的是（     ）。<br>A、编译失败<br>B、程序运行结果为：one.Threadtwo.Thread<br>C、程序运行结果是：one.two.ThreaThread<br>D、程序运行结果不确定<br>解答：D<br>分析：线程是并行运行，故结果输出顺序是不确定。<br>部分同学计算机运行几次时，可能会发现结果确定，<br>是因计算机速度太快导致，可以多次运行十几次或几十次，可以发现结果有变化</p>
<p>49、仔细分析下面程序，其正确的输出结果是（     ）。<br>publicclass Test1 {<br>    public static void changeStr(String str){   //②str<br>        str=”welcome”;<br>    }<br>    public staticvoid main(String[] args) {<br>        String str=”1234”;               //①str<br>        changeStr(str);<br>        System.out.println(str);<br>    }<br>}<br>A、welcome<br>B、welcome1234<br>C、1234<br>D、1234welcome<br>解答：C</p>
<p>分析：<br>1）主方法中的①号变量str是实际参数，changeStr(String str)中的②号str是形式参数，虽然是两个同名字变量，但实际是两个变量。</p>
<p>2）Java字符串基于字符串池实现，虽然①号str传值给了②号str，并且传的是引用，<br>   但②号str中执行语句str=”welcome”;后，并没有修改”1234”这个值本身，而是在字符串池中，新增加了一个字符串常量”welcome”，<br>   ②号str的引用指向了新的”welcome”值，但①号str指向的值”1234”没有被修改，因此主方法中打印输出的①号str的值还是1234</p>
<p>3）这里要注意，正常情况下，给方法的参数传值，当值是对象类型时，是引用传递。（若是基本数据类型，则是值传递）<br>   引用传递的确是可以利用方法来修改引用指向对的成员变量值的，字符串类（String）因其实现的机制是基于字符串池，故情况特殊<br>   参见下面代码对比：</p>
<p>class Stu{<br>    int stuAge;<br>}<br>public class Test1 {<br>    public static void changeStu(Stu stu){<br>        stu.stuAge=100;<br>    }<br>    public static void changeStr(String str){<br>        str=”welcome”;<br>    }<br>    public static void main(String[] args) {<br>        String str=”1234”;<br>        changeStr(str);               //Java字符串基于字符串池实现，因此不是简单的传递引用<br>        System.out.println(str);<br>//        Stu s=new Stu();<br>//        s.stuAge=20;<br>//        changeStu(s);                //对象类型传的是引用<br>//        System.out.println(s.stuAge);//输出100<br>    }<br>}  </p>
<p>50、下面2个文件位于相同目录下，编译运行后会出现的情况是（      ）。<br>//File P1.java<br>package MyPackage;<br>class P1{<br>void afancymethod(){<br>        System.out.println(“What a fancy method”);<br>        }<br>}<br>//File P2.java<br>public class P2 extends P1{<br>    public static void main(String argv[]){<br>    P2 p2 = new P2();<br>    p2.afancymethod();<br>    }<br>}<br>A、2个文件都可以编译，P2运行输出“What a fancy method”<br>B、2个文件都不能编译<br>C、2个文件都可以编译，P2运行时报错误<br>D、P1编译成功，P2编译时报错误<br>解答：D</p>
<p>51、编译和运行下面代码时显示的结果是（     ）。<br>public class MyClass{<br> static int i;<br> public static void main(String argv[]){<br>     System.out.println(i);<br> }<br>}<br>A、Error Variable i may not have been initializenull<br>C、1<br>D、0<br>解答：D<br>分析：本题能正常运行，static int i;中定义的i是静态成员变量，Java中成员变量默认给了初值，整型的初值是0，故此题正确</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/22/fastapi%E5%A4%9A%E6%96%87%E4%BB%B6/" rel="prev" title="fastapi多文件">
      <i class="fa fa-chevron-left"></i> fastapi多文件
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="pty"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">pty</p>
  <div class="site-description" itemprop="description">努力最坏的结果不过是大器晚成</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/penty7710" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;penty7710" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1219002685@qq.com" title="E-Mail → mailto:1219002685@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pty</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<script src="/js/prism/prism.js" async></script>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
