<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pety&#39;s blog</title>
  
  <subtitle>少年，你渴望力量吗</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-12T14:38:54.557Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pty</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty</title>
    <link href="http://example.com/2022/08/12/Netty/"/>
    <id>http://example.com/2022/08/12/Netty/</id>
    <published>2022-08-12T14:48:35.310Z</published>
    <updated>2022-08-12T14:38:54.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><blockquote><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如</p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、启动器，负责装配netty组件，启动服务器</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                <span class="hljs-comment">// 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector</span><br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 3、选择服务器的 ServerSocketChannel 实现</span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">// 4、child 负责处理读写，该方法决定了 child 执行哪些操作</span><br>            <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>            <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf=&gt;String</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                        <span class="hljs-comment">// 6、SocketChannel的业务处理，使用上一个处理器的处理结果</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(s);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                    <span class="hljs-comment">// 7、ServerSocketChannel绑定8080端口</span><br>                &#125;).bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现</span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>                <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 编码发出</span><br>                        channel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 指定要连接的服务器和端口</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                <span class="hljs-comment">// Netty 中很多方法都是异步的，如 connect</span><br>                <span class="hljs-comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span><br>                .sync()<br>                <span class="hljs-comment">// 获取 channel 对象，它即为通道抽象，可以进行数据读写操作</span><br>                .channel()<br>                <span class="hljs-comment">// 写入消息并清空缓冲区</span><br>                .writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220218561.png" alt="image-20220812220218561"></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li>channel 可以理解为数据的通道</li><li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>handler 可以理解为数据的处理工序<ul><li>工序有多道，<strong>合在一起就是 pipeline（传递途径）</strong>，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li>handler 分 Inbound 和 Outbound 两类<ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li>eventLoop 可以理解为处理数据的工人<ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEventLoop</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 通过next方法可以获得下一个 EventLoop</span><br>        System.out.println(group.next());<br>        System.out.println(group.next());<br><br>        <span class="hljs-comment">// 通过EventLoop执行普通任务</span><br>        group.next().execute(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过EventLoop执行定时任务</span><br>        group.next().scheduleAtFixedRate(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello2&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 优雅地关闭</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">io.netty.channel.nio.NioEventLoop@7bb11784<br>io.netty.channel.nio.NioEventLoop@33a10788<br>nioEventLoopGroup-2-1 hello<br>nioEventLoopGroup-2-2 hello2<br>nioEventLoopGroup-2-2 hello2<br>nioEventLoopGroup-2-2 hello2<br></code></pre></td></tr></table></figure><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br><br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        Channel channel = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                .sync()<br>                .channel();<br>        System.out.println(channel);<br>        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">public class MyServer &#123;<br>    public static void main(String[] args) &#123;<br>        new ServerBootstrap()<br>            // 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件<br>                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))<br>            <br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个客户端分别发送 <code>hello</code> 结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">nioEventLoopGroup-3-1 hello1<br>nioEventLoopGroup-3-2 hello2<br>nioEventLoopGroup-3-1 hello3<br>nioEventLoopGroup-3-2 hello4<br>nioEventLoopGroup-3-2 hello4<br></code></pre></td></tr></table></figure><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220458021.png" alt="image-20220812220458021"></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 增加自定义的非NioEventLoopGroup</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> DefaultEventLoopGroup();<br>        <br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>))<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;nioHandler&quot;</span>,<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br>                                <span class="hljs-comment">// 调用下一个handler</span><br>                                ctx.fireChannelRead(msg);<br>                            &#125;<br>                        &#125;)<br>                        <span class="hljs-comment">// 该handler绑定自定义的Group</span><br>                        .addLast(group, <span class="hljs-string">&quot;myHandler&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动四个客户端发送数据</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">nioEventLoopGroup-4-1 hello1<br>defaultEventLoopGroup-2-1 hello1<br>nioEventLoopGroup-4-2 hello2<br>defaultEventLoopGroup-2-2 hello2<br>nioEventLoopGroup-4-1 hello3<br>defaultEventLoopGroup-2-3 hello3<br>nioEventLoopGroup-4-2 hello4<br>defaultEventLoopGroup-2-4 hello4<br></code></pre></td></tr></table></figure><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220542209.png" alt="image-20220812220542209"></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span><br>    EventExecutor executor = next.executor();<br>    <br>    <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span><br>        next.invokeChannelRead(m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span><br>        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>            <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br>        <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>        channelFuture.sync();<br>        <br>        <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>        Channel channel = channelFuture.channel();<br>        channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br><span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Channel channel = channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建EventLoopGroup，使用完毕后关闭</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <br>        ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        channelFuture.sync();<br><br>        Channel channel = channelFuture.channel();<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>        <span class="hljs-comment">// 创建一个线程用于输入并向服务器发送</span><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                String msg = scanner.next();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(msg)) &#123;<br>                    <span class="hljs-comment">// 关闭操作是异步的，在NIO线程中执行</span><br>                    channel.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(msg);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;inputThread&quot;</span>).start();<br><br>        <span class="hljs-comment">// 获得closeFuture对象</span><br>        ChannelFuture closeFuture = channel.closeFuture();<br>        System.out.println(<span class="hljs-string">&quot;waiting close...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 同步等待NIO线程执行完close操作</span><br>        closeFuture.sync();<br>        <br>        <span class="hljs-comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span><br>        System.out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 获得closeFuture对象<br>ChannelFuture closeFuture = channel.closeFuture();<br><br>// 同步等待NIO线程执行完close操作<br>closeFuture.sync();<br></code></pre></td></tr></table></figure></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">closeFuture.addListener(new ChannelFutureListener() &#123;<br>    @Override<br>    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;<br>        // 等待channel关闭后才执行的操作<br>        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);<br>        // 关闭EventLoopGroup<br>        group.shutdownGracefully();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkFuture</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;JdkFuture&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 创建线程池</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>), factory);<br><br>        <span class="hljs-comment">// 获得Future对象</span><br>        Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过阻塞的方式，获得运行结果</span><br>        System.out.println(future.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyFuture</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-comment">// 获得 EventLoop 对象</span><br>        EventLoop eventLoop = group.next();<br>        Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 主线程中获取结果</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.getNow());<br>        System.out.println(<span class="hljs-string">&quot;get &quot;</span> + future.get());<br><br>        <span class="hljs-comment">// NIO线程中异步获取结果</span><br>        future.addListener(<span class="hljs-keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="hljs-keyword">super</span> Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-keyword">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.getNow());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">main 获取结果<br>getNow null<br>get 50<br>nioEventLoopGroup-2-1 获取结果<br>getNow 50<br></code></pre></td></tr></table></figure><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyPromise</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建EventLoop</span><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoop eventLoop = group.next();<br><br>        <span class="hljs-comment">// 创建Promise对象，用于存放结果</span><br>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);<br><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 自定义线程向Promise中存放结果</span><br>            promise.setSuccess(<span class="hljs-number">50</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 主线程从Promise中获取结果</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + promise.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PipeLineServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 在socketChannel的pipeline中添加handler</span><br>                        <span class="hljs-comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span><br>     <span class="hljs-comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span><br>                        <span class="hljs-comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span><br>                        <span class="hljs-comment">// 入站时，handler是从head向后调用的</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler1&quot;</span> ,<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Inbound handler 1&quot;</span>);<br>                                <span class="hljs-comment">// 父类该方法内部会调用fireChannelRead</span><br>                                <span class="hljs-comment">// 将数据传递给下一个handler</span><br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Inbound handler 2&quot;</span>);<br>                                <span class="hljs-comment">// 执行write操作，使得Outbound的方法能够得到调用</span><br>          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="hljs-string">&quot;Server...&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>                                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span><br>                        <span class="hljs-comment">// 出站时，handler的调用是从tail向前调用的</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler3&quot;</span> ,<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Outbound handler 1&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler4&quot;</span> ,<span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Outbound handler 2&quot;</span>);<br>                                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">nioEventLoopGroup-2-2 Inbound handler 1<br>nioEventLoopGroup-2-2 Inbound handler 2<br>nioEventLoopGroup-2-2 Outbound handler 2<br>nioEventLoopGroup-2-2 Outbound handler 1<br></code></pre></td></tr></table></figure><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220802980.png" alt="image-20220812220802980"></p><p><strong>调用顺序如下</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220817795.png" alt="image-20220812220817795"></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220842203.png" alt="image-20220812220842203"></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220857626.png" alt="image-20220812220857626"></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEmbeddedChannel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ChannelInboundHandlerAdapter h1 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        ChannelInboundHandlerAdapter h2 = <span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h3 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        ChannelOutboundHandlerAdapter h4 = <span class="hljs-keyword">new</span> ChannelOutboundHandlerAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>                <span class="hljs-keyword">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 用于测试Handler的Channel</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(h1, h2, h3, h4);<br>        <br>        <span class="hljs-comment">// 执行Inbound操作 </span><br>        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">// 执行Outbound操作</span><br>        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(ByteBuf buffer)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = buffer.readableBytes();<br>    <span class="hljs-keyword">int</span> rows = length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>        .append(NEWLINE);<br>    appendPrettyHexDump(buf, buffer);<br>    System.out.println(buf.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br><br>        <span class="hljs-comment">// 查看写入结果</span><br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">read index:0 write index:0 capacity:16<br><br>read index:0 write index:20 capacity:64<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|<br>|00000010| 61 61 61 61                                     |aaaa            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br><br>        buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br><br>        buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeDirectByteBuf</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">// 使用池化的堆内存    </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeHeapByteBuf</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">// 使用池化的直接内存    </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">io</span>.<span class="hljs-title">netty</span>.<span class="hljs-title">buffer</span>.<span class="hljs-title">PooledUnsafeDirectByteBuf</span></span><br></code></pre></td></tr></table></figure><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812220939175.png" alt="image-20220812220939175"></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeInt(<span class="hljs-number">5</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeIntLE(<span class="hljs-number">6</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeLong(<span class="hljs-number">7</span>);<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tex">read index:0 write index:0 capacity:16<br><br>read index:0 write index:4 capacity:16<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:0 write index:8 capacity:16<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:0 write index:12 capacity:16<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |<br>+--------+-------------------------------------------------+----------------+<br><br>read index:0 write index:20 capacity:20<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br>|00000010| 00 00 00 07                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex">buffer.writeLong(7);<br>ByteBufUtil.log(buffer);<br>// 扩容前<br>read index:0 write index:12 capacity:16<br>...<br><br>// 扩容后<br>read index:0 write index:20 capacity:20<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br>|00000010| 00 00 00 07                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h4 id="扩容规则te"><a href="#扩容规则te" class="headerlink" title="扩容规则te"></a>扩容规则te</h4><ul><li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p><ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p><p>n</p><ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li></ul></li><li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20/20)<br>...<br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        buffer.writeInt(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 读取4个字节</span><br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 通过mark与reset实现重复读取</span><br>        buffer.markReaderIndex();<br>        System.out.println(buffer.readInt());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 恢复到mark标记处</span><br>        buffer.resetReaderIndex();<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><span class="hljs-number">5</span><br>read index:<span class="hljs-number">8</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br><br>read index:<span class="hljs-number">4</span> write index:<span class="hljs-number">8</span> capacity:<span class="hljs-number">16</span><br>         +-------------------------------------------------+<br>         |  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|<span class="hljs-number">00000000</span>| <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span>                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">while (!buffer.release()) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 具体的释放方法</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br><span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221019762.png" alt="image-20220812221019762"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSlice</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        ByteBuf slice1 = buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        ByteBuf slice2 = buffer.slice(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.retain();<br>        slice2.retain();<br>        <br>        ByteBufUtil.log(slice1);<br>        ByteBufUtil.log(slice2);<br><br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.println(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.setByte(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        ByteBufUtil.log(slice1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tex">read index:0 write index:5 capacity:5<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 01 02 03 04 05                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br>read index:0 write index:5 capacity:5<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 06 07 08 09 0a                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:0 write index:5 capacity:5<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 05 02 03 04 05                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudyServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接建立时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">// 连接断开时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stopped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> StudyServer().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tex">public class StudyClient &#123;<br>    static final Logger log = LoggerFactory.getLogger(StudyClient.class);<br>    public static void main(String[] args) &#123;<br>        NioEventLoopGroup worker = new NioEventLoopGroup();<br>        try &#123;<br>            Bootstrap bootstrap = new Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                @Override<br>                protected void initChannel(SocketChannel ch) throws Exception &#123;<br>                    log.debug(&quot;connected...&quot;);<br>                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;<br>                        @Override<br>                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;<br>                            log.debug(&quot;sending...&quot;);<br>                            // 每次发送16个字节的数据，共发送10次<br>                            for (int i = 0; i &lt; 10; i++) &#123;<br>                                ByteBuf buffer = ctx.alloc().buffer();<br>                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; catch (InterruptedException e) &#123;<br>            log.error(&quot;client error&quot;, e);<br>        &#125; finally &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器接收结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:/127.0.0.1:8080 - R:/127.0.0.1:53797] READ: 160B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 调整channel的容量<br>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tex">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 36B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000020| 00 01 02 03                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000020| 04 05 06 07 08 09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br>|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br>|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000020| 04 05 06 07 08 09 0a 0b                         |........        |<br>+--------+-------------------------------------------------+----------------+<br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 4B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 0c 0d 0e 0f                                     |....            |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>    ByteBuf buffer = ctx.alloc().buffer(<span class="hljs-number">16</span>);<br>    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>    ctx.writeAndFlush(buffer);<br>    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span><br>    ctx.channel().close();<br>&#125;<br></code></pre></td></tr></table></figure><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送10次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        send();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tex">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] ACTIVE<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 ! R:/127.0.0.1:65024] INACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] ACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 ! R:/127.0.0.1:65057] INACTIVE<br><br>...<br></code></pre></td></tr></table></figure><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<br></code></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为16</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 向服务器发送10个报文</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>    <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span><br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[maxLength];<br>    <span class="hljs-comment">// 生成长度为0~15的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(Math.random()*(maxLength-<span class="hljs-number">1</span>)); j++) &#123;<br>        bytes[j] = (<span class="hljs-keyword">byte</span>) c;<br>    &#125;<br>    buffer.writeBytes(bytes);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.writeAndFlush(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 通过定长解码器对粘包数据进行拆分<br>ch.pipeline().addLast(new FixedLengthFrameDecoder(16));<br>ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tex">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|<br>+--------+-------------------------------------------------+----------------+<br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|<br>+--------+-------------------------------------------------+----------------+<br><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)**为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）**</p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为 64</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">64</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.alloc().buffer(maxLength);<br>    <span class="hljs-comment">// 生成长度为0~62的数据</span><br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-keyword">int</span>)(random.nextInt(maxLength-<span class="hljs-number">2</span>)); j++) &#123;<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-comment">// 数据以 \n 结尾</span><br>    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.writeAndFlush(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 通过行解码器对粘包数据进行拆分，以 <span class="hljs-tag">\<span class="hljs-name">n</span></span> 为分隔符<br>// 需要指定最大长度<br>ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));<br>ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tex">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 10B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |<br>+--------+-------------------------------------------------+----------------+<br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 11B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |<br>+--------+-------------------------------------------------+----------------+<br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 2B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 63 63                                           |cc              |<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">...<br>    <br>// 数据以 <span class="hljs-tag">\<span class="hljs-name">c</span></span> 结尾<br>sb.append(&quot;<span class="hljs-tag">\<span class="hljs-name">\</span></span>c&quot;);<br>buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br><br>...<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 将分隔符放入ByteBuf中<br>ByteBuf bufSet = ch.alloc().buffer().writeBytes(&quot;<span class="hljs-tag">\<span class="hljs-name">\</span></span>c&quot;.getBytes(StandardCharsets.UTF_8));<br>// 通过行解码器对粘包数据进行拆分，以 <span class="hljs-tag">\<span class="hljs-name">c</span></span> 为分隔符<br>ch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));<br>ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tex">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 14B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |<br>+--------+-------------------------------------------------+----------------+<br><br><br>8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 3B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 62 62 62                                        |bbb             |<br>+--------+-------------------------------------------------+----------------+<br><br>...<br></code></pre></td></tr></table></figure><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> maxFrameLength,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> lengthFieldOffset, <span class="hljs-keyword">int</span> lengthFieldLength,</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span> lengthAdjustment, <span class="hljs-keyword">int</span> initialBytesToStrip)</span></span><br></code></pre></td></tr></table></figure><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221105822.png" alt="image-20220812221105822"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TEX">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0 (= do not strip header)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br>+--------+----------------+      +--------+----------------+<br>| Length | Actual Content |-----&gt;| Length | Actual Content |<br>| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |<br>+--------+----------------+      +--------+----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 2 (= the length of the Length field)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)<br>+--------+----------------+      +----------------+<br>| Length | Actual Content |-----&gt;| Actual Content |<br>| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |<br>+--------+----------------+      +----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 2 (= the length of Header 1)<br>lengthFieldLength   = 3<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |<br>|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 0<br>lengthFieldLength   = 3<br>lengthAdjustment    = 2 (= the length of Header 1)<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |<br>| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p><hr><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">lengthFieldOffset   = 1 (= the length of HDR1)<br>lengthFieldLength   = 2<br>lengthAdjustment    = 1 (= the length of HDR2)<br>initialBytesToStrip = 3 (= the length of HDR1 + LEN)<br>  <br>BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br>+------+--------+------+----------------+      +------+----------------+<br>| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |<br>| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |<br>+------+--------+------+----------------+      +------+----------------+<br></code></pre></td></tr></table></figure><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncoderStudy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟服务器</span><br>        <span class="hljs-comment">// 使用EmbeddedChannel测试handler</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel(<br>                <span class="hljs-comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span><br>                <span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>                <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG)<br>        );<br><br>        <span class="hljs-comment">// 模拟客户端，写入数据</span><br>        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();<br>        send(buffer, <span class="hljs-string">&quot;Hello&quot;</span>);<br>        channel.writeInbound(buffer);<br>        send(buffer, <span class="hljs-string">&quot;World&quot;</span>);<br>        channel.writeInbound(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ByteBuf buf, String msg)</span> </span>&#123;<br>        <span class="hljs-comment">// 得到数据的长度</span><br>        <span class="hljs-keyword">int</span> length = msg.length();<br>        <span class="hljs-keyword">byte</span>[] bytes = msg.getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-comment">// 将数据信息写入buf</span><br>        <span class="hljs-comment">// 写入长度标识前的其他信息</span><br>        buf.writeByte(<span class="hljs-number">0xCA</span>);<br>        <span class="hljs-comment">// 写入数据长度标识</span><br>        buf.writeInt(length);<br>        <span class="hljs-comment">// 写入长度标识后的其他信息</span><br>        buf.writeByte(<span class="hljs-number">0xFE</span>);<br>        <span class="hljs-comment">// 写入具体的数据</span><br>        buf.writeBytes(bytes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tex">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |<br>+--------+-------------------------------------------------+----------------+<br><br>146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 该指令一共有3部分，每条指令之后都要添加回车与换行符<br>*3<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><br>// 第一个指令的长度是3<br><span class="hljs-formula">$3<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br><span class="hljs-formula">// 第一个指令是set指令</span><br><span class="hljs-formula">set<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br><span class="hljs-formula">// 下面的指令以此类推</span><br><span class="hljs-formula">$</span>4<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><br>name<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span><br><span class="hljs-formula">$5<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br><span class="hljs-formula">Nyima<span class="hljs-tag">\<span class="hljs-name">r</span></span><span class="hljs-tag">\<span class="hljs-name">n</span></span></span><br></code></pre></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group =  <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = <span class="hljs-keyword">new</span> Bootstrap()<br>                    .group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            <span class="hljs-comment">// 打印日志</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                    <span class="hljs-comment">// 回车与换行符</span><br>                                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] LINE = &#123;<span class="hljs-string">&#x27;\r&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>&#125;;<br>                                    <span class="hljs-comment">// 获得ByteBuf</span><br>                                    ByteBuf buffer = ctx.alloc().buffer();<br>                                    <span class="hljs-comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span><br>                                    <span class="hljs-comment">// set name Nyima</span><br>                                    buffer.writeBytes(<span class="hljs-string">&quot;*3&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;set&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$4&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;name&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$5&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;Nyima&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    ctx.writeAndFlush(buffer);<br>                                &#125;<br><br>                            &#125;);<br>                        &#125;<br>                    &#125;)<br>                    .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>));<br>            channelFuture.sync();<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().close().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭group</span><br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台打印结果</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:/127.0.0.1:60792 - R:localhost/127.0.0.1:6379] WRITE: 34B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..<span class="hljs-formula">$3..set..$</span>4.|<br>|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..<span class="hljs-formula">$5..Nyima|</span><br><span class="hljs-formula">|00000020| 0d 0a                                           |..              |</span><br><span class="hljs-formula">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p><strong>Redis中查询执行结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span><br><span class="hljs-comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpServerUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span></span><br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                .group(group)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>                        <span class="hljs-comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpServerCodec());<br>                        <span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpRequest msg)</span> </span>&#123;<br>                                <span class="hljs-comment">// 获得请求uri</span><br>                                log.debug(msg.uri());<br><br>                                <span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>                                DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);<br>                                <span class="hljs-comment">// 设置响应内容</span><br>                                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>                                <span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>                                response.headers().setInt(CONTENT_LENGTH, bytes.length);<br>                                <span class="hljs-comment">// 设置响应体</span><br>                                response.content().writeBytes(bytes);<br><br>                                <span class="hljs-comment">// 写回响应</span><br>                                ctx.writeAndFlush(response);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;()<br></code></pre></td></tr></table></figure><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);<br><span class="hljs-comment">// 设置响应内容</span><br><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);<br><span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>response.headers().setInt(CONTENT_LENGTH, bytes.length);<br><span class="hljs-comment">// 设置响应体</span><br>response.content().writeBytes(bytes);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>浏览器</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221229452.png" alt="image-20220812221229452"></p><p>控制台</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 请求内容<br>1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] READ: 688B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET /favicon.ico|<br>|00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP/1.1..Host:|<br>|00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.|<br>|00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee|<br>|00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|<br>....<br><br>// 响应内容<br>1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] WRITE: 61B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP/1.1 200 OK.|<br>|00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:|<br>|00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello|<br>|00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;/h1&gt;   |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 设置魔数 4个字节</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-string">&#x27;N&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>&#125;);<br>        <span class="hljs-comment">// 设置版本号 1个字节</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置序列化方式 1个字节</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置指令类型 1个字节</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 设置请求序号 4个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 为了补齐为16个字节，填充1个字节的数据</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br><br>        <span class="hljs-comment">// 获得序列化后的msg</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>        oos.writeObject(msg);<br>        <span class="hljs-keyword">byte</span>[] bytes = bos.toByteArray();<br><br>        <span class="hljs-comment">// 获得并设置正文长度 长度用4个字节标识</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 设置消息正文</span><br>        out.writeBytes(bytes);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获取魔数</span><br>        <span class="hljs-keyword">int</span> magic = in.readInt();<br>        <span class="hljs-comment">// 获取版本号</span><br>        <span class="hljs-keyword">byte</span> version = in.readByte();<br>        <span class="hljs-comment">// 获得序列化方式</span><br>        <span class="hljs-keyword">byte</span> seqType = in.readByte();<br>        <span class="hljs-comment">// 获得指令类型</span><br>        <span class="hljs-keyword">byte</span> messageType = in.readByte();<br>        <span class="hljs-comment">// 获得请求序号</span><br>        <span class="hljs-keyword">int</span> sequenceId = in.readInt();<br>        <span class="hljs-comment">// 移除补齐字节</span><br>        in.readByte();<br>        <span class="hljs-comment">// 获得正文长度</span><br>        <span class="hljs-keyword">int</span> length = in.readInt();<br>        <span class="hljs-comment">// 获得正文</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));<br>        Message message = (Message) ois.readObject();<br><span class="hljs-comment">// 将信息放入List中，传递给下一个handler</span><br>        out.add(message);<br>        <br>        <span class="hljs-comment">// 打印获得的信息正文</span><br>        System.out.println(<span class="hljs-string">&quot;===========魔数===========&quot;</span>);<br>        System.out.println(magic);<br>        System.out.println(<span class="hljs-string">&quot;===========版本号===========&quot;</span>);<br>        System.out.println(version);<br>        System.out.println(<span class="hljs-string">&quot;===========序列化方法===========&quot;</span>);<br>        System.out.println(seqType);<br>        System.out.println(<span class="hljs-string">&quot;===========指令类型===========&quot;</span>);<br>        System.out.println(messageType);<br>        System.out.println(<span class="hljs-string">&quot;===========请求序号===========&quot;</span>);<br>        System.out.println(sequenceId);<br>        System.out.println(<span class="hljs-string">&quot;===========正文长度===========&quot;</span>);<br>        System.out.println(length);<br>        System.out.println(<span class="hljs-string">&quot;===========正文===========&quot;</span>);<br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">Message</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCodec</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.slf4j.Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> EmbeddedChannel();<br>        <span class="hljs-comment">// 添加解码器，避免粘包半包问题</span><br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> MessageCodec());<br>        LoginRequestMessage user = <span class="hljs-keyword">new</span> LoginRequestMessage(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-comment">// 测试编码与解码</span><br>        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();<br>        <span class="hljs-keyword">new</span> MessageCodec().encode(<span class="hljs-keyword">null</span>, user, byteBuf);<br>        channel.writeInbound(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221252096.png" alt="image-20220812221252096"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221305651.png" alt="image-20220812221305651"></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br><span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span><br>channel1.pipeline().addLast(loggingHandler);<br>channel2.pipeline().addLast(loggingHandler);<br></code></pre></td></tr></table></figure><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221329549.png" alt="image-20220812221329549"></p></li><li><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec</span>&lt;<span class="hljs-title">ByteBuf</span>, <span class="hljs-title">Message</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Session</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Channel channel, String username)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">(Channel channel)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(Channel channel, String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(Channel channel, String name, Object value)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Channel <span class="hljs-title">getChannel</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GroupSession</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">createGroup</span><span class="hljs-params">(String name, Set&lt;String&gt; members)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">joinMember</span><span class="hljs-params">(String name, String member)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">removeMember</span><span class="hljs-params">(String name, String member)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Group <span class="hljs-title">removeGroup</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Set&lt;String&gt; <span class="hljs-title">getMembers</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Channel&gt; <span class="hljs-title">getMembersChannel</span><span class="hljs-params">(String name)</span></span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断群聊是否一被创建</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 群聊名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCreated</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221410021.png" alt="image-20220812221410021"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221418916.png" alt="image-20220812221418916"></p><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClient</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatClient.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group);<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect().sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(boss, worker);<br>            bootstrap.channel(NioServerSocketChannel.class);<br>            bootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建连接时执行的处理器，用于执行登陆操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 开辟额外线程，用于用户登陆及后续操作</span><br>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br>            String username = scanner.next();<br>            System.out.println(<span class="hljs-string">&quot;请输入密码&quot;</span>);<br>            String password = scanner.next();<br>            <span class="hljs-comment">// 创建包含登录信息的请求体</span><br>            LoginRequestMessage message = <span class="hljs-keyword">new</span> LoginRequestMessage(username, password);<br>            <span class="hljs-comment">// 发送到channel中</span><br>            ctx.writeAndFlush(message);<br>            System.out.println(<span class="hljs-string">&quot;等待后续操作...&quot;</span>);<br>            <span class="hljs-comment">// 阻塞，直到登陆成功后CountDownLatch被设置为0</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                waitLogin.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 执行后续操作</span><br>            <span class="hljs-keyword">if</span> (!loginStatus.get()) &#123;<br>                <span class="hljs-comment">// 登陆失败，关闭channel并返回</span><br>                ctx.channel().close();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 登录成功后，执行其他操作</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                String command = scanner.nextLine();<br>                <span class="hljs-comment">// 获得指令及其参数，并发送对应类型消息</span><br>                String[] commands = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                <span class="hljs-keyword">switch</span> (commands[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatRequestMessage(username, commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gsend&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatRequestMessage(username,commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                        <span class="hljs-comment">// 分割，获得群员名</span><br>                        String[] members = commands[<span class="hljs-number">2</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>                        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(members));<br>                        <span class="hljs-comment">// 把自己加入到群聊中</span><br>                        set.add(username);<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupCreateRequestMessage(commands[<span class="hljs-number">1</span>],set));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersRequestMessage(commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinRequestMessage(username, commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gquit&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitRequestMessage(username, commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>                        ctx.channel().close();<br>                        <span class="hljs-keyword">return</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        System.out.println(<span class="hljs-string">&quot;指令有误，请重新输入&quot;</span>);<br>                        <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;login channel&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> LoginResponseMessage) &#123;<br>            <span class="hljs-comment">// 如果是登录响应信息</span><br>            LoginResponseMessage message = (LoginResponseMessage) msg;<br>            <span class="hljs-keyword">boolean</span> isSuccess = message.isSuccess();<br>            <span class="hljs-comment">// 登录成功，设置登陆标记</span><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                loginStatus.set(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// 登陆后，唤醒登陆线程</span><br>            waitLogin.countDown();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">LoginRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得登录信息</span><br>        String username = msg.getUsername();<br>        String password = msg.getPassword();<br>        <span class="hljs-comment">// 校验登录信息</span><br>        <span class="hljs-keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);<br>        LoginResponseMessage message;<br>        <span class="hljs-keyword">if</span> (login) &#123;<br>            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            <span class="hljs-comment">// 绑定channel与user</span><br>            SessionFactory.getSession().bind(ctx.channel(), username);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-keyword">new</span> LoginResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;登陆失败&quot;</span>);<br>        &#125;<br>        ctx.writeAndFlush(message);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理登录请求</span><br>LoginRequestMessageHandler loginRequestMessageHandler = <span class="hljs-keyword">new</span> LoginRequestMessageHandler();<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> LoginRequestMessageHandler());<br></code></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">5665 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 1, 0, 279<br>5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success=true, reason=&#x27;登陆成功&#x27;&#125;<br>5667 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;登陆成功&#x27;&#125;<br>success<br></code></pre></td></tr></table></figure><p><strong>服务器</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tex">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 217<br>11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username=&#x27;Nyima&#x27;, password=&#x27;123&#x27;&#125;<br><br>7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:/127.0.0.1:8080 - R:/127.0.0.1:60572] WRITE: 295B<br>         +-------------------------------------------------+<br>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 4e 59 49 4d 01 01 01 00 00 00 00 ff 00 00 01 17 |NYIM............|<br>|00000010| ac ed 00 05 73 72 00 31 63 6e 2e 6e 79 69 6d 61 |....sr.1cn.nyima|<br>|00000020| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes|<br>|00000030| 73 61 67 65 2e 4c 6f 67 69 6e 52 65 73 70 6f 6e |sage.LoginRespon|<br>|00000040| 73 65 4d 65 73 73 61 67 65 e2 34 49 24 72 52 f3 |seMessage.4I<span class="hljs-formula">$rR.|</span><br><span class="hljs-formula">|00000050| 07 02 00 00 78 72 00 34 63 6e 2e 6e 79 69 6d 61 |....xr.4cn.nyima|</span><br><span class="hljs-formula">|00000060| 63 2e 73 74 75 64 79 2e 64 61 79 38 2e 6d 65 73 |c.study.day8.mes|</span><br><span class="hljs-formula">|00000070| 73 61 67 65 2e 41 62 73 74 72 61 63 74 52 65 73 |sage.AbstractRes|</span><br><span class="hljs-formula">|00000080| 70 6f 6e 73 65 4d 65 73 73 61 67 65 b3 7e 19 32 |ponseMessage.~.2|</span><br><span class="hljs-formula">|00000090| 9b 88 4d 7b 02 00 02 5a 00 07 73 75 63 63 65 73 |..M&#123;...Z..succes|</span><br><span class="hljs-formula">|000000a0| 73 4c 00 06 72 65 61 73 6f 6e 74 00 12 4c 6a 61 |sL..reasont..Lja|</span><br><span class="hljs-formula">|000000b0| 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 78 |va/lang/String;x|</span><br><span class="hljs-formula">|000000c0| 72 00 24 63 6e 2e 6e 79 69 6d 61 63 2e 73 74 75 |r.$</span>cn.nyimac.stu|<br>|000000d0| 64 79 2e 64 61 79 38 2e 6d 65 73 73 61 67 65 2e |dy.day8.message.|<br>|000000e0| 4d 65 73 73 61 67 65 dd e9 84 b7 21 db 18 52 02 |Message....!..R.|<br>|000000f0| 00 02 49 00 0b 6d 65 73 73 61 67 65 54 79 70 65 |..I..messageType|<br>|00000100| 49 00 0a 73 65 71 75 65 6e 63 65 49 64 78 70 00 |I..sequenceIdxp.|<br>|00000110| 00 00 00 00 00 00 00 01 74 00 0c e7 99 bb e9 99 |........t.......|<br>|00000120| 86 e6 88 90 e5 8a 9f                            |.......         |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ChatRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得user所在的channel</span><br>        Channel channel = SessionFactory.getSession().getChannel(msg.getTo());<br>        <span class="hljs-comment">// 如果双方都在线</span><br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 通过接收方与服务器之间的channel发送信息</span><br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通过发送方与服务器之间的channel发送消息</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> ChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;对方用户不存在或离线，发送失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理单聊请求</span><br>ChatRequestMessageHandler chatRequestMessageHandler = <span class="hljs-keyword">new</span> ChatRequestMessageHandler();<br>ch.pipeline().addLast(chatRequestMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">send Nyima hello<br></code></pre></td></tr></table></figure><p>接收方（Nyima）</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 收到zhangsan发来的消息<br>20230 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from=&#x27;zhangsan&#x27;, content=&#x27;hello&#x27;&#125;<br></code></pre></td></tr></table></figure><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupCreateMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupCreateRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得要创建的群聊名</span><br>        String groupName = msg.getGroupName();<br>        <span class="hljs-comment">// 获得要创建的群聊的成员组</span><br>        Set&lt;String&gt; members = msg.getMembers();<br>        <span class="hljs-comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span><br>        Group group = GroupSessionFactory.getGroupSession().createGroup(groupName, members);<br>        <span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 发送创建成功消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, groupName + <span class="hljs-string">&quot;创建成功&quot;</span>);<br>            ctx.writeAndFlush(groupCreateResponseMessage);<br>            <span class="hljs-comment">// 获得在线群员的channel，给群员发送入群聊消息</span><br>            List&lt;Channel&gt; membersChannel = GroupSessionFactory.getGroupSession().getMembersChannel(groupName);<br>            groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span>+groupName);<br>            <span class="hljs-comment">// 给每个在线群员发送消息</span><br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.writeAndFlush(groupCreateResponseMessage);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 发送失败消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> GroupCreateResponseMessage(<span class="hljs-keyword">false</span>, groupName + <span class="hljs-string">&quot;已存在&quot;</span>);<br>            ctx.writeAndFlush(groupCreateResponseMessage);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理创建群聊请求</span><br>GroupCreateMessageHandler groupCreateMessageHandler = <span class="hljs-keyword">new</span> GroupCreateMessageHandler();<br>ch.pipeline().addLast(groupCreateMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>创建者客户端</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 首次创建<br>gcreate Netty学习 zhangsan,lisi<br><br>31649 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;Netty学习创建成功&#x27;&#125;<br>15244 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;您已被拉入Netty学习&#x27;&#125;<br><br><br>// 再次创建<br>gcreate Netty学习 zhangsan,lisi<br>40771 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;Netty学习已存在&#x27;&#125;<br></code></pre></td></tr></table></figure><p>群员客户端</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">28788 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;您已被拉入Netty学习&#x27;&#125;<br></code></pre></td></tr></table></figure><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupChatRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String groupName = msg.getGroupName();<br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断群聊是否存在</span><br>        <span class="hljs-keyword">boolean</span> isCreated = groupSession.isCreated(groupName);<br>        <span class="hljs-keyword">if</span> (isCreated) &#123;<br>            <span class="hljs-comment">// 给群员发送信息</span><br>            List&lt;Channel&gt; membersChannel = groupSession.getMembersChannel(groupName);<br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupChatResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;群聊不存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理群聊聊天</span><br>GroupChatMessageHandler groupChatMessageHandler = <span class="hljs-keyword">new</span> GroupChatMessageHandler();<br>ch.pipeline().addLast(groupChatMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">gsend Netty学习 你们好<br><br>45408 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=&#x27;zhangsan&#x27;, content=&#x27;你们好&#x27;&#125;<br></code></pre></td></tr></table></figure><p>接收方</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">48082 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=&#x27;zhangsan&#x27;, content=&#x27;你们好&#x27;&#125;<br></code></pre></td></tr></table></figure><p>发送方（群聊不存在）t</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">gsend Spring学习 你们好<br><br>25140 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;群聊不存在&#x27;&#125;<br></code></pre></td></tr></table></figure><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupJoinMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupJoinRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断该用户是否在群聊中</span><br>        Set&lt;String&gt; members = groupSession.getMembers(msg.getGroupName());<br>        <span class="hljs-keyword">boolean</span> joinFlag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span><br>        <span class="hljs-keyword">if</span> (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;<br>            joinFlag = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 加入群聊</span><br>            groupSession.joinMember(msg.getGroupName(), msg.getUsername());<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">true</span>,<span class="hljs-string">&quot;加入&quot;</span>+msg.getGroupName()+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupJoinResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理加入群聊</span><br>GroupJoinMessageHandler groupJoinMessageHandler = <span class="hljs-keyword">new</span> GroupJoinMessageHandler();<br>ch.pipeline().addLast(groupJoinMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常加入群聊</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">94921 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;加入Netty学习成功&#x27;&#125;<br></code></pre></td></tr></table></figure><p>加入不能存在或已加入的群聊</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">44025 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;加入失败，群聊未存在或您已加入该群聊&#x27;&#125;<br></code></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupQuitMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupQuitRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        GroupSession groupSession = GroupSessionFactory.getGroupSession();<br>        String groupName = msg.getGroupName();<br>        Set&lt;String&gt; members = groupSession.getMembers(groupName);<br>        String username = msg.getUsername();<br>        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在</span><br>        <span class="hljs-keyword">boolean</span> joinFlag = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;<br>            <span class="hljs-comment">// 可以退出</span><br>            joinFlag = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 退出成功</span><br>            groupSession.removeMember(groupName, username);<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitResponseMessage(<span class="hljs-keyword">true</span>, <span class="hljs-string">&quot;退出&quot;</span>+groupName+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退出失败</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupQuitResponseMessage(<span class="hljs-keyword">false</span>, <span class="hljs-string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+groupName+<span class="hljs-string">&quot;失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理退出群聊</span><br>GroupQuitMessageHandler groupQuitMessageHandler = <span class="hljs-keyword">new</span> GroupQuitMessageHandler();<br>ch.pipeline().addLast(groupQuitMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常退出</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">32282 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=&#x27;退出Netty学习成功&#x27;&#125;<br></code></pre></td></tr></table></figure><p>退出不存在或未加入的群聊</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">67404 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=&#x27;群聊不存在或您未加入该群，退出Netty失败&#x27;&#125;<br></code></pre></td></tr></table></figure><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupMembersMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">GroupMembersRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理查看成员</span><br>GroupMembersMessageHandler groupMembersMessageHandler = <span class="hljs-keyword">new</span> GroupMembersMessageHandler();<br>ch.pipeline().addLast(groupMembersMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">46557 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members=[zhangsan, Nyima]&#125;<br></code></pre></td></tr></table></figure><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常退出，需要解绑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理退出聊天室</span><br>ch.pipeline().addLast(quitHandler);<br>GroupMembersMessageHandler groupMembersMessageHandler = <span class="hljs-keyword">new</span> GroupMembersMessageHandler();<br></code></pre></td></tr></table></figure><p><strong>退出时，客户端会关闭channel并返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br><span class="hljs-comment">// 关闭channel并返回</span><br>    ctx.channel().close();<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" alt="img"></a></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 添加双向处理器，负责处理READER_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 获得事件</span><br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>            <span class="hljs-comment">// 断开连接</span><br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><p>使用<code>IdleStateHandler</code>进行空闲检测</p></li><li><p>使用双向处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelDuplexHandler<br></code></pre></td></tr></table></figure><p>对入站与出站事件进行处理</p><ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送心跳包，让服务器知道客户端在线</span><br><span class="hljs-comment">// 3s未发生WRITER_IDLE，就像服务器发送心跳包</span><br><span class="hljs-comment">// 该值为服务器端设置的READER_IDLE触发时间的一半左右</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;<br>            <span class="hljs-comment">// 发送心跳包</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> PingMessage());<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object 被序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 被序列化对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 序列化后的字节数组</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 反序列化的目标类的Class对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 被反序列化的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 反序列化目标类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SerializerAlgorithm implements Serializer &#123;<br>    <span class="hljs-comment">// Java的序列化和反序列化</span><br>    Java &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>            <span class="hljs-comment">// 序列化后的字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> (ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>                 ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos)) &#123;<br>                oos.writeObject(object);<br>                bytes = bos.toByteArray();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>            T target = <span class="hljs-keyword">null</span>;<br>            System.out.println(Arrays.toString(bytes));<br>            <span class="hljs-keyword">try</span> (ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);<br>                 ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis)) &#123;<br>                target = (T) ois.readObject();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 返回反序列化后的对象</span><br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">// Json的序列化和反序列化</span><br>    Json &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object) &#123;<br>            String s = <span class="hljs-keyword">new</span> Gson().toJson(object);<br>            System.out.println(s);<br>            <span class="hljs-comment">// 指定字符集，获得字节数组</span><br>            <span class="hljs-keyword">return</span> s.getBytes(StandardCharsets.UTF_8);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>            String s = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>            System.out.println(s);<br>            <span class="hljs-comment">// 此处的clazz为具体类型的Class对象，而不是父类Message的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Gson().fromJson(s, clazz);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得序列化后的msg</span><br><span class="hljs-comment">// 使用指定的序列化方式</span><br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-comment">// 获得序列化后的对象</span><br><span class="hljs-keyword">byte</span>[] bytes = values[out.getByte(<span class="hljs-number">5</span>)-<span class="hljs-number">1</span>].serialize(msg);<br></code></pre></td></tr></table></figure><p><strong>解码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得反序列化方式</span><br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-comment">// 通过指定方式进行反序列化</span><br><span class="hljs-comment">// 需要通过Message的方法获得具体的消息类型</span><br>Message message = values[seqType-<span class="hljs-number">1</span>].deserialize(Message.getMessageClass(messageType), bytes);<br></code></pre></td></tr></table></figure><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParam</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>        <br>        <span class="hljs-comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p></li><li><p>服务器通过</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerBootstrap<br></code></pre></td></tr></table></figure><p>  来配置参数，但是对于不同的 Channel 需要选择不同的方法</p><ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// Schedule connect timeout.</span><br>    <span class="hljs-comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span><br>    <span class="hljs-keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();<br>    <span class="hljs-comment">// 如果超时时间大于0</span><br>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span><br>        <span class="hljs-comment">// schedule(Runnable command, long delay, TimeUnit unit)</span><br>        connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span><br>                <span class="hljs-comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span><br>                <span class="hljs-comment">// 在主线程中抛出</span><br>                ChannelPromise connectPromise = AbstractNioChannel.<span class="hljs-keyword">this</span>.connectPromise;<br>                ConnectTimeoutException cause = <span class="hljs-keyword">new</span> ConnectTimeoutException(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress);<br>                <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;<br>                    close(voidPromise());<br>                &#125;<br>            &#125;<br>        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>   ...<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221510897.png" alt="image-20220812221510897"></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221524109.png" alt="image-20220812221524109"></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221538399.png" alt="image-20220812221538399"></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置全连接队列，大小为2</span><br><span class="hljs-keyword">new</span> ServerBootstrap().option(ChannelOption.SO_BACKLOG, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> backlog = NetUtil.SOMAXCONN;<br></code></pre></td></tr></table></figure><p>具体的赋值操作如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">SOMAXCONN = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span><br>        <span class="hljs-comment">// The known defaults:</span><br>        <span class="hljs-comment">// - Windows NT Server 4.0+: 200</span><br>        <span class="hljs-comment">// - Linux and Mac OS X: 128</span><br>        <span class="hljs-keyword">int</span> somaxconn = PlatformDependent.isWindows() ? <span class="hljs-number">200</span> : <span class="hljs-number">128</span>;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/proc/sys/net/core/somaxconn&quot;</span>);<br>        BufferedReader in = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span><br>            <span class="hljs-comment">// try / catch block.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/4936</span><br>            <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>                in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(file));<br>                <span class="hljs-comment">// 将somaxconn设置为Linux配置文件中设置的值</span><br>                somaxconn = Integer.parseInt(in.readLine());<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, file, somaxconn);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ...<br>            &#125;<br>            ...<br>        &#125;  <br>        <span class="hljs-comment">// 返回backlog的值</span><br>        <span class="hljs-keyword">return</span> somaxconn;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux/Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span><br><span class="hljs-comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span><br><span class="hljs-keyword">new</span> ServerBootstrap().childOption(ChannelOption.ALLOCATOR, <span class="hljs-keyword">new</span> PooledByteBufAllocator());<br></code></pre></td></tr></table></figure><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// true表示使用直接内存</span><br><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure></li><li><p>池化并使用堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> PooledByteBufAllocator(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure></li><li><p>非池化并使用直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ture表示使用直接内存</span><br><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure></li><li><p>非池化并使用堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> UnpooledByteBufAllocator(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    ...<br><br>    <span class="hljs-comment">// 添加RPC消息类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="hljs-number">101</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="hljs-number">102</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 将消息类型放入消息类对象Map中</span><br>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);<br>        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RPC请求消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口中的方法名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String methodName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class&lt;?&gt; returnType;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数类型数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Class[] parameterTypes;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数值数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object[] parameterValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RpcRequestMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setSequenceId(sequenceId);<br>        <span class="hljs-keyword">this</span>.interfaceName = interfaceName;<br>        <span class="hljs-keyword">this</span>.methodName = methodName;<br>        <span class="hljs-keyword">this</span>.returnType = returnType;<br>        <span class="hljs-keyword">this</span>.parameterTypes = parameterTypes;<br>        <span class="hljs-keyword">this</span>.parameterValue = parameterValue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;<br>    &#125;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInterfaceName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> interfaceName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMethodName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> methodName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getReturnType() &#123;<br>        <span class="hljs-keyword">return</span> returnType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class[] getParameterTypes() &#123;<br>        <span class="hljs-keyword">return</span> parameterTypes;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object[] getParameterValue() &#123;<br>        <span class="hljs-keyword">return</span> parameterValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcRequestMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;interfaceName=&#x27;&quot;</span> + interfaceName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, methodName=&#x27;&quot;</span> + methodName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, returnType=&quot;</span> + returnType +<br>                <span class="hljs-string">&quot;, parameterTypes=&quot;</span> + Arrays.toString(parameterTypes) +<br>                <span class="hljs-string">&quot;, parameterValue=&quot;</span> + Arrays.toString(parameterValue) +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object returnValue;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Exception exceptionValue;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMessageType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;<br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReturnValue</span><span class="hljs-params">(Object returnValue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.returnValue = returnValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExceptionValue</span><span class="hljs-params">(Exception exceptionValue)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.exceptionValue = exceptionValue;<br>    &#125;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getReturnValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Exception <span class="hljs-title">getExceptionValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> exceptionValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcResponseMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;returnValue=&quot;</span> + returnValue +<br>                <span class="hljs-string">&quot;, exceptionValue=&quot;</span> + exceptionValue +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcRequestMessageHandler rpcRequestMessageHandler = <span class="hljs-keyword">new</span> RpcRequestMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                    ch.pipeline().addLast(rpcRequestMessageHandler);<br>                &#125;<br>            &#125;);<br>            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                    ch.pipeline().addLast(rpcResponseMessageHandler);<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过接口Class获取实例对象的<strong>Factory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServicesFactory</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> HashMap&lt;Class&lt;?&gt;, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Class&lt;?&gt; interfaceClass)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;<br>        <span class="hljs-comment">// 根据Class创建实例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>);<br>            Object instance = Class.forName(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;</span>).newInstance();<br>           <br>            <span class="hljs-comment">// 放入 InterfaceClass -&gt; InstanceObject 的映射</span><br>            map.put(clazz, instance);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;  <br>        <span class="hljs-keyword">return</span> map.get(interfaceClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcRequestMessage</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage)</span> </span>&#123;<br>        RpcResponseMessage rpcResponseMessage = <span class="hljs-keyword">new</span> RpcResponseMessage();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 设置返回值的属性</span><br>            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());<br>            <span class="hljs-comment">// 返回一个实例</span><br>            HelloService service = (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));<br>            <br>            <span class="hljs-comment">// 通过反射调用方法，并获取返回值</span><br>            Method method = service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());<br>            <span class="hljs-comment">// 获得返回值</span><br>            Object invoke = method.invoke(service, rpcMessage.getParameterValue());<br>            <span class="hljs-comment">// 设置返回值</span><br>            rpcResponseMessage.setReturnValue(invoke);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-comment">// 设置异常</span><br>            rpcResponseMessage.setExceptionValue(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 向channel中写入Message</span><br>    ctx.writeAndFlush(rpcResponseMessage);<br>&#125;<br></code></pre></td></tr></table></figure><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        System.out.println((String)msg.getReturnValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>...<br>           <br>        <span class="hljs-comment">// 创建请求并发送</span><br>RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(<span class="hljs-number">1</span>,<br>               <span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>,<br>               <span class="hljs-string">&quot;sayHello&quot;</span>,<br>               String.class,<br>               <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>               <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;Nyima&quot;</span>&#125;);<br><br>        channel.writeAndFlush(message);   <br>            <br>        ...    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>客户端</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">1606 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue=你好，Nyima, exceptionValue=null&#125;<br></code></pre></td></tr></table></figure><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClientManager</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 产生SequenceId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger sequenceId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建代理对象</span><br>        HelloService service = (HelloService) getProxy(HelloService.class);<br>        <span class="hljs-comment">// 通过代理对象执行方法</span><br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;Nyima&quot;</span>));<br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;Hulu&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例模式创建Channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title">getChannel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span>) &#123;<br>                    init();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> channel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用代理模式，帮助我们创建请求消息并发送</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;<br>        Class&lt;?&gt;[] classes = <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;;<br>        <span class="hljs-comment">// 使用JDK代理，创建代理对象</span><br>        Object o = Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                <span class="hljs-comment">// 创建请求消息</span><br>                <span class="hljs-keyword">int</span> id = sequenceId.getAndIncrement();<br>                RpcRequestMessage message = <span class="hljs-keyword">new</span> RpcRequestMessage(id, serviceClass.getName(),<br>                        method.getName(), method.getReturnType(),<br>                        method.getParameterTypes(),<br>                        args);<br>                <span class="hljs-comment">// 发送消息</span><br>                getChannel().writeAndFlush(message);<br><br>                <span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>                DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<br>                <span class="hljs-comment">// 将Promise放入Map中</span><br>                RpcResponseMessageHandler.promiseMap.put(id, promise);<br>                <span class="hljs-comment">// 等待被放入Promise中结果</span><br>                promise.await();<br>                <span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;<br>                    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>                    <span class="hljs-keyword">return</span> promise.getNow();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler(LogLevel.DEBUG);<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> MessageSharableCodec();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> RpcResponseMessageHandler();<br><br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.channel(NioSocketChannel.class);<br>        bootstrap.group(group);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtocolFrameDecoder());<br>                ch.pipeline().addLast(loggingHandler);<br>                ch.pipeline().addLast(messageSharableCodec);<br>                ch.pipeline().addLast(rpcResponseMessageHandler);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel = bootstrap.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)).sync().channel();<br>            <span class="hljs-comment">// 异步关闭 group，避免Channel被阻塞</span><br>            channel.closeFuture().addListener(future -&gt; &#123;<br>                group.shutdownGracefully();<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获得Channel</strong></p><ul><li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li><li>通过<strong>单例模式</strong>创建与获取Channel</li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());<br><span class="hljs-comment">// 将Promise放入Map中</span><br>RpcResponseMessageHandler.promiseMap.put(id, promise);<br><span class="hljs-comment">// 等待被放入Promise中结果</span><br>promise.await();<br><span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;<br>    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>    <span class="hljs-keyword">return</span> promise.getNow();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(promise.cause());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());<br>Object returnValue = msg.getReturnValue();<br>Exception exception = msg.getExceptionValue();<br><span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 返回结果中有异常信息</span><br>        promise.setFailure(exception);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 方法正常执行，没有异常</span><br>        promise.setSuccess(returnValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">RpcResponseMessage</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>        Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());<br>        Object returnValue = msg.getReturnValue();<br>        Exception exception = msg.getExceptionValue();<br>        <span class="hljs-keyword">if</span> (promise != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 返回结果中有异常信息</span><br>                promise.setFailure(exception);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 方法正常执行，没有异常</span><br>                promise.setSuccess(returnValue);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拿到返回结果并打印</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span><br>Selector selector = Selector.open(); <br><br><span class="hljs-comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br>NioServerSocketChannel attachment = <span class="hljs-keyword">new</span> NioServerSocketChannel();<br><br><span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); <br>serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br><span class="hljs-comment">// 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br>SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">// 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;<br>validate();<br><span class="hljs-keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;<br>    <span class="hljs-comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span><br>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span><br>    <span class="hljs-comment">// init由main线程完成，regisetr由NIO线程完成</span><br>    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();<br>    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为register操作是异步的</span><br>    <span class="hljs-comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        ChannelPromise promise = channel.newPromise();<br>        <br>        <span class="hljs-comment">// 执行doBind0绑定操作</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-comment">// 如果register操作还没执行完，就会到这个分支中来</span><br>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);<br>        <br>        <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span><br>        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                Throwable cause = future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered();<br><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;<br>    Channel channel = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel();<br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    ChannelFuture regFuture = config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Channel channel = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 通过反射初始化NioServerSocketChannel</span><br>    channel = channelFactory.newChannel();<br>    init(channel);<br>&#125;<br></code></pre></td></tr></table></figure><p>newChannel方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newChannel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射调用NioServerSocketChannel的构造方法</span><br>        <span class="hljs-comment">// 创建NioServerSocketChannel对象</span><br>        <span class="hljs-keyword">return</span> constructor.newInstance();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioServerSocketChannel构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerSocketChannel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));<br>&#125;<br></code></pre></td></tr></table></figure><p>newSocket方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title">newSocket</span><span class="hljs-params">(SelectorProvider provider)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ServerSocketChannel.open方法：</span><br>        <span class="hljs-comment">// SelectorProvider.provider().openServerSocketChannel()</span><br>    <span class="hljs-comment">// 所以此处相当于ServerSocketChannel.open()</span><br>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>init方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>   ...<br><br>    <span class="hljs-comment">// NioSocketChannl的Pipeline    </span><br>    ChannelPipeline p = channel.pipeline();<br><br>    ...<br><br>    <span class="hljs-comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// register之后才调用该方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            <br>            <span class="hljs-comment">// 创建handler并加入到pipeline中</span><br>            ChannelHandler handler = config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 添加新的handler，在发生Accept事件后建立连接</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>init主要完成了以下三个操作</strong></p><ul><li><p>创建NioServerSocketChannel</p></li><li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p></li><li><p>由</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">initChannel<br></code></pre></td></tr></table></figure><p>方法向NioServerSocketChannel中添加了两个handler，</p><p>添加操作在register之后被执行</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 获取EventLoop</span><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>   <span class="hljs-comment">// 此处完成了由 主线程 到 NIO线程 的切换</span><br>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 向NIO线程中添加任务</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 该方法中会执行doRegister</span><br>                    <span class="hljs-comment">// 执行真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>           ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>register0方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       ...<br>            <br>        <span class="hljs-comment">// 执行真正的注册操作</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-keyword">false</span>;<br>        registered = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 调用init中的initChannel方法</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>doRegister方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br>            <span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>           <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回调initChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>    ChannelHandler handler = config.handler();<br>    <span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;<br>        pipeline.addLast(handler);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span><br>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span><br>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br><span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br><span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br><span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();<br>regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Throwable cause = future.cause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>            promise.setFailure(cause);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>            promise.registered();<br>            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span><br>            doBind0(regFuture, channel, localAddress, promise);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span><br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>    invokeLater(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            pipeline.fireChannelActive();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readPending = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span><br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 则让其关注Accepet事件</span><br>        <span class="hljs-comment">// readInterestOp 取值是 16</span><br>        <span class="hljs-comment">// 在 NioServerSocketChannel 创建时初始化</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br></code></pre></td></tr></table></figure></li><li><p>然后再设置其感兴趣的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jselectionKey.interestOps(interestOps | readInterestOp);<br></code></pre></td></tr></table></figure></li></ul><p><strong>各个事件对应的值</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220812221611103.png" alt="image-20220812221611103"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleThreadEventLoop</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">private</span> SelectedSelectionKeySet selectedKeys;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Thread与TaskQueue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractScheduledEventExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderedEventExecutor</span> </span>&#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;<br>    <br>        ...<br>           <br>        <span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        <span class="hljs-keyword">final</span> SelectorTuple selectorTuple = openSelector();<br>        <span class="hljs-keyword">this</span>.selector = selectorTuple.selector;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title">openSelector</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">unwrappedSelector = provider.openSelector();<br></code></pre></td></tr></table></figure><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title">openSelector</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    <span class="hljs-keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();<br><br><br>    Object maybeException = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br><br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));<br>&#125;<br></code></pre></td></tr></table></figure><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br><span class="hljs-keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> SelectedSelectionKeySet();<br><br>SelectedSelectionKeySet() &#123;<br>keys = <span class="hljs-keyword">new</span> SelectionKey[<span class="hljs-number">1024</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)<br></code></pre></td></tr></table></figure></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>return <span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectorTuple(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">new</span> SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNioEventLoop</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EventLoop eventLoop = <span class="hljs-keyword">new</span> NioEventLoopGroup().next();<br>        <span class="hljs-comment">// 使用NioEventLoop执行任务</span><br>        eventLoop.execute(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>execute</code>执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>    <span class="hljs-comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span><br>    ObjectUtil.checkNotNull(task, <span class="hljs-string">&quot;task&quot;</span>);<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span><br>    execute(task, !(task <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));<br>&#125;<br></code></pre></td></tr></table></figure><p>进入上述代码的<code>execute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断当前线程是否为NIO线程</span><br>    <span class="hljs-comment">// 判断方法为 return thread == this.thread;</span><br>    <span class="hljs-comment">// this.thread即为NIO线程，首次执行任务时，其为null</span><br>    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();<br>    <br>    <span class="hljs-comment">// 向任务队列taskQueue中添加任务</span><br>    addTask(task);<br>    <br>    <span class="hljs-comment">// 当前线程不是NIO线程，则进入if语句</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// 启动NIO线程的核心方法</span><br>        startThread();<br>        <br>        ...<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>startThread</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                doStartThread();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_STARTED, ST_NOT_STARTED);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> strategy;<br>            <span class="hljs-keyword">try</span> &#123;<br>                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    <span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br>                    <span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>                        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                    &#125;<br>                    nextWakeupNanos.set(curDeadlineNanos);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                            strategy = select(curDeadlineNanos);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                        <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                        nextWakeupNanos.lazySet(AWAKE);<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>                &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br><span class="hljs-keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br><span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>    &#125;<br>nextWakeupNanos.set(curDeadlineNanos);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>            <span class="hljs-comment">// 执行select方法</span><br>            strategy = select(curDeadlineNanos);<br>        &#125;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deadlineNanos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 如果没有指定阻塞事件，就调用select()</span><br>    <span class="hljs-keyword">if</span> (deadlineNanos == NONE) &#123;<br>        <span class="hljs-keyword">return</span> selector.select();<br>    &#125;<br>    <span class="hljs-comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span><br>    <span class="hljs-comment">// Timeout will only be 0 if deadline is within 5 microsecs</span><br>    <span class="hljs-keyword">long</span> timeoutMillis = deadlineToDelayNanos(deadlineNanos + <span class="hljs-number">995000L</span>) / <span class="hljs-number">1000000L</span>;<br>    <span class="hljs-keyword">return</span> timeoutMillis &lt;= <span class="hljs-number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p><p>唤醒是通过execute最后的if代码块来完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>    wakeup(inEventLoop);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> inEventLoop)</span> </span>&#123;<br>    <span class="hljs-comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span><br>    <span class="hljs-comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;<br>        <span class="hljs-comment">// 唤醒被selector.select方法阻塞的NIO线程</span><br>        selector.wakeup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br><span class="hljs-keyword">switch</span> (strategy) &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>strategy的值由<code>calculateStrategy</code>方法确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateStrategy</span><span class="hljs-params">(IntSupplier selectSupplier, <span class="hljs-keyword">boolean</span> hasTasks)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// selectSupplier.get() 底层是 selector.selectNow();</span><br>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IntSupplier selectNowSupplier = <span class="hljs-keyword">new</span> IntSupplier() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> NioEventLoop.<span class="hljs-keyword">this</span>.selectNow();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.selector.selectNow();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        ...<br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = select(curDeadlineNanos);  <br>        ...     <br>    <br>     <span class="hljs-keyword">if</span>(...) &#123;<br>...<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>    <span class="hljs-comment">// The selector returned prematurely many times in a row.</span><br>    <span class="hljs-comment">// Rebuild the selector to work around the problem.</span><br>    logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,selectCnt, selector);<br>    <span class="hljs-comment">// 重建selector，将原selector的配置信息传给新selector</span><br>    <span class="hljs-comment">// 再用新selector覆盖旧selector</span><br>    rebuildSelector();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理IO事件时间比例，默认为50%</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br><br><span class="hljs-comment">// 如果IO事件时间比例设置为100%</span><br><span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果需要去处理IO事件</span><br>        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先处理IO事件</span><br>            processSelectedKeys();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// 剩下的时间都去处理普通任务和定时任务</span><br>        ranTasks = runAllTasks();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果需要去处理IO事件</span><br>    <span class="hljs-comment">// 记录处理IO事件前的时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 去处理IO事件</span><br>        processSelectedKeys();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// ioTime为处理IO事件耗费的事件</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>        <span class="hljs-comment">// 计算出处理其他任务的事件</span><br>        <span class="hljs-comment">// 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行</span><br>        ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有IO事件需要处理</span><br>    <span class="hljs-comment">// This will run the minimum number of tasks</span><br>    <span class="hljs-comment">// 直接处理普通和定时任务</span><br>    ranTasks = runAllTasks(<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 没有指定执行任务的时间</span><br>ranTasks = runAllTasks();<br></code></pre></td></tr></table></figure></li></ul></li><li><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比如ioTime为10s，ioRatio为50</span><br><span class="hljs-comment">// 那么通过 10*(100-50)/50=10 计算出其他任务可用的时间为 10s</span><br><span class="hljs-comment">// 处理IO事件占用的事件总比例为50%</span><br>ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br></code></pre></td></tr></table></figure></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行最少数量的任务</span><br>ranTasks = runAllTasks(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeys</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// 一般情况下都走这个分支</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 处理各种IO事件</span><br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>processSelectedKeysOptimized方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;<br>        <span class="hljs-comment">// 拿到SelectionKeyec</span><br>        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<br>        <span class="hljs-comment">// null out entry in the array to allow to have it GC&#x27;ed once the Channel close</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br>        <span class="hljs-keyword">final</span> Object a = k.attachment();<br><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>            <span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>            processSelectedKey(k, (AbstractNioChannel) a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, task);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>            <span class="hljs-comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>            selectedKeys.reset(i + <span class="hljs-number">1</span>);<br><br>            selectAgain();<br>            i = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];<br></code></pre></td></tr></table></figure><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br><span class="hljs-keyword">final</span> Object a = k.attachment();<br></code></pre></td></tr></table></figure><p>如果附件继承自AbstractNioChannel，则会调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>processSelectedKey(k, (AbstractNioChannel) a);<br></code></pre></td></tr></table></figure><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            unsafe.close(unsafe.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-keyword">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br>        <span class="hljs-comment">// to a spin loop</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞直到事件发生</span><br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-comment">// 拿到一个事件</span><br>    SelectionKey key = iter.next();<br>    <br>    <span class="hljs-comment">// 如果是 accept 事件</span><br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-comment">// 执行accept，获得SocketChannel</span><br>        SocketChannel channel = serverSocketChannel.accept();<br>        channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        <br>        <span class="hljs-comment">// 将SocketChannel注册到selector中，并关注read事件</span><br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioMessageUnsafe.read</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ...<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span><br>                <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span><br>                <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span><br>                <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span><br>                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);<br>                <br>                ...<br>                <br><span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span><br>                allocHandle.incMessagesRead(localRead);<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> size = readBuf.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span><br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        <br>        ...<br>        <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span><br>    SocketChannel ch = SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span><br>            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>ServerBootstrapAcceptor.channelRead<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span><br>    <span class="hljs-keyword">final</span> Channel child = (Channel) msg;<br><br>    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span><br>    child.pipeline().addLast(childHandler);<br><br>    <span class="hljs-comment">// 设置选项</span><br>    setChannelOptions(child, childOptions, logger);<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    <br>    ...<br><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br>AbstractChannel.AbstractUnsafe.register0<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register0</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <br>        ...<br>            <br>        <span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span><br>        doRegister();<br>        <br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发pipeline上active事件</span><br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将Selector注册到Selector中</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br>HeadContext.channelActive<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>    ctx.fireChannelActive();<br><span class="hljs-comment">// 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)</span><br>    readIfIsAutoRead();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 这时候 interestOps是0</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关注read事件</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获得Channel的配置</span><br>    <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br><span class="hljs-comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span><br><span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();<br>    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 创建ByteBuf</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取内容，放入ByteBUf中</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                byteBuf.release();<br>                byteBuf = <span class="hljs-keyword">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    readPending = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 触发read 事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// 这时是处理NioSocketChannel上的handler</span><br>            pipeline.fireChannelRead(byteBuf);<br>            byteBuf = <span class="hljs-keyword">null</span>;<br>        &#125; <br>        <span class="hljs-comment">// 是否要继续循环</span><br>        <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>        allocHandle.readComplete();<br>        <span class="hljs-comment">// 触发 read complete事件</span><br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>         <span class="hljs-comment">// This could be for two reasons:</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br>DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">continueReading</span><span class="hljs-params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <br>           <span class="hljs-comment">// 一般为true</span><br>           config.isAutoRead() &amp;&amp;<br>           <span class="hljs-comment">// respectMaybeMoreData默认为true</span><br>           <span class="hljs-comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span><br>           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;<br>           <span class="hljs-comment">// 小于最大次数，maxMessagePerRead默认16</span><br>           totalMessages &lt; maxMessagePerRead &amp;&amp;<br>           <span class="hljs-comment">// 实际读到了数据</span><br>           totalBytesRead &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Netty&quot;&gt;&lt;a href=&quot;#Netty&quot; class=&quot;headerlink&quot; title=&quot;Netty&quot;&gt;&lt;/a&gt;Netty&lt;/h1&gt;&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语言基础</title>
    <link href="http://example.com/2022/07/31/Go/"/>
    <id>http://example.com/2022/07/31/Go/</id>
    <published>2022-07-31T13:47:03.260Z</published>
    <updated>2022-07-31T13:48:03.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构程序化"><a href="#结构程序化" class="headerlink" title="结构程序化"></a>结构程序化</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><blockquote><p>必须以字母或者下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</p></blockquote><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p><blockquote><p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（函数内部的名字则必须先声明之后才能使用）。</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> 变量名字 类型 = 表达式<br></code></pre></td></tr></table></figure><p>其中“<em>类型</em>”或“*= 表达式*”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p><h4 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h4><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">1.2</span><br></code></pre></td></tr></table></figure><p>请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。</p><p>简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。</p><p>在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go">in, err := os.Open(infile)<br><span class="hljs-comment">// ...</span><br>out, err := os.Create(outfile)<br></code></pre></td></tr></table></figure><p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go">f, err := os.Open(infile)<br><span class="hljs-comment">// ...</span><br>f, err := os.Create(outfile) <span class="hljs-comment">// compile error: no new variables</span><br></code></pre></td></tr></table></figure><p>解决的方法是第二个简短变量声明语句改用普通的多重赋值语句。</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。</p><p>如果用<code>var x int</code>声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Go">x := <span class="hljs-number">1</span><br>p := &amp;x         <span class="hljs-comment">// p, of type *int, points to x</span><br>fmt.Println(*p) <span class="hljs-comment">// &quot;1&quot;</span><br>*p = <span class="hljs-number">2</span>          <span class="hljs-comment">// equivalent to x = 2</span><br>fmt.Println(x)  <span class="hljs-comment">// &quot;2&quot;</span><br></code></pre></td></tr></table></figure><p>任何类型的指针的零值都是nil。如果p指向某个有效变量，那么<code>p != nil</code>测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x, y <span class="hljs-keyword">int</span><br>fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// &quot;true false false&quot;</span><br></code></pre></td></tr></table></figure><h4 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h4><p><strong>变量的生命周期指的是在程序运行期间变量有效存在的时间段。</strong>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：<strong>每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。</strong>函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p><p>Go的垃圾收集器判断一个变量是否可以回收的基本思路：从每个包级的变量和每个当前的运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的。也就是说它是否存在并不影响程序后续的计算结果。</p><p><strong>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</strong></p><p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> global *<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><br>    x = <span class="hljs-number">1</span><br>    global = &amp;x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>    y := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>    *y = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><strong>反转数组</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>        s[i], s[j] = s[j], s[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go">a := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>reverse(a[:])<br>fmt.Println(a) <span class="hljs-comment">// &quot;[5 4 3 2 1 0]&quot;</span><br></code></pre></td></tr></table></figure><p><strong>将元素循环向左旋转n个元素</strong>：三次调用reverse反转函数，第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。（如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go">s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// Rotate s left by two positions.</span><br>reverse(s[:<span class="hljs-number">2</span>])<br>reverse(s[<span class="hljs-number">2</span>:])<br>reverse(s)<br>fmt.Println(s) <span class="hljs-comment">// &quot;[2 3 4 5 0 1]&quot;</span><br></code></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><blockquote><p>defer语句 后紧跟随到语句会被延迟处理。</p><p>在defer所属函数返回时，将被defer修饰的语句逆序执行。</p><p>也就是最下面的defer语句最先执行。可以用来做资源清理：数据库连接释放、锁资源释放、关闭文件</p></blockquote><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote><p>先于main函数自动执行，不可以被其他函数调用。</p><p>init函数既没有参数也没有返回值，一个包可以有多个init函数，</p><p>可以用来做一些初始化操作：初始化顺序：<strong>变量初始化-&gt;init-&gt;main</strong></p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//定义结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   name <span class="hljs-keyword">string</span><br>   age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">//定义构造方法 ，返回两个参数，第一个是一个指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(*Person, error)</span></span> &#123;<br>   <span class="hljs-comment">// 字符串可以直接比较</span><br>   <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;姓名不能为空&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;age 不能小于0&quot;</span>)<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> &amp;Person&#123;name, age&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//接受两个参数，第一个是一个指针类型</span><br>   person, err := newPerson(<span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-number">-1</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, *person)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote><p>创建一个协程非常容易，在语句前面加上 go 即可</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>      fmt.Println(msg)<br>      <span class="hljs-comment">//休眠100ms</span><br>      time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;java&quot;</span>) <span class="hljs-comment">//go 启动了一个协程来执行</span><br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;golang&quot;</span>)<br>   fmt.Println(<span class="hljs-string">&quot;end...&quot;</span>) <span class="hljs-comment">//主函数退出，程序就结束了，会发现并不会打印5次java 和5次 go</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><blockquote><p>通道用于在协程之前共享数据</p><ol><li>对于一个通道，发送操作之间是互斥的，接受操作之间也是互斥的</li><li>发送操作和接受操作中对元素值的处理都是不可分割的</li><li>发送操作在完全完成之前会被阻塞。接收操作也是如此。</li></ol></blockquote><p>根据数据交换的行为，有两种类型的通道：无缓冲通道和缓冲通道。无缓冲通道用于执行通道之间的同步通信，而缓冲通道用于执行异步通信。无缓冲通道保证在发送和接收发生的瞬间执行两个协程之间的交换，缓冲通道没有这样的保证。</p><p>语法：由make函数创建，制定chan关键字和通道的元素类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">unbuffered := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)  <span class="hljs-comment">//创建无缓冲的int型通道</span><br>buffered :=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span> <span class="hljs-number">10</span>) <span class="hljs-comment">//创建有缓冲的int型通道</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;math/rand&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">//创建一个无缓冲的通道</span><br><span class="hljs-keyword">var</span> values = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-comment">//向通道中添加数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span> &#123;<br>   rand.Seed(time.Now().UnixNano())<br>   <span class="hljs-comment">//返回[0,n)的伪随机数</span><br>   value := rand.Intn(<span class="hljs-number">10</span>)<br>   <span class="hljs-built_in">println</span>(value)<br>   <span class="hljs-comment">//休眠5s，5s之后向通道放入数据</span><br>   time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>   <span class="hljs-comment">//将value 写入到 values中（通道）</span><br>   values &lt;- value<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//程序运行结束的之前关闭通道</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(values)<br>   <span class="hljs-comment">//启动一个协程</span><br>   <span class="hljs-keyword">go</span> send()<br>   fmt.Println(<span class="hljs-string">&quot;wait...&quot;</span>)<br>   <span class="hljs-comment">//会一直阻塞，直到通道中被放入数据</span><br>   value := &lt;-values<br>   fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="waitgroup"><a href="#waitgroup" class="headerlink" title="waitgroup"></a>waitgroup</h3><blockquote><p>有点像java的countdownlanch，用于实现同步</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showMessage</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-comment">//表示任务完成，计数器减1</span><br>   <span class="hljs-keyword">defer</span> wg.Done()<br>   <span class="hljs-built_in">println</span>(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>      <span class="hljs-comment">//计数器加1</span><br>      wg.Add(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">go</span> showMessage(i)<br>   &#125;<br>   <span class="hljs-comment">//阻塞，直到计数器的值为0</span><br>   wg.Wait()<br>   <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;end...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><h4 id="Gosched"><a href="#Gosched" class="headerlink" title="Gosched()"></a>Gosched()</h4><blockquote><p>主动让出cpu时间，重新等待安排任务</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;runtime&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>      <span class="hljs-built_in">println</span>(s)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;java&quot;</span>)<br><br>  <span class="hljs-comment">//主协程</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>      <span class="hljs-comment">//让出cpu时间片，等待重新分配任务</span><br>      runtime.Gosched()<br>      <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;golang&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子会先打印两遍java，再打印两遍golang。</p><p>虽然主协程和开启的协程会异步运行，但是由于使用了<code>runtime.Gosched()</code>,主协程会自动让出cpu，让其他协程运行，因此会等到没有其他协程运行才开始运行，实现了同步。</p><h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><blockquote><p>退出当前协程</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;runtime&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      <span class="hljs-comment">//如果i&gt;=5，直接退出协程</span><br>      <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">5</span> &#123;<br>         runtime.Goexit()<br>      &#125;<br>      <span class="hljs-built_in">println</span>(s)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> show(<span class="hljs-string">&quot;java&quot;</span>)<br>   time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><blockquote><p>设置最大的可执行的cpu数量</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;runtime&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;a:%v\n&quot;</span>, i)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;b:%v\n&quot;</span>, i)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//获取当前机器的cpu数量</span><br>   cpu := runtime.NumCPU()<br>   <span class="hljs-comment">//设置当前最大的执行cpu数量</span><br>   runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">go</span> a()<br>   <span class="hljs-keyword">go</span> b()<br>   <span class="hljs-built_in">println</span>(cpu)<br><br>   time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Metux"><a href="#Metux" class="headerlink" title="Metux"></a>Metux</h3><blockquote><p>加互斥锁</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;sync&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> wt sync.WaitGroup<br><span class="hljs-comment">//定义互斥锁变量</span><br><span class="hljs-keyword">var</span> lock sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">defer</span> wt.Done()<br>   lock.Lock()<br>   i++<br>   fmt.Println(<span class="hljs-string">&quot;add&quot;</span>, i)<br>   lock.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">defer</span> wt.Done()<br>  <span class="hljs-comment">//加锁</span><br>   lock.Lock()<br>   time.Sleep(time.Millisecond * <span class="hljs-number">2</span>)<br>   i--<br>   fmt.Println(<span class="hljs-string">&quot;sub&quot;</span>, i)<br>  <span class="hljs-comment">//解锁 </span><br>   lock.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>      wt.Add(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">go</span> add()<br>      wt.Add(<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">go</span> sub()<br>   &#125;<br><br>   wt.Wait()<br>   fmt.Println(<span class="hljs-string">&quot;end:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="select-switch"><a href="#select-switch" class="headerlink" title="select switch"></a>select switch</h3><blockquote><p>并发中的控制语句，类似于switch。用于处理异步io。</p><p>select会监听case中channel的读写操作，当case中的读写操作为非阻塞操作时，会触发响应的动作</p><p>select中的case语句必须是一个channel操作</p><p>select中的default语句总是可以运行</p></blockquote><ul><li>如果有多个case可以运行，select会公平的随机选择一个执行，其他的不执行</li><li>如果没有可运行的case，且有default语句，那么就会执行default语句</li><li>如果没有可运行的case，且没有default语句,select会阻塞，直到某个case通信可以运行</li></ul><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><blockquote><p>定时器，可以实现一些定时操作，内部通过channel实现</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个2s的定时器</span><br>   timer := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, time.Now())<br>   <span class="hljs-comment">//会一直阻塞，直到定时器的时间过了</span><br>   t := &lt;-timer.C<br>   fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, t)<br><br>   <span class="hljs-comment">//创建一个定时器，又阻塞两秒，</span><br>   timer2 := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>   &lt;-timer2.C<br><br>   <span class="hljs-comment">//可以使用Sleep实现阻塞功能</span><br>   time.Sleep(time.Second * <span class="hljs-number">2</span>)<br><br>   <span class="hljs-comment">//after也可以实现阻塞，after返回的就是 chan Time</span><br>   &lt;-time.After(time.Second * <span class="hljs-number">2</span>)<br><br>   timer3 := time.NewTimer(time.Second * <span class="hljs-number">2</span>)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      &lt;-timer3.C<br>      fmt.Println(<span class="hljs-string">&quot;hhh&quot;</span>)<br>   &#125;()<br>   <span class="hljs-comment">//上面定义了一个2s的定时器timer3，但是调用stop会立即停止等待,后面的打印也不会执行</span><br>   timer3.Stop()<br><br>   <span class="hljs-comment">//定义一个5s的定时器</span><br>   timer4 := time.NewTimer(time.Second * <span class="hljs-number">5</span>)<br>   <span class="hljs-comment">//修改定时器的时间为2s</span><br>   timer4.Reset(time.Second * <span class="hljs-number">2</span>)<br>   <span class="hljs-comment">//只阻塞2s</span><br>   &lt;-timer.C<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h3><blockquote><p>ticker周期性的执行</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建一个ticker，周期性的执行一次</span><br>   ticker := time.NewTicker(time.Second)<br>   <span class="hljs-comment">/*count := 1</span><br><span class="hljs-comment">   for _ = range ticker.C &#123;</span><br><span class="hljs-comment">      println(&quot;ticker&quot;)</span><br><span class="hljs-comment">      count++</span><br><span class="hljs-comment">      if count &gt;= 5 &#123;</span><br><span class="hljs-comment">         ticker.Stop()</span><br><span class="hljs-comment">         break</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">   &#125;*/</span><br><br>   chanInt := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br>   <span class="hljs-comment">//创建一个协程，周期性的向channel中写入数据，后面加（）是让匿名函数自己调用自己</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">for</span> _ = <span class="hljs-keyword">range</span> ticker.C &#123;<br>         <span class="hljs-keyword">select</span> &#123;<br>         <span class="hljs-keyword">case</span> chanInt &lt;- <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;发送1&quot;</span>)<br>         <span class="hljs-keyword">case</span> chanInt &lt;- <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;发送2&quot;</span>)<br>         <span class="hljs-keyword">case</span> chanInt &lt;- <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;发送3&quot;</span>)<br>         &#125;<br>      &#125;<br>   &#125;()<br><br>   <span class="hljs-comment">//从channel中读取数据</span><br>   <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> chanInt &#123;<br>      <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;收到：&quot;</span>, v)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><blockquote><p>sycn下的atomic是一个原子包，可以保证操作的原子性</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;sync/atomic&quot;</span><br>   <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int32</span> = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//使用原子操作：cas，compare and swap 保证线程安全</span><br>   <span class="hljs-comment">//第一个是变量的地址，第二个是增加的值</span><br>   atomic.AddInt32(&amp;i, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span></span> &#123;<br>   atomic.AddInt32(&amp;i, <span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>      <span class="hljs-keyword">go</span> add()<br>      <span class="hljs-keyword">go</span> sub()<br>   &#125;<br>   time.Sleep(time.Second)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;结果为：&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;io/ioutil&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">//创建文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createFile</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建文件，传入文件名称</span><br>   <span class="hljs-comment">//返回文件和错误信息，如果没发生错误，err=nil</span><br>   file, err := os.Create(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, file.Name())<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeDir</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//创建目录，第一个是目录名，第二个是权限，ModePerm表示最高权限</span><br>   err := os.Mkdir(<span class="hljs-string">&quot;a&quot;</span>, os.ModePerm)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125;<br>   <span class="hljs-comment">//MkdirAll 创建多级目录</span><br>   err1 := os.MkdirAll(<span class="hljs-string">&quot;b/c/d&quot;</span>, os.ModePerm)<br>   <span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err1)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//删除单个文件，可以是文件也可以是目录</span><br>   err := os.Remove(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125;<br><br>   err1 := os.RemoveAll(<span class="hljs-string">&quot;b&quot;</span>)<br>   <span class="hljs-keyword">if</span> err1 != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err1)<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 工作目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wd</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//获取当前工作目录</span><br>   dir, err := os.Getwd()<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//打印当前目录</span><br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, dir)<br>   &#125;<br>   <span class="hljs-comment">//修改当前工作目录</span><br>   os.Chdir(<span class="hljs-string">&quot;Users/didi/&quot;</span>)<br>   dir, _ = os.Getwd()<br>   <span class="hljs-comment">//打印当前目录</span><br>   fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, dir)<br>   <span class="hljs-comment">//临时目录</span><br>   tempDir := os.TempDir()<br>   fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, tempDir)<br>&#125;<br><br><span class="hljs-comment">//重命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rename</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//重命名，1.旧文件名 2.新文件名</span><br>   err := os.Rename(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;b.txt&quot;</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br>   &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//使用ioutil.ReadFile读取，直接输入文件名</span><br>   file, _ := ioutil.ReadFile(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, <span class="hljs-keyword">string</span>(file[:]))<br><br>   <span class="hljs-comment">//先创建句柄再读取</span><br>   open, _ := os.Open(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   bytes, _ := ioutil.ReadAll(open)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bytes[:]))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeFile</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//ioutil.WriteFile 写入：文件名、字节数组、权限</span><br>   <span class="hljs-comment">//会覆盖之前的内容</span><br>   ioutil.WriteFile(<span class="hljs-string">&quot;a.txt&quot;</span>, []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>), os.ModePerm)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   createFile()<br>   makeDir()<br>   remove()<br>   wd()<br>   readFile()<br>   writeFile()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="File文件读操作"><a href="#File文件读操作" class="headerlink" title="File文件读操作"></a>File文件读操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;io&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openclose</span><span class="hljs-params">()</span></span> &#123;<br><br>   <span class="hljs-comment">//打开文件，使用open方法文件只读，如果文件不存在则报错</span><br>   <span class="hljs-comment">//底层还是调用OpenFile方法</span><br>   file, _ := os.Open(<span class="hljs-string">&quot;a.txt&quot;</span>)<br>   <span class="hljs-built_in">println</span>(file.Name())<br><br>   <span class="hljs-comment">//O_RDWR：读写权限，O_CREATE：如果文件不存在则创建一个</span><br>   file, _ = os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="hljs-number">0755</span>)<br>   <span class="hljs-built_in">println</span>(file.Name())<br><br>   <span class="hljs-comment">//关闭文件</span><br>   file.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//等价于OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)</span><br>   file, _ := os.Create(<span class="hljs-string">&quot;a1.txt&quot;</span>)<br>   <span class="hljs-built_in">println</span>(file.Name())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> &#123;<br>   file, _ := os.Open(<span class="hljs-string">&quot;a.txt&quot;</span>)<br><br>   <span class="hljs-comment">//循环读取</span><br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-comment">//创建一个字符数组</span><br>      bufer := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">10</span>)<br>      <span class="hljs-comment">//将文件的数据读取到字符数组</span><br>      read, err := file.Read(bufer)<br>      <span class="hljs-comment">//如果读到文件末尾，退出循环</span><br>      <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>         <span class="hljs-keyword">break</span><br>      &#125;<br>      <span class="hljs-built_in">println</span>(read)<br>      <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bufer[:]))<br>   &#125;<br><br>   <span class="hljs-comment">//从某个地方开始读取</span><br>   bufer := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">5</span>)<br>   <span class="hljs-comment">//从第二个字节开始读取5个字节</span><br>   n, _ := file.ReadAt(bufer, <span class="hljs-number">2</span>)<br>   <span class="hljs-built_in">println</span>(n)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bufer))<br><br>   <span class="hljs-comment">//定位</span><br>   <span class="hljs-comment">//相对于文件头偏移2个单位</span><br>   file.Seek(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>   n, _ = file.Read(bufer)<br>   <span class="hljs-built_in">println</span>(n)<br>   <span class="hljs-built_in">println</span>(<span class="hljs-keyword">string</span>(bufer))<br><br>   file.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   readFile()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="File写操作"><a href="#File写操作" class="headerlink" title="File写操作"></a>File写操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">//打开文件，O_APPEND 追加到文件末尾 O_TRUNC:清空</span><br>   file, _ := os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR|os.O_APPEND, <span class="hljs-number">0777</span>)<br>   file.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello golang!&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeString</span><span class="hljs-params">()</span></span> &#123;<br>   file, _ := os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR|os.O_TRUNC, <span class="hljs-number">0777</span>)<br>   <span class="hljs-comment">//直接写字符串</span><br>   file.WriteString(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeAt</span><span class="hljs-params">()</span></span> &#123;<br>   file, _ := os.OpenFile(<span class="hljs-string">&quot;a.txt&quot;</span>, os.O_RDWR, <span class="hljs-number">0777</span>)<br>   <span class="hljs-comment">//在指定位置开始写入</span><br>   file.WriteAt([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hha&quot;</span>), <span class="hljs-number">4</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   write()<br>   writeString()<br>   writeAt()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;结构程序化&quot;&gt;&lt;a href=&quot;#结构程序化&quot; class=&quot;headerlink&quot; title=&quot;结构程序化&quot;&gt;&lt;/a&gt;结构程序化&lt;/h2&gt;&lt;h3 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql函数</title>
    <link href="http://example.com/2022/07/31/Mysql%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/07/31/Mysql%E5%87%BD%E6%95%B0/</id>
    <published>2022-07-31T13:47:02.427Z</published>
    <updated>2022-07-31T13:47:02.639Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录刷题过程中需要使用到的一些mysql函数</p><p>窗口函数：窗口函数也叫OLAP函数，可以对数据进行实时分析处理。</p><p>窗口函数用法：</p><p>&lt;窗口函数&gt; OVER ( [PARTITION BY &lt;列清单&gt; ]</p><p>​                ORDER BY &lt;排序用列清单&gt; ）</p><p>*其中[ ]中的内容可以忽略</p></blockquote><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK()"></a>RANK()</h3><p>在计算排序时，若存在相同位次，会跳过之后的位次。例如，有3条排在第1位时，排序为：1，1，1，4······</p><h3 id="DENSE-RANK"><a href="#DENSE-RANK" class="headerlink" title="DENSE_RANK()"></a>DENSE_RANK()</h3><p>在计算排序时，若存在相同位次，不会跳过之后的位次。例如，有3条排在第1位时，排序为：1，1，1，2······</p><h3 id="ROW-NUMBER"><a href="#ROW-NUMBER" class="headerlink" title="ROW_NUMBER()"></a>ROW_NUMBER()</h3><p>这个函数赋予唯一的连续位次。例如，有3条排在第1位时，排序为：1，2，3，4······</p><p>牛客网SQL217就用到了<code>dense_rank()</code>函数：</p><p>对所有员工的薪水按照salary降序先进行1-N的排名，如果salary相同，再按照emp_no升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  emp_no,<br>  salary,<br>  <span class="hljs-keyword">dense_rank</span>() <span class="hljs-keyword">over</span> (<br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>      salary <span class="hljs-keyword">desc</span><br>  ) <span class="hljs-keyword">rank</span><br><span class="hljs-keyword">from</span><br>  salaries<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">rank</span> <span class="hljs-keyword">asc</span>,emp_no <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure><h2 id="小数格式化"><a href="#小数格式化" class="headerlink" title="小数格式化"></a>小数格式化</h2><blockquote><p>有时题目需要将结果保留几位小数</p></blockquote><h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND()"></a>ROUND()</h3><p><code>round(number,n)</code>可以指定保留几位小数，采用四舍五入。 如<code>round(3.1415,3)</code>会变成3.142</p><p>如果小数位不足指定的位数，比如只有一位小数，需要保留到两位小数则只会显示一位小数。</p><h3 id="CONVERT"><a href="#CONVERT" class="headerlink" title="CONVERT()"></a>CONVERT()</h3><p><code>CONVERT(X,DECIMAL(L,D))</code></p><p>L:格式化的数的总的长度；D:小数的个数；X:格式化的数字。 如：<code>convert(3.1314,decimal(10,2))</code>将会保留两位小数。四舍五入。</p><p>如果小数位不足，会自动补0。</p><h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><p><code>TRUNCATE（X,D）</code></p><p>X:格式化的数字，D:小数的个数。会直接舍去，不会四舍五入。</p><p>如果小数位不足，只会显示已有的小数位。不会补0。</p><h3 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h3><p><code>FORMAT（X,D）</code></p><p>四舍五入，会自动补0。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录刷题过程中需要使用到的一些mysql函数&lt;/p&gt;
&lt;p&gt;窗口函数：窗口函数也叫OLAP函数，可以对数据进行实时分析处理。&lt;/p&gt;
&lt;p&gt;窗口函数用法：&lt;/p&gt;
&lt;p&gt;&amp;lt;窗口函数&amp;gt; OVER ( [PARTITION BY &amp;lt;列</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Php语言基础</title>
    <link href="http://example.com/2022/07/31/php/"/>
    <id>http://example.com/2022/07/31/php/</id>
    <published>2022-07-31T13:47:01.119Z</published>
    <updated>2022-07-31T13:53:20.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><ul><li>定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。</li><li>函数内定义的变量就是局部变量，它的作用域为函数定义范围内。</li><li>函数之间存在作用域互不影响。</li><li>函数内访问全局变量需要 <strong>global</strong> 关键字或者使用 <strong>$GLOBALS[index]</strong> 数组</li></ul><p>在 php 中函数是有独立的作用域，所以局部变量会覆盖全局变量，即使局部变量中没有全局变量相同的变量，也会被覆盖。</p></blockquote><p>php是一门弱类型语言，声明变量时不需要声明变量的数据类型。</p><p>命名规则和Java一样，以字母或者下划线开头，只能用字母、下划线、数字命名。区分大小写。</p><p>声明变量时，使用<code>$</code>,后面紧跟变量名称。</p><p>如：<code>$a = 1</code></p><p>有四种变量定义域：</p><ul><li>local:局部作用域</li><li>global：全局作用域</li><li>static：静态作用域</li><li>parameter：参数作用域</li></ul><p>定义在所有函数之外的变量具有全局作用域。在一个函数内想要使用全局变量，需要使用<code>global</code>关键字。</p><p>PHP 将所有全局变量存储在一个名为 <code>$GLOBALS[*index*]</code>的数组中。 <em>index</em> 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$x=<span class="hljs-number">5</span>;<br>$y=<span class="hljs-number">10</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTest</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">global</span> $x,$y;<br>    $y=$x+$y;<br>&#125;<br> <br>myTest();<br><span class="hljs-keyword">echo</span> $y; <span class="hljs-comment">// 输出 15</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>当一个函数完成时，他定义的所有变量都会被删除，如果你不想某个局部变量被删除，可以使用static修饰。<strong>该变量仍然是函数的局部变量。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myTest</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">static</span> $x=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">echo</span> $x;<br>    $x++;<br>    <span class="hljs-keyword">echo</span> PHP_EOL;    <span class="hljs-comment">// 换行符</span><br>&#125;<br> <br>myTest(); <span class="hljs-comment">//0</span><br>myTest(); <span class="hljs-comment">//1</span><br>myTest(); <span class="hljs-comment">//2</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量值被定义后，在脚本的其他任何地方都不能被改变，在整个脚本中都可以使用。</p><p>设置常量，使用 define() 函数，函数语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> define ( <span class="hljs-keyword">string</span> $name , mixed $value [, <span class="hljs-keyword">bool</span> $case_insensitive = <span class="hljs-literal">false</span> ] )<br></code></pre></td></tr></table></figure><p>该函数有三个参数:</p><ul><li><strong>name：</strong>必选参数，常量名称，即标志符。</li><li><strong>value：</strong>必选参数，常量的值。</li><li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><p><code>define(&quot;GREETING&quot;, &quot;欢迎访问 Runoob.com&quot;);</code></p><p>创建了一个变量名为GREETING的常量。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>可以使用<code>echo</code> 和<code>print</code>来进行打印输出，两者都可以使用括号或者不使用括号。</p><p>区别在于前者可以输出多个字符串，后者只可以输出一个字符串。</p><p>输出的字符可以包含html标签。</p><h2 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h2><p>虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。</p><ul><li>松散比较：使用两个等号 <strong>==</strong> 比较，只比较值，不比较类型。</li><li>严格比较：用三个等号 <strong>===</strong> 比较，除了比较值，也比较类型。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">42</span> == <span class="hljs-string">&quot;42&quot;</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;1、值相等&#x27;</span>;<br>&#125;<br> <br><span class="hljs-keyword">echo</span> PHP_EOL; <span class="hljs-comment">// 换行符</span><br> <br><span class="hljs-keyword">if</span>(<span class="hljs-number">42</span> === <span class="hljs-string">&quot;42&quot;</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;2、类型相等&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;3、类型不相等&#x27;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br>  <br><span class="hljs-comment">// 1、值相等 3、类型不相等</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>定义字符串的时候需要使用单引号或者双引号括起来。</p><h3 id="并置运算符"><a href="#并置运算符" class="headerlink" title="并置运算符"></a>并置运算符</h3><p>将两个字符串连接起来。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$txt1=<span class="hljs-string">&quot;Hello world!&quot;</span>;<br>$txt2=<span class="hljs-string">&quot;What a nice day!&quot;</span>;<br><span class="hljs-keyword">echo</span> $txt1 . $txt2;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p>返回字符串的长度</p><h3 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a>strpos()</h3><p>在字符串中查找一个字符或者指定的文本。如果存在返回第一个匹配的字符的位置，否则返回false。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> strpos(<span class="hljs-string">&quot;Hello world!&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br>  <br><span class="hljs-comment">//返回6</span><br></code></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数主要用来在创建对象时初始化对象，即为对象成员变量赋初值。</p><p>使用<code>_construct</code>关键字定义。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数和构造函数相反，当对象结束其生命周期时系统自动执行析构函数。</p><p>使用<code>_destruct</code>关键字定义。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类可以继承父类，使用<code>extends</code>关键字。</p><p>继承之后，子类拥有父类的所有东西，包括protected、private，但是父类私有的属性和方法不能让子类直接调用。子类可以扩展自己的属性和方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口使用<code>interface</code>定义，接口中的所有方法都必须是公有的。php可以实现多个接口，实现接口时必须实现接口定义的所有方法，使用<code>implements</code>实现接口。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类里面有一个抽象方法，那么这个类必须是抽象类。抽象类不能被实例化。</p><p>继承一个抽象类的时候，必须重写所有的抽象方法；并且这些方法的访问权限必须大于等于父类的访问权限。使用<code>abstruct</code>修饰抽象方法和抽象类。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>声明属性或者方法为static，就可以不实例化类而直接访问。</p><p>静态属性不能通过一个实例化的对象来访问，静态方法可以。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> $my_static = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">staticValue</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::$my_static;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">print</span> Foo::$my_static . PHP_EOL;<br>$foo = <span class="hljs-keyword">new</span> Foo();<br><br><span class="hljs-keyword">print</span> $foo-&gt;staticValue() . PHP_EOL;<br><span class="hljs-meta">?&gt;</span>  <br>  <br><span class="hljs-comment">//foo</span><br><span class="hljs-comment">//foo</span><br></code></pre></td></tr></table></figure><h3 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h3><p>如果父类中的方法被声明为final，则子类无法覆盖该方法。如果一个类被声明为final，则不能被继承。</p><h3 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h3><p>php不像java，php不会自动调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用<code>parent::_construct()</code></p><h3 id="date-函数"><a href="#date-函数" class="headerlink" title="date()函数"></a>date()函数</h3><p>date()函数用于格式化时间/日期。</p><p><code>string date ( string $format [, int $timestamp ] )</code></p><ul><li>format:必需。规定时间戳的格式。</li><li>timestamp:可选。规定时间戳。默认是当前的日期和时间。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y/m/d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y.m.d&quot;</span>) . <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> date(<span class="hljs-string">&quot;Y-m-d&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2016/10/21</span><br><span class="hljs-comment">2016.10.21</span><br><span class="hljs-comment">2016-10-21</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>date() 函数的第一个必需参数 <em>format</em> 规定了如何格式化日期/时间。</p><p>这里列出了一些可用的字符：</p><ul><li>d - 代表月中的天 (01 - 31)</li><li>m - 代表月 (01 - 12)</li><li>Y - 代表年 (四位数)</li></ul><h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p>假设您有一个标准的页头文件，名为 “header.php”。如需在页面中引用这个页头文件，请使用 include/require：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;header.php&#x27;</span>; <span class="hljs-meta">?&gt;</span><br>&lt;h1&gt;欢迎来到我的主页!&lt;/h1&gt;<br>&lt;p&gt;一些文本。&lt;/p&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>require() 语句的性能与 include() 相类似，都是包括并运行指定文件。不同之处在于：对 include() 语句来说，在执行文件时每次都要进行读取和评估；而对于 require() 来说，文件只处理一次（实际上，文件内容替换 require() 语句）。这就意味着如果可能执行多次的代码，则使用 require() 效率比较高。</p><ul><li><p>require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；==在一开始就加载==</p></li><li><p>include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。==用到时才加载==</p></li><li><p>require 引入的文件有错误时，执行会中断，并返回一个致命错误；</p></li><li><p>include 引入的文件有错误时，会继续执行，并返回一个警告。</p></li></ul><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>fopen() 函数用于在 PHP 中打开文件。</p><p>此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">只读。在文件的开头开始。</td></tr><tr><td align="left">r+</td><td align="left">读/写。在文件的开头开始。</td></tr><tr><td align="left">w</td><td align="left">只写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td></tr><tr><td align="left">w+</td><td align="left">读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td></tr><tr><td align="left">a</td><td align="left">追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。</td></tr><tr><td align="left">a+</td><td align="left">读/追加。通过向文件末尾写内容，来保持文件内容。</td></tr><tr><td align="left">x</td><td align="left">只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td></tr><tr><td align="left">x+</td><td align="left">读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;html&gt;<br>&lt;body&gt;<br><br><span class="hljs-meta">&lt;?php</span><br>$file=fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);  <span class="hljs-comment">//以只读的形式打开文件</span><br><span class="hljs-meta">?&gt;</span><br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>如果无法打开文件则fopen()函数会返回0</strong></p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>fclose() 函数用于关闭打开的文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$file = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">//执行一些代码</span><br><br>fclose($file);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="检测文件末尾（EOF）"><a href="#检测文件末尾（EOF）" class="headerlink" title="检测文件末尾（EOF）"></a>检测文件末尾（EOF）</h3><p>feof() 函数检测是否已到达文件末尾（EOF）。</p><p>在循环遍历未知长度的数据时，feof() 函数很有用。</p><p><strong>注释：</strong>在 w 、a 和 x 模式下，您无法读取打开的文件！</p><p><code>if (feof($file)) echo &quot;文件结尾&quot;;</code></p><h3 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h3><p>fgets() 函数用于从文件中逐行读取文件。</p><p><strong>注释：</strong>在调用该函数之后，文件指针会移动到下一行。</p><p>下面的实例逐行读取文件，直到文件末尾为止：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$file = fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;无法打开文件!&quot;</span>);<br><span class="hljs-comment">// 读取文件每一行，直到文件结尾</span><br><span class="hljs-keyword">while</span>(!feof($file))<br>&#123;<br>  <span class="hljs-keyword">echo</span> fgets($file). <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>&#125;<br>fclose($file);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="逐字符读取文件"><a href="#逐字符读取文件" class="headerlink" title="逐字符读取文件"></a>逐字符读取文件</h3><p>fgetc() 函数用于从文件中逐字符地读取文件。</p><p><strong>注释：</strong>在调用该函数之后，文件指针会移动到下一个字符。</p><p>下面的实例逐字符地读取文件，直到文件末尾为止：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>$file=fopen(<span class="hljs-string">&quot;welcome.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;无法打开文件!&quot;</span>);<br><span class="hljs-keyword">while</span> (!feof($file))<br>&#123;<br>  <span class="hljs-keyword">echo</span> fgetc($file);<br>&#125;<br>fclose($file);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p><a href="https://www.runoob.com/php/php-file-upload.html">详情参考如下链接</a></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote><p>cookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。</p></blockquote><h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><p>setcookie() 函数用于设置 cookie。<strong>setcookie() 函数必须位于 <html> 标签之前。</html></strong></p><p><code>setcookie(name, value, expire, path, domain);</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>setcookie(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;runoob&quot;</span>, time()+<span class="hljs-number">3600</span>);<br><span class="hljs-meta">?&gt;</span><br><br>&lt;html&gt;<br>.....<br></code></pre></td></tr></table></figure><h3 id="取回cookie"><a href="#取回cookie" class="headerlink" title="取回cookie"></a>取回cookie</h3><p>PHP 的 $_COOKIE 变量用于取回 cookie 的值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 输出 cookie 值</span><br><span class="hljs-keyword">echo</span> $_COOKIE[<span class="hljs-string">&quot;user&quot;</span>];<br><br><span class="hljs-comment">// 查看所有 cookie</span><br>print_r($_COOKIE);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h3><p>当删除 cookie 时，您应当使过期日期变更为过去的时间点。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 设置 cookie 过期时间为过去 1 小时</span><br>setcookie(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, time()<span class="hljs-number">-3600</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="SESSION"><a href="#SESSION" class="headerlink" title="SESSION"></a>SESSION</h2><p>PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。</p><p>在使用php session之前，需要先开启php session</p><p><code>session_start();</code>,这个函数必须位于<html>标签之前</html></p><p>session_start()会向服务器注册用户的会话，以便您可以开始保存用户信息，同时会为用户会话分配一个 UID。</p><h3 id="存储session"><a href="#存储session" class="headerlink" title="存储session"></a>存储session</h3><p>存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>session_start();<br><span class="hljs-comment">// 存储 session 数据</span><br>$_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-meta">?&gt;</span><br> <br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;<br>&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 检索 session 数据</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;浏览量：&quot;</span>. $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在下面的实例中，我们创建了一个简单的 page-view 计数器。isset() 函数检测是否已设置 “views” 变量。如果已设置 “views” 变量，我们累加计数器。如果 “views” 不存在，则创建 “views” 变量，并把它设置为 1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>session_start();<br> <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]))<br>&#123;<br>    $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]=$_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;浏览量：&quot;</span>. $_SESSION[<span class="hljs-string">&#x27;views&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="销毁SESSION"><a href="#销毁SESSION" class="headerlink" title="销毁SESSION"></a>销毁SESSION</h3><p>使用 unset() 或 session_destroy() 函数销毁session。</p><p>unset() 函数用于释放指定的 session 变量；session_destroy() 函数彻底销毁 session：</p><p><code>unset($_SESSION[&#39;views&#39;]); 或者  session_destroy();</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定义在函数外部的就是全局变量，它的作用域从定义处一直到文件结尾。&lt;/li&gt;
&lt;li&gt;函数内定义的变量就</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RPC</title>
    <link href="http://example.com/2022/07/13/RPC/"/>
    <id>http://example.com/2022/07/13/RPC/</id>
    <published>2022-07-13T08:16:47.555Z</published>
    <updated>2022-07-13T08:21:02.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-什么是-RPC？原理是什么？"><a href="#01-什么是-RPC？原理是什么？" class="headerlink" title="01 什么是 RPC？原理是什么？"></a>01 什么是 RPC？原理是什么？</h1><h2 id="1-什么是-RPC？"><a href="#1-什么是-RPC？" class="headerlink" title="1. 什么是 RPC？"></a>1. 什么是 RPC？</h2><p>RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p><p>为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p><p>RPC 能帮助我们做什么呢？  简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p><p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p><p>一言蔽之：RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</p><h2 id="2-RPC-原理是什么？"><a href="#2-RPC-原理是什么？" class="headerlink" title="2. RPC 原理是什么？"></a>2. RPC 原理是什么？</h2><p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 6 个部分实现的：</p><ol><li>客户端（服务消费端） ：调用远程方法的一端。</li><li>客户端 Stub（桩） ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li>网络传输 ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li><li>服务端 Stub（桩） ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li>服务端（服务提供端） ：提供远程方法的一端。</li></ol><p>具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704120100609.png" alt="image-20220704120100609"></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: RpcRequest；</li><li>服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:RpcResponse ，这样也就得到了最终结果。over!</li></ol><p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p><p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p><p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p><h1 id="02-常见RPC框架介绍"><a href="#02-常见RPC框架介绍" class="headerlink" title="02 常见RPC框架介绍"></a>02 常见RPC框架介绍</h1><h2 id="常见RPC框架介绍"><a href="#常见RPC框架介绍" class="headerlink" title="常见RPC框架介绍"></a>常见RPC框架介绍</h2><p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC这些。   如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704120316871.png" alt="image-20220704120316871"></p><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：</p><ol><li>面向接口的远程方法调用</li><li>智能容错和负载均衡</li><li>服务自动注册和发现。</li></ol><p>简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。</p><p>截止到今天（2020-07-14） ， Dubbo 目前已经有接近 32.9k 的 Star 。</p><p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p><p>可以说 Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！<br>如果要进一步学习的学习的话，这里有参考文档：</p><ol><li>Github ：<a href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a></li><li>官网：<a href="https://dubbo.apache.org/zh-cn/">https://dubbo.apache.org/zh-cn/</a></li></ol><h3 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a>Motan</h3><p>motan 是今年(2016 年)新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上流传的资料也比较少。</p><p>很多人喜欢拿 motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：<strong>motan 更像是一个精简版的 dubbo，可能是借鉴了 Dubbo 的思想，motan 的设计更加精简，功能更加纯粹。</strong></p><p>不过，我不推荐你在实际项目中使用 motan。<strong>如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。</strong></p><p>如果要进一步学习的学习的话，这里有参考文档：</p><p>1<br>从 motan 看 RPC 框架设计：<a href="http://kriszhang.com/motan-rpc-impl/">http://kriszhang.com/motan-rpc-impl/</a><br>2<br>motan 中文文档：<a href="https://github.com/weibocom/motan/wiki/zh_overview">https://github.com/weibocom/motan/wiki/zh_overview</a></p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704120441271.png" alt="image-20220704120441271"></p><p>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。</p><p>通过 ProtoBuf 定义接口和数据类型还挺繁琐的，虽然 gRPC 确实很多亮点的地方，但是我还是选择 Dubbo。</p><p>如果要进一步学习的学习的话，这里有参考文档：</p><ol><li>Github：<a href="https://github.com/grpc/grpc">https://github.com/grpc/grpc</a></li><li>官网：<a href="https://grpc.io/">https://grpc.io/</a></li></ol><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><p>Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</p><p>Thrift支持多种不同的编程语言，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等（相比于 gRPC 支持的语言更多 ）。</p><ol><li>官网：<a href="https://thrift.apache.org/">https://thrift.apache.org/</a></li><li>Thrift 简单介绍：<a href="https://www.jianshu.com/p/8f25d057a5a9">https://www.jianshu.com/p/8f25d057a5a9</a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是因为它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。</p><p>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。最重要的是其在国内有很多成功的案例比如当当网、滴滴等等。下图展示了 Dubbo 的生态系统。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704123904515.png" alt="image-20220704123904515"></p><p>另外 ，Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704123920049.png" alt="image-20220704123920049"></p><p>但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨语言调用的话，可以考虑一下 Thrift 和 gRPC。</p><p>综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。</p><h1 id="03-如何自己实现一个-RPC-框架？"><a href="#03-如何自己实现一个-RPC-框架？" class="headerlink" title="03 如何自己实现一个 RPC 框架？"></a>03 如何自己实现一个 RPC 框架？</h1><p>如果让你自己设计 RPC 框架你会如何设计？</p><p>一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。</p><p>为了便于小伙伴们理解，我们先从一个最简单的 RPC 框架使用示意图开始。这也是 <a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 目前的架构 。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124159909.png" alt="image-20220704124159909"></p><p>从上图我们可以看出：<strong>服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。</strong></p><p>作为 RPC 框架领域的佼佼者Dubbo的架构如下图所示,和我们上面画的大体也是差不多的。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124232741.png" alt="image-20220704124232741"></p><p>下面我们再来看一个比较完整的 RPC 框架使用示意图如下：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124257969.png" alt="image-20220704124257969"></p><p>参考上面这张图，我们简单说一下设计一个最基本的 RPC 框架的思路或者说实现一个最基本的 RPC 框架需要哪些东西：</p><h3 id="1-注册中心"><a href="#1-注册中心" class="headerlink" title="1.注册中心"></a>1.注册中心</h3><p>注册中心首先是要有的。比较推荐使用 Zookeeper 作为注册中心。当然了，你也可以使用 Nacos ，甚至是 Redis。</p><p>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</p><p>关于 ZooKeeper 的更多介绍可以看我总结的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#_1-%E5%89%8D%E8%A8%80">《ZooKeeper相关概念总结》</a></p><p>当然了，如果你想通过文件来存储服务地址的话也是没问题的，不过性能会比较差。</p><p><strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p><p>我们再来结合 Dubbo 的架构图来理解一下！</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124408934.png" alt="image-20220704124408934"></p><p>上述节点简单说明：</p><ul><li>Provider： 暴露服务的服务提供方</li><li>Consumer： 调用远程服务的服务消费方</li><li>Registry： 服务注册与发现的注册中心</li><li>Monitor： 统计服务的调用次数和调用时间的监控中心</li><li>Container： 服务运行容器</li></ul><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="2-网络传输"><a href="#2-网络传输" class="headerlink" title="2.网络传输"></a>2.网络传输</h3><p><strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</strong></p><p>网络传输具体实现你可以使用<strong>Socket</strong>（ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p><p>你也可以使用同步非阻塞的 I/O 模型<strong>NIO</strong> ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择！</p><p>我先简单介绍一下 Netty ，后面的文章中我会详细介绍到。</p><ol><li><strong>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</strong></li><li>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li><li>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li></ol><h3 id="3-序列化和反序列化"><a href="#3-序列化和反序列化" class="headerlink" title="3.序列化和反序列化"></a>3.序列化和反序列化</h3><p>要在网络传输数据就要涉及到序列化。为什么需要序列化和反序列化呢？ </p><p>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其序列化为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次反序列化。</p><p>另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704124723073.png" alt="image-20220704124723073"></p><p>JDK 自带的序列化，只需实现<code> java.io.Serializable</code>接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。</p><p>现在比较常用序列化的有 <strong>hessian、kyro、protostuff</strong> ……。我会在下一篇文章中简单对比一下这些序列化方式。</p><h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><p>动态代理也是需要的。很多人可能不清楚为啥需要动态代理？我来简单解释一下吧！</p><p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p><p>讲完了代理模式，再来说动态代理在 RPC 框架中的作用。</p><p>前面第一节的时候，我们就已经提到 ：<strong>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。</strong></p><p>怎样才能屏蔽程方法调用的底层细节呢？</p><p>答案就是<strong>动态代理。</strong>简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。</p><p>相关文章： <a href="https://javaguide.cn/java/basis/proxy.html#_1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式详解：静态代理+JDK/CGLIB 动态代理实战</a></p><h3 id="5-负载均衡"><a href="#5-负载均衡" class="headerlink" title="5.负载均衡"></a>5.负载均衡</h3><p>负载均衡也是需要的。为啥？</p><p>举个例子：我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p><h3 id="6-传输协议"><a href="#6-传输协议" class="headerlink" title="6.传输协议"></a>6.传输协议</h3><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</p><p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据。</strong>这有一点像密文传输的感觉。</p><p>通常一些标准的 RPC 协议包含下面这些内容：</p><ul><li>魔数 ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。</li><li>序列化器编号 ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。</li><li>消息体长度 ： 运行时计算出来。</li><li>……</li></ul><p>如果你想看 guide-rpc-framework 的 RPC 协议设计的话，可以在 Netty 编解码器相关的类中找到。</p><h2 id="实现一个最基本的-RPC-框架需要哪些技术？"><a href="#实现一个最基本的-RPC-框架需要哪些技术？" class="headerlink" title="实现一个最基本的 RPC 框架需要哪些技术？"></a>实现一个最基本的 RPC 框架需要哪些技术？</h2><p>刚刚我们已经聊了如何实现一个 RPC 框架，下面我们就来看看实现一个最基本的 RPC 框架需要哪些技术吧！</p><p>按照我实现的这一款基于 Netty+Kyro+Zookeeper 实现的 RPC 框架来说的话，你需要下面这些技术支撑：</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ol><li>动态代理机制；</li><li>序列化机制以及各种序列化框架的对比，比如 hession2、kyro、protostuff；</li><li>线程池的使用；</li><li>CompletableFuture 的使用；</li><li>……</li></ol><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ol><li>使用 Netty 进行网络传输；</li><li>ByteBuf 介绍；</li><li>Netty 粘包拆包；</li><li>Netty 长连接和心跳机制；</li><li>……</li></ol><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ol><li>基本概念；</li><li>数据结构；</li><li>如何使用 Netflix 公司开源的 zookeeper 客户端框架 Curator 进行增删改查；</li><li>……</li></ol><h1 id="04-序列化介绍以及序列化协议选择"><a href="#04-序列化介绍以及序列化协议选择" class="headerlink" title="04 序列化介绍以及序列化协议选择"></a>04 序列化介绍以及序列化协议选择</h1><h2 id="序列化和反序列化相关概念"><a href="#序列化和反序列化相关概念" class="headerlink" title="序列化和反序列化相关概念"></a>序列化和反序列化相关概念</h2><p>什么是序列化?什么是反序列化?</p><p>如果我们需要持久化Java对象比如将Java对象保存在文件中，或者在网络传输Java对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li>序列化： 将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程</li></ul><p>对于Java这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><blockquote><p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p><strong>综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125247053.png" alt="image-20220704125247053"></p><p><a href="https://www.corejavaguru.com/java/serialization/interview-questions-1">https://www.corejavaguru.com/java/serialization/interview-questions-1</a></p><h2 id="实际开发中有哪些用到序列化和反序列化的场景"><a href="#实际开发中有哪些用到序列化和反序列化的场景" class="headerlink" title="实际开发中有哪些用到序列化和反序列化的场景"></a>实际开发中有哪些用到序列化和反序列化的场景</h2><ol><li>对象在进行网络传输（比如远程方法调用RPC的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li></ol><h2 id="序列化协议对应于TCP-IP-4层模型的哪一层？"><a href="#序列化协议对应于TCP-IP-4层模型的哪一层？" class="headerlink" title="序列化协议对应于TCP/IP 4层模型的哪一层？"></a>序列化协议对应于TCP/IP 4层模型的哪一层？</h2><p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125359908.png" alt="image-20220704125359908"></p><p>如上图所示，<u>OSI七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么</u>？</p><p>因为，OSI七层协议模型中的应用层、表示层和会话层对应的都是TCP/IP 四层模型中的应用层，所以序列化协议属于TCP/IP协议应用层的一部分。</p><h2 id="常见序列化协议对比"><a href="#常见序列化协议对比" class="headerlink" title="常见序列化协议对比"></a>常见序列化协议对比</h2><p>JDK自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kyro、protostuff。</p><p>下面提到的都是基于二进制的序列化协议，像 JSON 和 XML这种属于文本类序列化方式。虽然 JSON 和 XML可读性比较好，但是性能较差，一般不会选择。</p><h3 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h3><p>JDK 自带的序列化，只需实现 java.io.Serializable接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的序列化号</p></blockquote><p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p><ol><li><strong>不支持跨语言调用 :</strong> 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li></ol><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p><p>guide-rpc-framework  就是使用的 kyro 进行序列化，序列化和反序列化相关的代码如下：、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 19:29:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        Kryo kryo = <span class="hljs-keyword">new</span> Kryo();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>             Output output = <span class="hljs-keyword">new</span> Output(byteArrayOutputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;Serialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);<br>             Input input = <span class="hljs-keyword">new</span> Input(byteArrayInputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span><br>            Object o = kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;Deserialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Github 地址：<a href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a> 。</p><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是却可以让 Protobuf 没有序列化漏洞的风险。</p><blockquote><p>Protobuf包含序列化格式的定义、各种语言的库以及一个IDL编译器。正常情况下你需要定义proto文件，然后使用IDL编译器编译成你需要的语言</p></blockquote><p>一个简单的 proto 文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// protobuf的版本</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <br><span class="hljs-comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span><br>message Person &#123;<br>  <span class="hljs-comment">//string类型字段</span><br>  string name = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// int 类型字段</span><br>  int32 age = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Github地址：<a href="https://github.com/protocolbuffers/protobuf%E3%80%82">https://github.com/protocolbuffers/protobuf。</a></p><h3 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h3><p>由于Protobuf的易用性，它的哥哥 Protostuff  诞生了。</p><p>protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p><p>Gihub地址：<a href="https://github.com/protostuff/protostuff%E3%80%82">https://github.com/protostuff/protostuff。</a></p><h3 id="hession"><a href="#hession" class="headerlink" title="hession"></a>hession</h3><p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125745480.png" alt="image-20220704125745480"></p><p>dubbo RPC默认启用的序列化方式是 hession2 ,但是，Dubbo对hessian2进行了修改，不过大体结构还是差不多。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Kryo 是专门针对Java语言序列化方式并且性能非常好，如果你的应用是专门针对Java语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/</a>)</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704125819700.png" alt="image-20220704125819700"></p><p>像Protobuf、 ProtoStuff、hession这类都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p><p>除了我上面介绍到的序列化方式的话，还有像 Thrift，Avro 这些。</p><h2 id="其他推荐阅读"><a href="#其他推荐阅读" class="headerlink" title="其他推荐阅读"></a>其他推荐阅读</h2><ol><li>美团技术团队-序列化和反序列化：<a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a></li><li>在Dubbo中使用高效的Java序列化（Kryo和FST）: <a href="https://dubbo.apache.org/zh-cn/docs/user/serialization.html">https://dubbo.apache.org/zh-cn/docs/user/serialization.html</a></li></ol><h1 id="05-Socket-网络通信实战"><a href="#05-Socket-网络通信实战" class="headerlink" title="05 Socket 网络通信实战"></a>05 Socket 网络通信实战</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>guide-rpc-framework 的第一版使用的是 JDK 提供了 socket 进行网络编程。为了搞懂具体原理，我们首先要学会使用 Socket 进行网络通信。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704130001809.png" alt="image-20220704130001809"></p><h2 id="2-什么是-Socket-套接字"><a href="#2-什么是-Socket-套接字" class="headerlink" title="2. 什么是 Socket(套接字)"></a>2. 什么是 Socket(套接字)</h2><p>Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操作套接字的时候，和我们读写文件很像。套接字是 IP 地址与端口的组合，套接字 Socket=（IP 地址：端口号）。</p><p>要通过互联网进行通信，至少需要一对套接字：</p><ol><li>运行于服务器端的 Server Socket。</li><li>运行于客户机端的 Client Socket</li></ol><p>在 Java 开发中使用 Socket 时会常用到两个类，都在 java.net 包中：</p><ol><li><code>Socket:</code> 一般用于客户端</li><li><code>ServerSocket: </code>用于服务端</li></ol><h2 id="3-Socket-网络通信过程"><a href="#3-Socket-网络通信过程" class="headerlink" title="3. Socket 网络通信过程"></a>3. Socket 网络通信过程</h2><p>Socket 网络通信过程如下图所示：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704130115513.png" alt="image-20220704130115513"></p><p><a href="https://www.javatpoint.com/socket-programming">https://www.javatpoint.com/socket-programming</a></p><p>Socket 网络通信过程简单来说分为下面 4 步：</p><ol><li>建立服务端并且监听客户端请求</li><li>客户端请求，服务端和客户端建立连接</li><li>两端之间可以传递数据</li><li>关闭资源</li></ol><p>对应到服务端和客户端的话，是下面这样的。</p><p><strong>服务器端：</strong></p><ol><li>创建 ServerSocket 对象并且绑定地址（ip）和端口号(port)：server.bind(new InetSocketAddress(host, port))</li><li>通过 accept()方法监听客户端请求</li><li>连接建立后，通过输入流读取客户端发送的请求信息</li><li>通过输出流向客户端发送响应信息</li><li>关闭相关资源</li></ol><p><strong>客户端：</strong></p><ol><li>创建Socket 对象并且连接指定的服务器的地址（ip）和端口号(port)：socket.connect(inetSocketAddress)</li><li>连接建立后，通过输出流向服务器端发送请求信息</li><li>通过输入流获取服务器响应的信息</li><li>关闭相关资源</li></ol><h2 id="4-Socket-网络通信实战"><a href="#4-Socket-网络通信实战" class="headerlink" title="4. Socket 网络通信实战"></a>4. Socket 网络通信实战</h2><h3 id="4-1-服务端"><a href="#4-1-服务端" class="headerlink" title="4.1. 服务端"></a>4.1. 服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServer.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-comment">//1.创建 ServerSocket 对象并且绑定一个端口</span><br>        <span class="hljs-keyword">try</span> (ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(port);) &#123;<br>            Socket socket;<br>            <span class="hljs-comment">//2.通过 accept()方法监听客户端请求</span><br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-keyword">null</span>) &#123;<br>                logger.info(<span class="hljs-string">&quot;client connected&quot;</span>);<br>                <span class="hljs-keyword">try</span> (ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                     ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br>                   <span class="hljs-comment">//3.通过输入流读取客户端发送的请求信息</span><br>                    Message message = (Message) objectInputStream.readObject();<br>                    logger.info(<span class="hljs-string">&quot;server receive message:&quot;</span> + message.getContent());<br>                    message.setContent(<span class="hljs-string">&quot;new content&quot;</span>);<br>                    <span class="hljs-comment">//4.通过输出流向客户端发送响应信息</span><br>                    objectOutputStream.writeObject(message);<br>                    objectOutputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloServer helloServer = <span class="hljs-keyword">new</span> HelloServer();<br>        helloServer.start(<span class="hljs-number">6666</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerSocket</code> 的 <code>accept（）</code> 方法是阻塞方法，也就是说 <code>ServerSocket</code> 在调用 <code>accept（)</code>等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p><p>很明显，我上面演示的代码片段有一个很严重的问题：只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。 如下图所示：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704130352083.png" alt="image-20220704130352083"></p><p>对应的 Java 代码可能是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>   <span class="hljs-comment">// 创建 socket 连接</span><br>&#125;).start();<br></code></pre></td></tr></table></figure><p>但是，这样会导致一个很严重的问题：<strong>资源浪费。</strong></p><p>我们知道线程是很宝贵的资源，如果我们为每一次连接都用一个线程处理的话，就会导致线程越来越多，最后达到了极限之后，就无法再创建线程处理请求了。处理的不好的话，甚至可能直接就宕机掉了。</p><p>很多人就会问了：那有没有改进的方法呢？</p><p>当然有！ 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadFactory threadFactory = Executors.defaultThreadFactory();<br>ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">100</span>), threadFactory);<br>threadPool.execute(() -&gt; &#123;<br>     <span class="hljs-comment">// 创建 socket 连接</span><br> &#125;);<br></code></pre></td></tr></table></figure><p><strong>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的 BIO 模型的事实，因此无法从根本上解决问题。</strong></p><p><strong>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。</strong> 由于使用同步非阻塞的 I/O 模型 <strong>NIO</strong> 来进行网络编程真的太麻烦了。你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择（前面的章节提到过，后面的章节会详细讲解如何使用 Netty 进行网络编程）！</p><h3 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2. 客户端"></a>4.2. 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 16:56:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloClient.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">send</span><span class="hljs-params">(Message message, String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-comment">//1. 创建Socket对象并且指定服务器的地址和端口号</span><br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket(host, port)) &#123;<br>            ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            <span class="hljs-comment">//2.通过输出流向服务器端发送请求信息</span><br>            objectOutputStream.writeObject(message);<br>            <span class="hljs-comment">//3.通过输入流获取服务器响应的信息</span><br>            ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        HelloClient helloClient = <span class="hljs-keyword">new</span> HelloClient();<br>        helloClient.send(<span class="hljs-keyword">new</span> Message(<span class="hljs-string">&quot;content from client&quot;</span>), <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;client receive message:&quot;</span> + message.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发送的消息实体类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 17:02:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String content;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>首先运行服务端，然后再运行客户端，控制台输出如下：</strong></p><p>服务端:</p><p>Bash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[main] INFO github.javaguide.socket.HelloServer - client connected<br>[main] INFO github.javaguide.socket.HelloServer - server receive message:content from client<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">client receive message:<span class="hljs-keyword">new</span> content<br></code></pre></td></tr></table></figure><p>好的！我们的第一个使用 Socket 进行网络编程的案例已经完成了。</p><p>下一篇我们来看看如何使用 Netty 进行网络编程。</p><h1 id="06-Netty从入门到网络通信实战"><a href="#06-Netty从入门到网络通信实战" class="headerlink" title="06 Netty从入门到网络通信实战"></a>06 Netty从入门到网络通信实战</h1><h2 id="Netty-介绍"><a href="#Netty-介绍" class="headerlink" title="Netty 介绍"></a>Netty 介绍</h2><p>简单用 3 点概括一下 Netty 吧！</p><ol><li><strong>Netty 是一个基于 NIO 的 client-server(客户端服务器)框架</strong>，使用它可以快速简单地开发网络应用程序。</li><li>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li><li>支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li></ol><p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p><h2 id="Netty-特点"><a href="#Netty-特点" class="headerlink" title="Netty 特点"></a>Netty 特点</h2><p>根据官网的描述，我们可以总结出下面一些特点：</p><ul><li>统一的 API，支持多种传输类型，阻塞和非阻塞的。</li><li>简单而强大的线程模型。</li><li>自带编解码器解决 TCP 粘包/拆包问题。</li><li>自带各种协议栈。</li><li>真正的无连接数据包套接字支持。</li><li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li><li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。</li><li>社区活跃</li><li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty 比如我们经常接触的 Dubbo、RocketMQ 等等。</li><li>……</li></ul><ol start="3"><li>使用 Netty 能做什么？</li></ol><p>这个应该是老铁们最关心的一个问题了，凭借自己的了解，简单说一下，理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。Netty 主要用来做网络通信 :</p><ol><li>作为 RPC 框架的网络通信工具 ： 我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务指点的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！</li><li>实现一个自己的 HTTP 服务器 ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。</li><li>实现一个即时通讯系统 ： 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。</li><li>消息推送系统 ：市面上有很多消息推送系统都是基于 Netty 来做的。</li><li>……</li></ol><h2 id="哪些开源项目用到了-Netty？"><a href="#哪些开源项目用到了-Netty？" class="headerlink" title="哪些开源项目用到了 Netty？"></a>哪些开源项目用到了 Netty？</h2><p>我们平常经常接触的 Dubbo、RocketMQ、Elasticsearch、gRPC 等等都用到了 Netty。</p><p>可以说大量的开源项目都用到了 Netty，所以掌握 Netty 有助于你更好的使用这些开源项目并且让你有能力对其进行二次开发。</p><p>实际上还有很多很多优秀的项目用到了 Netty,Netty 官方也做了统计，统计结果在这里：</p><p><a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a> 。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704150216533.png" alt="image-20220704150216533"></p><h2 id="Netty-使用-kryo-序列化传输对象实战"><a href="#Netty-使用-kryo-序列化传输对象实战" class="headerlink" title="Netty 使用 kryo 序列化传输对象实战"></a>Netty 使用 kryo 序列化传输对象实战</h2><h3 id="传输实体类"><a href="#传输实体类" class="headerlink" title="传输实体类"></a>传输实体类</h3><p>我们首先定义两个对象，这两个对象是客户端与服务端进行交互的实体类。 客户端将 RpcRequest 类型的对象发送到服务端，服务端进行相应的处理之后将得到结果 RpcResponse 对象返回给客户端。</p><h4 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h4><p><code>RpcRequest.java </code>：客户端请求实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponse</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> String message;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="初始化客户端"><a href="#初始化客户端" class="headerlink" title="初始化客户端"></a>初始化客户端</h4><p><strong>客户端中主要有一个用于向服务端发送消息的<code>sendMessage()</code>方法，通过这个方法你可以将消息也就是<code>RpcRequest</code> 对象发送到服务端，并且你可以同步获取到服务端返回的结果也就是<code>RpcResponse</code> 对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 20:48:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Bootstrap b;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = host;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化相关资源比如 EventLoopGroup, Bootstrap</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        EventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        b = <span class="hljs-keyword">new</span> Bootstrap();<br>        KryoSerializer kryoSerializer = <span class="hljs-keyword">new</span> KryoSerializer();<br>        b.group(eventLoopGroup)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                <span class="hljs-comment">// 连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span><br>                <span class="hljs-comment">//  如果 15 秒之内没有发送数据给服务端的话，就发送一次心跳请求</span><br>                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         自定义序列化编解码器</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-comment">// RpcResponse -&gt; ByteBuf</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse.class));<br>                        <span class="hljs-comment">// ByteBuf -&gt; RpcRequest</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest.class));<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                    &#125;<br>                &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到服务端</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcRequest 消息体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 服务端返回的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RpcResponse <span class="hljs-title">sendMessage</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture f = b.connect(host, port).sync();<br>            logger.info(<span class="hljs-string">&quot;client connect  &#123;&#125;&quot;</span>, host + <span class="hljs-string">&quot;:&quot;</span> + port);<br>            Channel futureChannel = f.channel();<br>            logger.info(<span class="hljs-string">&quot;send message&quot;</span>);<br>            <span class="hljs-keyword">if</span> (futureChannel != <span class="hljs-keyword">null</span>) &#123;<br>                futureChannel.writeAndFlush(rpcRequest).addListener(future -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                        logger.info(<span class="hljs-string">&quot;client send message: [&#123;&#125;]&quot;</span>, rpcRequest.toString());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        logger.error(<span class="hljs-string">&quot;Send failed:&quot;</span>, future.cause());<br>                    &#125;<br>                &#125;);<br>               <span class="hljs-comment">//阻塞等待 ，直到Channel关闭</span><br>                futureChannel.closeFuture().sync();<br>               <span class="hljs-comment">// 将服务端返回的数据也就是RpcResponse对象取出</span><br>                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br>                <span class="hljs-keyword">return</span> futureChannel.attr(key).get();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception when connect server:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sendMessage()</code>方法分析：</p><ol><li>首先初始化了一个 <code>Bootstrap</code></li><li>通过 <code>Bootstrap</code> 对象连接服务端</li><li>通过 <code>Channel</code> 向服务端发送消息<code>RpcRequest</code></li><li>发送成功后，阻塞等待 ，直到<code>Channel</code>关闭</li><li>拿到服务端返回的结果 <code>RpcResponse</code></li></ol><h4 id="自定义-ChannelHandler-处理服务端消息"><a href="#自定义-ChannelHandler-处理服务端消息" class="headerlink" title="自定义 ChannelHandler 处理服务端消息"></a>自定义 ChannelHandler 处理服务端消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RpcResponse rpcResponse = (RpcResponse) msg;<br>            logger.info(<span class="hljs-string">&quot;client receive msg: [&#123;&#125;]&quot;</span>, rpcResponse.toString());<br>            <span class="hljs-comment">// 声明一个 AttributeKey 对象</span><br>            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br>            <span class="hljs-comment">// 将服务端的返回结果保存到 AttributeMap 上，AttributeMap 可以看作是一个Channel的共享数据源</span><br>            <span class="hljs-comment">// AttributeMap的key是AttributeKey，value是Attribute</span><br>            ctx.channel().attr(key).set(rpcResponse);<br>            ctx.channel().close();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        logger.error(<span class="hljs-string">&quot;client caught exception&quot;</span>, cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NettyClientHandler</code>用于读取服务端发送过来的 <code>RpcResponse</code> 消息对象，并将 <code>RpcResponse</code> 消息对象保存到<code> AttributeMap</code> 上，<code>AttributeMap</code> 可以看作是一个<code>Channel</code>的共享数据源。</p><p>这样的话，我们就能通过 channel 和 key 将数据读取出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br><span class="hljs-keyword">return</span> futureChannel.attr(key).get();<br></code></pre></td></tr></table></figure><p>这个额外提一下<code> AttributeMap</code> ,<code>AttributeMap</code> 是一个接口，但是类似于 <code>Map</code> 数据结构 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeMap</span> </span>&#123;<br><br>    &lt;T&gt; <span class="hljs-function">Attribute&lt;T&gt; <span class="hljs-title">attr</span><span class="hljs-params">(AttributeKey&lt;T&gt; key)</span></span>;<br><br>    &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttr</span><span class="hljs-params">(AttributeKey&lt;T&gt; key)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Channel </code>实现了<code> AttributeMap</code> 接口，这样也就表明它存在了<code>AttributeMap</code> 相关的属性。 每个 <code>Channel</code>上的<code>AttributeMap</code>属于共享数据。<code>AttributeMap</code> 的结构，和<code>Map</code>很像，我们可以把 key 看作是<code>AttributeKey</code>，value 看作是<code>Attribute</code>，我们可以根据 <code>AttributeKey</code>找到对应的<code>Attribute</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeMap</span>, <span class="hljs-title">ChannelOutboundInvoker</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="初始化服务端"><a href="#初始化服务端" class="headerlink" title="初始化服务端"></a>初始化服务端</h4><p><code>NettyServer</code> 主要作用就是开启了一个服务端用于接受客户端的请求并处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">NettyServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        KryoSerializer kryoSerializer = <span class="hljs-keyword">new</span> KryoSerializer();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span><br>                    .childOption(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">// 是否开启 TCP 底层心跳机制</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcRequest.class));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcResponse.class));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">// 绑定端口，同步等待绑定成功</span><br>            ChannelFuture f = b.bind(port).sync();<br>            <span class="hljs-comment">// 等待服务端监听端口关闭</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception when start server:&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义-ChannelHandler-处理客户端消息"><a href="#自定义-ChannelHandler-处理客户端消息" class="headerlink" title="自定义 ChannelHandler 处理客户端消息"></a>自定义 ChannelHandler 处理客户端消息</h4><p><code>NettyServerHandler</code> 用于接收客户端发送过来的消息并返回结果给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            RpcRequest rpcRequest = (RpcRequest) msg;<br>            logger.info(<span class="hljs-string">&quot;server receive msg: [&#123;&#125;] ,times:[&#123;&#125;]&quot;</span>, rpcRequest, atomicInteger.getAndIncrement());<br>            RpcResponse messageFromServer = RpcResponse.builder().message(<span class="hljs-string">&quot;message from server&quot;</span>).build();<br>            ChannelFuture f = ctx.writeAndFlush(messageFromServer);<br>            f.addListener(ChannelFutureListener.CLOSE);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        logger.error(<span class="hljs-string">&quot;server catch exception&quot;</span>,cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><h4 id="自定义编码器"><a href="#自定义编码器" class="headerlink" title="自定义编码器"></a>自定义编码器</h4><p><strong><code>NettyKryoEncoder </code>是我们自定义的编码器。它负责处理”出站”消息，将消息格式转换为字节数组然后写入到字节数据的容器<code>ByteBuf</code>对象中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义编码器。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 网络传输需要通过字节流来实现，ByteBuf 可以看作是 Netty 提供的字节数据的容器，使用它会让我们更加方便地处理字节数据。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月25日 19:43:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyKryoEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Serializer serializer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; genericClass;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将对象转换为字节码然后写入到 ByteBuf 对象中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, Object o, ByteBuf byteBuf)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (genericClass.isInstance(o)) &#123;<br>            <span class="hljs-comment">// 1. 将对象转换为byte</span><br>            <span class="hljs-keyword">byte</span>[] body = serializer.serialize(o);<br>            <span class="hljs-comment">// 2. 读取消息的长度</span><br>            <span class="hljs-keyword">int</span> dataLength = body.length;<br>            <span class="hljs-comment">// 3.写入消息对应的字节数组长度,writerIndex 加 4</span><br>            byteBuf.writeInt(dataLength);<br>            <span class="hljs-comment">//4.将字节数组写入 ByteBuf 对象中</span><br>            byteBuf.writeBytes(body);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义解码器"><a href="#自定义解码器" class="headerlink" title="自定义解码器"></a>自定义解码器</h4><p><code>NettyKryoDecoder</code>是我们自定义的解码器。它负责处理”入站”消息，它会从<code>ByteBuf</code>中读取到业务对象对应的字节序列，然后再将字节序列转换为我们的业务对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义解码器。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月25日 19:42:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyKryoDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Serializer serializer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; genericClass;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Netty传输的消息长度也就是对象序列化后对应的字节数组的大小，存储在 ByteBuf 头部</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BODY_LENGTH = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解码 ByteBuf 对象</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 解码器关联的 ChannelHandlerContext 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in  &quot;入站&quot;数据，也就是 ByteBuf 对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 解码之后的数据对象需要添加到 out 对象里面</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;<br><br>        <span class="hljs-comment">//1.byteBuf中写入的消息长度所占的字节数已经是4了，所以 byteBuf 的可读字节必须大于 4，</span><br>        <span class="hljs-keyword">if</span> (in.readableBytes() &gt;= BODY_LENGTH) &#123;<br>            <span class="hljs-comment">//2.标记当前readIndex的位置，以便后面重置readIndex 的时候使用</span><br>            in.markReaderIndex();<br>            <span class="hljs-comment">//3.读取消息的长度</span><br>            <span class="hljs-comment">//注意： 消息长度是encode的时候我们自己写入的，参见 NettyKryoEncoder 的encode方法</span><br>            <span class="hljs-keyword">int</span> dataLength = in.readInt();<br>            <span class="hljs-comment">//4.遇到不合理的情况直接 return</span><br>            <span class="hljs-keyword">if</span> (dataLength &lt; <span class="hljs-number">0</span> || in.readableBytes() &lt; <span class="hljs-number">0</span>) &#123;<br>                log.error(<span class="hljs-string">&quot;data length or byteBuf readableBytes is not valid&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//5.如果可读字节数小于消息长度的话，说明是不完整的消息，重置readIndex</span><br>            <span class="hljs-keyword">if</span> (in.readableBytes() &lt; dataLength) &#123;<br>                in.resetReaderIndex();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 6.走到这里说明没什么问题了，可以序列化了</span><br>            <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[dataLength];<br>            in.readBytes(body);<br>            <span class="hljs-comment">// 将bytes数组转换为我们需要的对象</span><br>            Object obj = serializer.deserialize(body, genericClass);<br>            out.add(obj);<br>            log.info(<span class="hljs-string">&quot;successful decode ByteBuf to Object&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义序列化接口"><a href="#自定义序列化接口" class="headerlink" title="自定义序列化接口"></a>自定义序列化接口</h4><p><code>Serializer</code> 接口主要有两个方法一个用于序列化，一个用户反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 要序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 字节数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">byte</span>[] serialize(Object obj);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 序列化后的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现序列化接口"><a href="#实现序列化接口" class="headerlink" title="实现序列化接口"></a>实现序列化接口</h4><p>下面是我自定义 kryo 序列化实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由于 Kryo 不是线程安全的。每个线程都应该有自己的 Kryo，Input 和 Output 实例。</span><br><span class="hljs-comment">     * 所以，使用 ThreadLocal 存放 Kryo 对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        Kryo kryo = <span class="hljs-keyword">new</span> Kryo();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        kryo.setReferences(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//默认值为true,是否关闭注册行为,关闭之后可能存在序列化问题，一般推荐设置为 true</span><br>        kryo.setRegistrationRequired(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//默认值为false,是否关闭循环引用，可以提高性能，但是一般不推荐设置为 true</span><br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>             Output output = <span class="hljs-keyword">new</span> Output(byteArrayOutputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;序列化失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);<br>             Input input = <span class="hljs-keyword">new</span> Input(byteArrayInputStream)) &#123;<br>            Kryo kryo = kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对对象</span><br>            Object o = kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SerializeException(<span class="hljs-string">&quot;反序列化失败&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义序列化异常类<code> SerializeException</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializeException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>启动服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">new</span> NettyServer(<span class="hljs-number">8889</span>).run();<br></code></pre></td></tr></table></figure><p>启动客户端并发送 4 次消息给服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">RpcRequest rpcRequest = RpcRequest.builder()<br>  .interfaceName(<span class="hljs-string">&quot;interface&quot;</span>)<br>  .methodName(<span class="hljs-string">&quot;hello&quot;</span>).build();<br>NettyClient nettyClient = <span class="hljs-keyword">new</span> NettyClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8889</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  nettyClient.sendMessage(rpcRequest);<br>&#125;<br>RpcResponse rpcResponse = nettyClient.sendMessage(rpcRequest);<br>System.out.println(rpcResponse.toString());<br></code></pre></td></tr></table></figure><p>客户端控制台输出：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704205539793.png" alt="image-20220704205539793"></p><p>服务端控制台输出：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704205554308.png" alt="image-20220704205554308"></p><h1 id="静态代理-JDK-CGLIB-动态代理实战"><a href="#静态代理-JDK-CGLIB-动态代理实战" class="headerlink" title="静态代理+JDK/CGLIB 动态代理实战"></a>静态代理+JDK/CGLIB 动态代理实战</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220704205727047.png" alt="image-20220704205727047"></p><p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>下面通过代码展示！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsProxy</span><span class="hljs-params">(SmsService smsService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.smsService = smsService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method send()&quot;</span>);<br>        smsService.send(message);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method send()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SmsService smsService = <span class="hljs-keyword">new</span> SmsServiceImpl();<br>        SmsProxy smsProxy = <span class="hljs-keyword">new</span> SmsProxy(smsService);<br>        smsProxy.send(<span class="hljs-string">&quot;java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs BASH">before method send()<br>send message:java<br>after method send()<br></code></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理、CGLIB 动态代理</strong>等等。</p><p>guide-rpc-framework 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p><p>另外，虽然 guide-rpc-framework 没有用到 <strong>CGLIB 动态代理 ，我们这里还是简单介绍一下其使用</strong>以及和JDK 动态代理的对比。</p><h3 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-function"><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-function"><span class="hljs-params">                                      InvocationHandler h)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalArgumentException</span><br><span class="hljs-function"></span>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li>loader :类加载器，用于加载代理对象。</li><li>interfaces : 被代理类实现的一些接口；</li><li>h : 实现了 InvocationHandler 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的<code>invoke</code>方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invoke() </code>方法有下面三个参数：</p><ol><li><code>proxy</code> :动态生成的代理类</li><li><code>method </code>: 与代理类对象调用的方法相对应</li><li><code>args </code>: 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。</strong> 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h4 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h4><ol><li>定义一个接口及其实现类；</li><li>自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) </code>方法创建代理对象；</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.定义一个 JDK 动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 11:23:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        Object result = method.invoke(target, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invoke() </code>方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是<code>invoke()</code>方法，然后 <code>invoke() </code>方法代替我们去调用了被代理对象的原生方法。</p><p><strong>4.获取代理对象的工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkProxyFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(), <span class="hljs-comment">// 目标类的类加载</span><br>                target.getClass().getInterfaces(),  <span class="hljs-comment">// 代理需要实现的接口，可指定多个</span><br>                <span class="hljs-keyword">new</span> DebugInvocationHandler(target)   <span class="hljs-comment">// 代理对象对应的自定义 InvocationHandler</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getProxy() </code>：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><p><strong>5.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="hljs-keyword">new</span> SmsServiceImpl());<br>smsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure><h3 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和<code> Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor </code>并重写<code> intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodInterceptor</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span></span>&#123;<br>    <span class="hljs-comment">// 拦截被代理类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="hljs-function"><span class="hljs-params">                               MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>obj :被代理的对象（需要增强的对象）</li><li>method :被拦截的方法（需要增强的方法）</li><li>args :方法入参</li><li>methodProxy :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor </code>中的<code> intercept</code> 方法。</p><h4 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h4><ol><li>定义一个类；</li><li>自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；</li><li>通过 Enhancer 类的 create()创建代理类；</li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliSmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.自定义 MethodInterceptor（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           被代理的对象（需要增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        Object object = methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> DebugMethodInterceptor());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br>aliSmsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure><h2 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h2><ol><li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h2><ol><li>灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li>JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p><p>文中涉及到的所有源码，你可以在这里找到：<a href="https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy">https://github.com/Snailclimb/guide-rpc-framework-learning/tree/master/src/main/java/github/javaguide/proxy</a> 。</p><h1 id="ZooKeeper常用命令-Curator使用详解"><a href="#ZooKeeper常用命令-Curator使用详解" class="headerlink" title="ZooKeeper常用命令+ Curator使用详解"></a>ZooKeeper常用命令+ Curator使用详解</h1><p>guide-rpc-framework 使用了 Zookeeper 来存储服务的相关信息 ，并且使用的是 ZooKeeper Java客户端  Curator 来对 ZooKeeper 进行增删改查等操作。</p><p>所以，本文就简单介绍一下 ZooKeeper常用命令 以及 Curator 的基本使用。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。</p><p>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！</p><h2 id="ZooKeeper-安装和使用"><a href="#ZooKeeper-安装和使用" class="headerlink" title="ZooKeeper 安装和使用"></a>ZooKeeper 安装和使用</h2><h3 id="使用Docker-安装-zookeeper"><a href="#使用Docker-安装-zookeeper" class="headerlink" title="使用Docker 安装 zookeeper"></a>使用Docker 安装 zookeeper</h3><p>a.使用 Docker 下载 ZooKeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull zookeeper:3.5.8<br></code></pre></td></tr></table></figure><p>b.运行 ZooKeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8<br></code></pre></td></tr></table></figure><h3 id="连接-ZooKeeper-服务"><a href="#连接-ZooKeeper-服务" class="headerlink" title="连接 ZooKeeper 服务"></a>连接 ZooKeeper 服务</h3><p>a.进入ZooKeeper容器中</p><p>先使用 <code>docker ps</code> 查看 ZooKeeper 的 ContainerID，然后使用 <code>docker exec -it ContainerID /bin/bash</code> 命令进入容器中。</p><p>b.先进入 bin 目录,然后通过  <code>./zkCli.sh -server 127.0.0.1:2181</code>命令连接ZooKeeper 服务﻿</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin# cd bin<br></code></pre></td></tr></table></figure><p>如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705165251545.png" alt="image-20220705165251545"></p><h3 id="常用命令演示"><a href="#常用命令演示" class="headerlink" title="常用命令演示"></a>常用命令演示</h3><h4 id="查看常用命令-help-命令"><a href="#查看常用命令-help-命令" class="headerlink" title="查看常用命令(help 命令)"></a>查看常用命令(help 命令)</h4><p>通过 <code>help</code> 命令查看 ZooKeeper 常用命令</p><h4 id="创建节点-create-命令"><a href="#创建节点-create-命令" class="headerlink" title="创建节点(create 命令)"></a>创建节点(create 命令)</h4><p>通过 create 命令在根目录创建了 node1 节点，与它关联的字符串是”node1”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”<br></code></pre></td></tr></table></figure><p>通过 create 命令在根目录创建了 node1 节点，与它关联的内容是数字 123</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123<br>Created /node1/node1.1<br></code></pre></td></tr></table></figure><h4 id="更新节点数据内容-set-命令"><a href="#更新节点数据内容-set-命令" class="headerlink" title="更新节点数据内容(set 命令)"></a>更新节点数据内容(set 命令)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 11] set /node1 &quot;set node1&quot;<br></code></pre></td></tr></table></figure><h4 id="获取节点的数据-get-命令"><a href="#获取节点的数据-get-命令" class="headerlink" title="获取节点的数据(get 命令)"></a>获取节点的数据(get 命令)</h4><p>get 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 <code>set </code>命令已经将节点数据内容改为 “set node1”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">set node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x4b<br>mtime = Sun Jan 20 10:41:10 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 9<br>numChildren = 1<br></code></pre></td></tr></table></figure><h4 id="查看某个目录下的子节点-ls-命令"><a href="#查看某个目录下的子节点-ls-命令" class="headerlink" title="查看某个目录下的子节点(ls 命令)"></a>查看某个目录下的子节点(ls 命令)</h4><p>通过 ls 命令查看根目录下的节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 37] ls /<br>[dubbo, ZooKeeper, node1]<br></code></pre></td></tr></table></figure><p>通过 ls 命令查看 node1 目录下的节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /node1<br>[node1.1]<br></code></pre></td></tr></table></figure><p>ZooKeeper 中的 ls 命令和 linux 命令中的 ls 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）</p><h4 id="查看节点状态-stat-命令"><a href="#查看节点状态-stat-命令" class="headerlink" title="查看节点状态(stat 命令)"></a>查看节点状态(stat 命令)</h4><p>通过 <code>stat</code> 命令查看节点状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 10] stat /node1<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure><p>上面显示的一些信息比如 cversion、aclVersion、numChildren 等等，我在上面 “<a href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#_1-%E5%89%8D%E8%A8%80">ZooKeeper 相关概念总结(入门)</a>” 这篇文章中已经介绍到。</p><h4 id="查看节点信息和状态-ls2-命令"><a href="#查看节点信息和状态-ls2-命令" class="headerlink" title="查看节点信息和状态(ls2 命令)"></a>查看节点信息和状态(ls2 命令)</h4><p><code>ls2</code> 命令更像是  <code>ls</code> 命令和 <code>stat </code>命令的结合。 ls2 命令返回的信息包括 2 部分：</p><ol><li>子节点列表</li><li>当前节点的 stat 信息。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1<br>[node1.1]<br>cZxid = 0x47<br>ctime = Sun Jan 20 10:22:59 CST 2019<br>mZxid = 0x47<br>mtime = Sun Jan 20 10:22:59 CST 2019<br>pZxid = 0x4a<br>cversion = 1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 11<br>numChildren = 1<br></code></pre></td></tr></table></figure><h4 id="删除节点-delete-命令"><a href="#删除节点-delete-命令" class="headerlink" title="删除节点(delete 命令)"></a>删除节点(delete 命令)</h4><p>这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1<br></code></pre></td></tr></table></figure><p>在后面我会介绍到 Java 客户端 API 的使用以及开源 ZooKeeper 客户端 ZkClient 和 Curator 的使用。</p><h2 id="ZooKeeper-Java客户端-Curator简单使用"><a href="#ZooKeeper-Java客户端-Curator简单使用" class="headerlink" title="ZooKeeper Java客户端 Curator简单使用"></a>ZooKeeper Java客户端 Curator简单使用</h2><p>Curator 是Netflix公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705165754955.png" alt="image-20220705165754955"></p><p>下面我们就来简单地演示一下 Curator 的使用吧！</p><p>Curator4.0+版本对ZooKeeper 3.5.x支持比较好。开始之前，请先将下面的依赖添加进你的项目。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="连接-ZooKeeper-客户端"><a href="#连接-ZooKeeper-客户端" class="headerlink" title="连接 ZooKeeper 客户端"></a>连接 ZooKeeper 客户端</h3><p>通过 CuratorFrameworkFactory 创建 CuratorFramework 对象，然后再调用  CuratorFramework 对象的 start() 方法即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE_SLEEP_TIME = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_RETRIES = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span><br>RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(BASE_SLEEP_TIME, MAX_RETRIES);<br>CuratorFramework zkClient = CuratorFrameworkFactory.builder()<br>    <span class="hljs-comment">// the server to connect to (can be a server list)</span><br>    .connectString(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>)<br>    .retryPolicy(retryPolicy)<br>    .build();<br>zkClient.start();<br></code></pre></td></tr></table></figure><p>对于一些基本参数的说明：</p><ul><li><code>baseSleepTimeMs</code>：重试之间等待的初始时间</li><li><code>maxRetries</code> ：最大重试次数</li><li><code>connectString </code>：要连接的服务器列表</li><li><code>retryPolicy </code>：重试策略</li></ul><h3 id="数据节点的增删改查"><a href="#数据节点的增删改查" class="headerlink" title="数据节点的增删改查"></a>数据节点的增删改查</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>我们在 <a href="https://javaguide.cn/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html#_1-%E5%89%8D%E8%A8%80">ZooKeeper常见概念解读</a>中介绍到，我们通常是将 znode 分为 4 大类：</p><ul><li>持久（PERSISTENT）节点 ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li><li>临时（EPHEMERAL）节点 ：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点 只能做叶子节点 ，不能创建子节点。</li><li>持久顺序（PERSISTENT_SEQUENTIAL）节点 ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001 、/node1/app0000000002 。</li><li>临时顺序（EPHEMERAL_SEQUENTIAL）节点 ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><p>你在使用的 ZooKeeper 的时候，会发现  <code>CreateMode</code> 类中实际有 7种 znode 类型 ，但是用的最多的还是上面介绍的 4 种。</p><p>a.创建持久化节点</p><p>你可以通过下面两种方式创建持久化的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意:下面的代码会报错，下文说了具体原因</span><br>zkClient.create().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br>zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00002&quot;</span>);<br></code></pre></td></tr></table></figure><p>但是，你运行上面的代码会报错，这是因为的父节点<code>node1</code>还未创建。</p><p>你可以先创建父节点 <code>node1</code> ，然后再执行上面的代码就不会报错了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure><p>更推荐的方式是通过下面这行代码， <code>creatingParentsIfNeeded() </code><strong>可以保证父节点不存在的时候自动创建父节点，这是非常有用的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure><p>b.创建临时节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure><p>c.创建节点并指定数据内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容，获取到的是 byte数组</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.checkExists().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//不为null的话，说明节点创建成功</span><br></code></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>a.删除一个子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<br></code></pre></td></tr></table></figure><p>b.删除一个节点以及其下的所有子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="获取-更新节点数据内容"><a href="#获取-更新节点数据内容" class="headerlink" title="获取/更新节点数据内容"></a>获取/更新节点数据内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>.getBytes());<br>zkClient.getData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>);<span class="hljs-comment">//获取节点的数据内容</span><br>zkClient.setData().forPath(<span class="hljs-string">&quot;/node1/00001&quot;</span>,<span class="hljs-string">&quot;c++&quot;</span>.getBytes());<span class="hljs-comment">//更新节点数据内容</span><br></code></pre></td></tr></table></figure><h4 id="获取某个节点的所有子节点路径"><a href="#获取某个节点的所有子节点路径" class="headerlink" title="获取某个节点的所有子节点路径"></a>获取某个节点的所有子节点路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="hljs-string">&quot;/node1&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p><strong>下面简单演示一下如何给某个节点注册子节点监听器 。</strong>注册了监听器之后，这个节点的子节点发生变化比如增加、减少或者更新的时候，你可以自定义回调操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String path = <span class="hljs-string">&quot;/node1&quot;</span>;<br>PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache(zkClient, path, <span class="hljs-keyword">true</span>);<br>PathChildrenCacheListener pathChildrenCacheListener = (curatorFramework, pathChildrenCacheEvent) -&gt; &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;;<br>pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);<br>pathChildrenCache.start();<br></code></pre></td></tr></table></figure><p>如果你要获取节点事件类型的话，可以通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pathChildrenCacheEvent.getType()<br></code></pre></td></tr></table></figure><p>一共有下面几种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> Type &#123;<br>    CHILD_ADDED,<span class="hljs-comment">//子节点增加</span><br>    CHILD_UPDATED,<span class="hljs-comment">//子节点更新</span><br>    CHILD_REMOVED,<span class="hljs-comment">//子节点被删除</span><br>    CONNECTION_SUSPENDED,<br>    CONNECTION_RECONNECTED,<br>    CONNECTION_LOST,<br>    INITIALIZED;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Type</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="RPC-框架代码分析之网络传输模块"><a href="#RPC-框架代码分析之网络传输模块" class="headerlink" title="RPC 框架代码分析之网络传输模块"></a>RPC 框架代码分析之网络传输模块</h1><blockquote><p>以下提到的 <strong>服务端</strong> 指的是提供服务/方法的一端，<strong>客户端</strong> 指的是调用远程(服务端)服务/方法的一端。</p></blockquote><p>我们之前在“如何自己实现一个 RPC 框架？”这篇文章中介绍到说：<strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务端。</strong> 这就涉及到了网络传输！网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。你也可以使用同步非阻塞的 I/O 模型 NIO ，但是用它来进行网络编程真的太麻烦了。不过没关系，你可以使用基于 NIO 的网络编程框架 Netty ，它将是你最好的选择！</p><p>guide-rpc-framework 使用了一种基于 Socket，一种基于 Netty 的方式（循序渐进）。</p><p>网络传输模块整体结构如下：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705170846123.png" alt="image-20220705170846123"></p><p>一共被分为了 4 个包</p><ol><li>constants : 存放一些网络传输模块共用的常量</li><li>dto : 用于网络传输的类。</li><li>handler : 里面只有一个用于处理 rpc 请求的类RpcRequestHandler（根据 rpc 请求调用目标类的目标方法）。</li><li>transport : 用户网络传输相关类（真正传输网络请求的地方。提供了 Socket 和 Netty 两种网络传输方式）。</li></ol><h2 id="网络传输实体类"><a href="#网络传输实体类" class="headerlink" title="网络传输实体类"></a>网络传输实体类</h2><p>网络传输实体类在 dto 包下，主要有两个类。</p><p><code>RpcRequest.java</code></p><p>rpc 请求实体类。当你要调用远程方法的时候，你需要先传输一个 <code>RpcRequest</code> 给对方，<code>RpcRequest</code> 里面包含了要调用的目标方法和类的名称、参数等数据。</p><p>另外，<code>version </code>字段（服务版本）主要是为后续不兼容升级提供可能。<code>group</code> 字段主要用于处理一个接口有多个类实现的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageType rpcMessageType;<br>    <span class="hljs-keyword">private</span> String version;<br>    <span class="hljs-keyword">private</span> String group;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RpcServiceProperties <span class="hljs-title">toRpcProperties</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> RpcServiceProperties.builder().serviceName(<span class="hljs-keyword">this</span>.getInterfaceName())<br>                .version(<span class="hljs-keyword">this</span>.getVersion())<br>                .group(<span class="hljs-keyword">this</span>.getGroup()).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RpcResponse.java</code></p><p>既然有了 rpc 请求实体类，那肯定就要有 rpc 响应实体类了。</p><p>当服务端通过 <code>RpcRequest</code> 中的相关数据调用到目标服务的目标方法之后，调用结果就通过<code> RpcResponse</code> 返回给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponse</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">715745410605631233L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response code</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response message</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * response body</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> T data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">RpcResponse&lt;T&gt; <span class="hljs-title">success</span><span class="hljs-params">(T data, String requestId)</span> </span>&#123;<br>        RpcResponse&lt;T&gt; response = <span class="hljs-keyword">new</span> RpcResponse&lt;&gt;();<br>        response.setCode(RpcResponseCode.SUCCESS.getCode());<br>        response.setMessage(RpcResponseCode.SUCCESS.getMessage());<br>        response.setRequestId(requestId);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != data) &#123;<br>            response.setData(data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">RpcResponse&lt;T&gt; <span class="hljs-title">fail</span><span class="hljs-params">(RpcResponseCode rpcResponseCode)</span> </span>&#123;<br>        RpcResponse&lt;T&gt; response = <span class="hljs-keyword">new</span> RpcResponse&lt;&gt;();<br>        response.setCode(rpcResponseCode.getCode());<br>        response.setMessage(rpcResponseCode.getMessage());<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><p><strong>由于，这部分我提供了一种基于 Socket，一种基于 Netty 的网络传输方式（循序渐进）。</strong></p><p>因此，我先定义了一个发送 RPC 请求的顶层接口，然后我们分别使用 Socket 和 Netty 两种方式对这个接口进行实现即可！</p><p><code>RpcRequestTransport.java </code>传输请求的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * send RpcRequest。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月29日 13:26:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SPI</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RpcRequestTransport</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * send rpc request to server and get result</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcRequest message body</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> data from server</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Object <span class="hljs-title">sendRpcRequest</span><span class="hljs-params">(RpcRequest rpcRequest)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面，我们先来看一下比较简单点的使用 Socket 进行网络传输的方式。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>这里的客户端实际就是发送 RPC 请求的一端，可以对照我们之间画的 RPC 调用的原理图来理解。</p><p>客户端主要用于发送网络请求到服务端（目标方法所在的服务器）。当我们知道了服务端的地址之后，我们就可以通过 <code>SocketRpcClient</code> 发送 rpc 请求(<code>RpcRequest</code>) 到服务端了(如果我们要找到服务端的地址，涉及到了注册中心相关的知识。下一节会提到。)。</p><p>我们直接实现上面定义的 <code>RpcRequestTransport.java</code> 即可。这样的话，通过 Socket 来传输消息的模块就写好了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于 Socket 传输 RpcRequest</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月10日 18:40:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketRpcClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RpcRequestTransport</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscovery serviceDiscovery;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SocketRpcClient</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(&quot;zk&quot;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">sendRpcRequest</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;<br>        <span class="hljs-comment">// build rpc service name by rpcRequest</span><br>        String rpcServiceName = RpcServiceProperties.builder().serviceName(rpcRequest.getInterfaceName())<br>                .group(rpcRequest.getGroup()).version(rpcRequest.getVersion()).build().toRpcServiceName();<br>        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcServiceName);<br>        <span class="hljs-keyword">try</span> (Socket socket = <span class="hljs-keyword">new</span> Socket()) &#123;<br>            socket.connect(inetSocketAddress);<br>            ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            <span class="hljs-comment">// Send data to the server through the output stream</span><br>            objectOutputStream.writeObject(rpcRequest);<br>            ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            <span class="hljs-comment">// Read RpcResponse from the input stream</span><br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">&quot;调用服务失败:&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的逻辑很简单，就是对 Socket 发送网络请求这个基础知识的运用。</p><p>我这里就不再对上面的代码进行解析了，看不懂的小伙伴自行翻看之前关于 Socket 讲解的章节。</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p><code>SocketRpcServer.java</code></p><p>Socket 服务端。用于等待客户端连接。当客户端成功连接之后，就可以发送 rpc 请求(RpcRequest) 到服务端了。然后，服务端拿到 RpcRequest就会去执行对应的方法。执行完对应的方法之后，就把执行得到的结果放在 RpcResponse 中返回给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月10日 08:01:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketRpcServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService threadPool;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceProvider serviceProvider;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SocketRpcServer</span><span class="hljs-params">()</span> </span>&#123;<br>        threadPool = ThreadPoolFactoryUtils.createCustomThreadPoolIfAbsent(<span class="hljs-string">&quot;socket-server-rpc-pool&quot;</span>);<br>        serviceProvider = SingletonFactory.getInstance(ServiceProviderImpl.class);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(Object service)</span> </span>&#123;<br>        serviceProvider.publishService(service);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(Object service, RpcServiceProperties rpcServiceProperties)</span> </span>&#123;<br>        serviceProvider.publishService(service, rpcServiceProperties);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket()) &#123;<br>            String host = InetAddress.getLocalHost().getHostAddress();<br>            server.bind(<span class="hljs-keyword">new</span> InetSocketAddress(host, PORT));<br>            CustomShutdownHook.getCustomShutdownHook().clearAll();<br>            Socket socket;<br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-keyword">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;client connected [&#123;&#125;]&quot;</span>, socket.getInetAddress());<br>                threadPool.execute(<span class="hljs-keyword">new</span> SocketRpcRequestHandlerRunnable(socket));<br>            &#125;<br>            threadPool.shutdown();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Netty-1"><a href="#Netty-1" class="headerlink" title="Netty"></a>Netty</h3><p>Netty 这部分的原理也差不多，不过实现代码差别很大。</p><h4 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h4><p><code>NettyClient.java</code></p><p>Netty 客户端主要提供了:</p><ul><li><code>doConnect() </code>:用于连接服务端（目标方法所在的服务器）并返回对应的 <code>Channel</code>。当我们知道了服务端的地址之后，我们就可以通过 <code>NettyClient</code> 成功连接服务端了。（有了<code>Channel</code>之后就能发送数据到服务端了）</li><li><code>sendRpcRequest() </code>: 用于传输 rpc 请求(<code>RpcRequest</code>) 到服务端。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyRpcClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RpcRequestTransport</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscovery serviceDiscovery;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnprocessedRequests unprocessedRequests;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelProvider channelProvider;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup eventLoopGroup;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">doConnect</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        CompletableFuture&lt;Channel&gt; completableFuture = <span class="hljs-keyword">new</span> CompletableFuture&lt;&gt;();<br>        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                log.info(<span class="hljs-string">&quot;The client has connected [&#123;&#125;] successful!&quot;</span>, inetSocketAddress.toString());<br>                completableFuture.complete(future.channel());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> completableFuture.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">sendRpcRequest</span><span class="hljs-params">(RpcRequest rpcRequest)</span> </span>&#123;<br>        <span class="hljs-comment">// build return value</span><br>        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="hljs-keyword">new</span> CompletableFuture&lt;&gt;();<br>        <span class="hljs-comment">// build rpc service name by rpcRequest</span><br>        String rpcServiceName = rpcRequest.toRpcProperties().toRpcServiceName();<br>        <span class="hljs-comment">// get server address</span><br>        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcServiceName);<br>        <span class="hljs-comment">// get  server address related channel</span><br>        Channel channel = getChannel(inetSocketAddress);<br>        <span class="hljs-keyword">if</span> (channel.isActive()) &#123;<br>            <span class="hljs-comment">// put unprocessed request</span><br>            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);<br>            RpcMessage rpcMessage = <span class="hljs-keyword">new</span> RpcMessage();<br>            rpcMessage.setData(rpcRequest);<br>            rpcMessage.setCodec(SerializationTypeEnum.PROTOSTUFF.getCode());<br>            rpcMessage.setCompress(CompressTypeEnum.GZIP.getCode());<br>            rpcMessage.setMessageType(RpcConstants.REQUEST_TYPE);<br>            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.info(<span class="hljs-string">&quot;client send message: [&#123;&#125;]&quot;</span>, rpcMessage);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    future.channel().close();<br>                    resultFuture.completeExceptionally(future.cause());<br>                    log.error(<span class="hljs-string">&quot;Send failed:&quot;</span>, future.cause());<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> resultFuture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UnprocessedRequests.java</code></p><p>用于存放未被服务端处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnprocessedRequests</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;&gt; UNPROCESSED_RESPONSE_FUTURES = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String requestId, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future)</span> </span>&#123;<br>        UNPROCESSED_RESPONSE_FUTURES.put(requestId, future);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(RpcResponse&lt;Object&gt; rpcResponse)</span> </span>&#123;<br>        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future = UNPROCESSED_RESPONSE_FUTURES.remove(rpcResponse.getRequestId());<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != future) &#123;<br>            future.complete(rpcResponse);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NettyClientHandler</code></p><p>自定义客户端<code> ChannelHandler</code> 用于处理服务器发送的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnprocessedRequests unprocessedRequests;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelProvider channelProvider;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyClientHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);<br>        <span class="hljs-keyword">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取从服务端返回的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;client receive msg: [&#123;&#125;]&quot;</span>, msg);<br>            <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> RpcResponse) &#123;<br>                RpcResponse&lt;Object&gt; rpcResponse = (RpcResponse&lt;Object&gt;) msg;<br>                unprocessedRequests.complete(rpcResponse);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Netty 心跳机制相关。保证客户端和服务端的连接不被断掉，避免重连。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//省略部分代码</span><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中，可以看出当 rpc 请求被成功处理（客户端收到服务端的执行结果）之后，我们调用了 <code>unprocessedRequests.complete(rpcResponse)</code> 方法，这样的话，你只需要通过下面的方式就能成功接收到服务端返回的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);<br>rpcResponse = completableFuture.get();<br></code></pre></td></tr></table></figure><p><code>ChannelProvider.java</code></p><p>用于存放<code> Channel</code>（<code>Channel</code>用于在服务端和客户端之间传输数据）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelProvider</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Channel&gt; channelMap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChannelProvider</span><span class="hljs-params">()</span> </span>&#123;<br>        channelMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Channel <span class="hljs-title">get</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        String key = inetSocketAddress.toString();<br>        <span class="hljs-comment">// determine if there is a connection for the corresponding address</span><br>        <span class="hljs-keyword">if</span> (channelMap.containsKey(key)) &#123;<br>            Channel channel = channelMap.get(key);<br>            <span class="hljs-comment">// if so, determine if the connection is available, and if so, get it directly</span><br>            <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span> &amp;&amp; channel.isActive()) &#123;<br>                <span class="hljs-keyword">return</span> channel;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channelMap.remove(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(InetSocketAddress inetSocketAddress, Channel channel)</span> </span>&#123;<br>        String key = inetSocketAddress.toString();<br>        channelMap.put(key, channel);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        String key = inetSocketAddress.toString();<br>        channelMap.remove(key);<br>        log.info(<span class="hljs-string">&quot;Channel map size :[&#123;&#125;]&quot;</span>, channelMap.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务端相关"><a href="#服务端相关" class="headerlink" title="服务端相关"></a>服务端相关</h4><p><code>NettyRpcServer.java</code></p><p>Netty 服务端。并监听客户端的连接。另外，还提供了两个用户手动注册服务的方法（<em>还可以通过注解<code>RpcService</code>注册服务，这个后面也会介绍到</em>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyRpcServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9998</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceProvider serviceProvider = SingletonFactory.getInstance(ServiceProviderImpl.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(Object service, RpcServiceProperties rpcServiceProperties)</span> </span>&#123;<br>        serviceProvider.publishService(service, rpcServiceProperties);<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        CustomShutdownHook.getCustomShutdownHook().clearAll();<br>        String host = InetAddress.getLocalHost().getHostAddress();<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        DefaultEventExecutorGroup serviceHandlerGroup = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<br>                RuntimeUtil.cpus() * <span class="hljs-number">2</span>,<br>                ThreadPoolFactoryUtils.createThreadFactory(<span class="hljs-string">&quot;service-handler-group&quot;</span>, <span class="hljs-keyword">false</span>)<br>        );<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            b.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span><br>                    .childOption(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">// 是否开启 TCP 底层心跳机制</span><br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    <span class="hljs-comment">// 当客户端第一次进行请求的时候才会进行初始化</span><br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            <span class="hljs-comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span><br>                            ChannelPipeline p = ch.pipeline();<br>                            p.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS));<br>                            p.addLast(<span class="hljs-keyword">new</span> RpcMessageEncoder());<br>                            p.addLast(<span class="hljs-keyword">new</span> RpcMessageDecoder());<br>                            p.addLast(serviceHandlerGroup, <span class="hljs-keyword">new</span> NettyRpcServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-comment">// 绑定端口，同步等待绑定成功</span><br>            ChannelFuture f = b.bind(host, PORT).sync();<br>            <span class="hljs-comment">// 等待服务端监听端口关闭</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;occur exception when start server:&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.error(<span class="hljs-string">&quot;shutdown bossGroup and workerGroup&quot;</span>);<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>            serviceHandlerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>NettyServerHandler.java</code></p><p>自定义服务端 <code>ChannelHandler</code> 用于处理客户端发送的数据。</p><p>当客户端发的 rpc 请求(<code>RpcRequest</code>) 来了之后，服务端就会处理 <code>rpc</code> 请求(<code>RpcRequest</code>) ，处理完之后就把得到 rpc 相应(<code>RpcResponse</code>)传输给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RpcRequestHandler rpcRequestHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyServerHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);<br>    &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取从客户端消息，然后调用目标服务的目标方法并返回给客户端。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>      <span class="hljs-comment">// 省略部分代码</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// Netty 心跳机制相关。保证客户端和服务端的连接不被断掉，避免重连。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>     <span class="hljs-comment">// 省略部分代码</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>在《如何自己实现一个 RPC 框架》这一节，我们就提到了传输协议的作用。</p><p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二级制数据之后，就可以正确的解析出我们需要的数据。这有一点像密文传输的感觉。</strong></p><p>以下便是我们设计的传输协议（编解码器这里会用到！！！）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">*   <span class="hljs-number">0</span>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>        <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span>     <span class="hljs-number">8</span>         <span class="hljs-number">9</span>          <span class="hljs-number">10</span>      <span class="hljs-number">11</span>     <span class="hljs-number">12</span>  <span class="hljs-number">13</span>  <span class="hljs-number">14</span>   <span class="hljs-number">15</span> <span class="hljs-number">16</span><br>*   +-----+-----+-----+-----+--------+----+----+----+------+-----------+-------+----- --+-----+-----+-------+<br>*   |   magic   code        |version | full length         | messageType| codec|compress|    RequestId       |<br>*   +-----------------------+--------+---------------------+-----------+-----------+-----------+------------+<br>*   |                                                                                                       |<br>*   |                                         body                                                          |<br>*   |                                                                                                       |<br>*   |                                        ... ...                                                        |<br>*   +-------------------------------------------------------------------------------------------------------+<br>* <span class="hljs-number">4</span>B  magic code（魔法数）   <span class="hljs-number">1</span>B version（版本）   <span class="hljs-number">4</span>B full length（消息长度）    <span class="hljs-number">1</span>B messageType（消息类型）<br>* <span class="hljs-number">1</span>B compress（压缩类型） <span class="hljs-number">1</span>B codec（序列化类型）    <span class="hljs-number">4</span>B  requestId（请求的Id）<br></code></pre></td></tr></table></figure><ul><li>魔法数 ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。</li><li>序列化器类型 ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。</li><li>消息长度 ： 运行时计算出来。</li><li>……</li></ul><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>编解码器这里主要用到了 Kryo 序列化和反序列化以及 Netty 网络传输字节容器 ByteBuf 相关的知识。</p><p>编解码器的作用主要是让我们在 Netty 进行网络传输所用的对象类型 ByteBuf 与 我们代码层面需要的业务对象之间转换。这部分的代码还是比较多的，小伙伴们可以自己阅读以下，整体逻辑还是比较简单的。</p><p><strong>一定要先搞懂传输协议之后再去看这部分代码。</strong></p><p><code>RpcMessageDecoder.java</code></p><p>自定义解码器。负责处理”入站”消息，将 ByteBuf 消息格式的对象转换为我们需要的业务对象。</p><blockquote><p>网络传输需要通过字节流来实现，ByteBuf 可以看作是 Netty 提供的字节数据的容器，使用它会让我们更加方便地处理字节数据。</p></blockquote><p><code>RpcMessageEncoder.java</code></p><p>自定义编码器。负责处理”出站”消息，将消息格式转换字节数组然后写入到字节数据的容器 ByteBuf 对象中。</p><h1 id="RPC-框架代码分析之注册中心模块"><a href="#RPC-框架代码分析之注册中心模块" class="headerlink" title="RPC 框架代码分析之注册中心模块"></a>RPC 框架代码分析之注册中心模块</h1><p>我们之前在“如何自己实现一个 RPC 框架？”这篇文章中介绍到说：<strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p><p>简单来说注册中心就像是一个中转站，提供的作用就是根据调用的服务名称找到远程服务的地址（数据保存服务）。</p><p>注册中心模块整体结构如下：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705172541611.png" alt="image-20220705172541611"></p><p>我们定义了两个接口<code> ServiceDiscovery.java</code> 和 <code>ServiceRegistry.java</code>，这两个接口分别定义了服务发现和服务注册行为。</p><p><code>ServiceRegistry.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务注册</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 08:39:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceRegistry</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册服务到注册中心</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcServiceName    完整的服务名称（class name+group+version）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inetSocketAddress 远程服务地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(String rpcServiceName, InetSocketAddress inetSocketAddress)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServiceDiscovery.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务发现</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年06月01日 15:16:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceDiscovery</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据 rpcServiceName 获取远程服务地址</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rpcServiceName 完整的服务名称（class name+group+version）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 远程服务地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">InetSocketAddress <span class="hljs-title">lookupService</span><span class="hljs-params">(String rpcServiceName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们使用 ZooKeeper 作为注册中心的实现方式，并实现了这两个接口。</p><p><code>ZkServiceRegistry.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务注册（基于zookeeper实现）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkServiceRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceRegistry</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(String rpcServiceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;<br>        String servicePath = CuratorUtils.ZK_REGISTER_ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + rpcServiceName + inetSocketAddress.toString();<br>        CuratorFramework zkClient = CuratorUtils.getZkClient();<br>        CuratorUtils.createPersistentNode(zkClient, servicePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们的服务被注册进 zookeeper 的时候，我们将完整的服务名称 rpcServiceName （class name+group+version）作为根节点 ，子节点是对应的服务地址（ip+端口号）。</p><blockquote><ul><li>class name : 服务接口名也就是类名比如：github.javaguide.HelloService。</li><li>version :（服务版本）主要是为后续不兼容升级提供可能</li><li>group :主要用于处理一个接口有多个类实现的情况。</li></ul></blockquote><p>一个根节点（rpcServiceName）可能会对应多个服务地址（相同服务被部署多份的情况）。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220713161511054.png" alt="image-20220713161511054"></p><p>如果我们要获得某个服务对应的地址的话，就直接根据完整的服务名称来获取到其下的所有子节点，然后通过具体的负载均衡策略取出一个就可以了。相关代码如下在 <code>ZkServiceDiscovery.java</code>中已经给出。</p><p><code>ZkServiceDiscovery.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务发现（基于zookeeper实现）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkServiceDiscovery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceDiscovery</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoadBalance loadBalance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkServiceDiscovery</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadBalance = <span class="hljs-keyword">new</span> RandomLoadBalance();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> InetSocketAddress <span class="hljs-title">lookupService</span><span class="hljs-params">(String rpcServiceName)</span> </span>&#123;<br>        CuratorFramework zkClient = CuratorUtils.getZkClient();<br>        List&lt;String&gt; serviceUrlList = CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);<br>        <span class="hljs-keyword">if</span> (serviceUrlList.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(RpcErrorMessage.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);<br>        &#125;<br>        <span class="hljs-comment">// load balancing</span><br>        String targetServiceUrl = loadBalance.selectServiceAddress(serviceUrlList);<br>        log.info(<span class="hljs-string">&quot;Successfully found the service address:[&#123;&#125;]&quot;</span>, targetServiceUrl);<br>        String[] socketAddressArray = targetServiceUrl.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        String host = socketAddressArray[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> port = Integer.parseInt(socketAddressArray[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InetSocketAddress(host, port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们根据完整的服务名称便可以将对应的服务地址查出来， 查出来的服务地址可能并不止一个。</p><p>所以，我们可以通过对应的负载均衡策略来选择出一个服务地址。</p><p><code>CuratorUtils.java</code></p><p>另外，我们还自定义了一个 ZooKeeper Java 客户端 Curtor 的工具类 CuratorUtils.java 。关于这个工具类，这里就不再提了。</p><p>在《08 Zookeeper 常用命令+ Curtor 使用详解》中已经介绍的非常详细了。</p><h1 id="RPC-框架代码分析之其他模块"><a href="#RPC-框架代码分析之其他模块" class="headerlink" title="RPC 框架代码分析之其他模块"></a>RPC 框架代码分析之其他模块</h1><h2 id="动态代理屏蔽网络传输细节"><a href="#动态代理屏蔽网络传输细节" class="headerlink" title="动态代理屏蔽网络传输细节"></a>动态代理屏蔽网络传输细节</h2><p>我们在前面的章节讲到过我们需要用到动态代理来屏蔽复杂的网络传输细节。对应的代码:<code> RpcClientProxy.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcClientProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们去调用一个远程的方法的时候，实际上是通过代理对象调用的。</p><p>获取代理对象的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>网络传输细节都被封装在了  <code>invoke()  </code>方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> </span>&#123;<br>    log.info(<span class="hljs-string">&quot;invoked method: [&#123;&#125;]&quot;</span>, method.getName());<br>    RpcRequest rpcRequest = RpcRequest.builder().methodName(method.getName())<br>            .parameters(args)<br>            .interfaceName(method.getDeclaringClass().getName())<br>            .paramTypes(method.getParameterTypes())<br>            .requestId(UUID.randomUUID().toString())<br>            .group(rpcServiceProperties.getGroup())<br>            .version(rpcServiceProperties.getVersion())<br>            .build();<br>    RpcResponse&lt;Object&gt; rpcResponse = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (rpcRequestTransport <span class="hljs-keyword">instanceof</span> NettyRpcClient) &#123;<br>        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);<br>        rpcResponse = completableFuture.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rpcRequestTransport <span class="hljs-keyword">instanceof</span> SocketRpcClient) &#123;<br>        rpcResponse = (RpcResponse&lt;Object&gt;) rpcRequestTransport.sendRpcRequest(rpcRequest);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.check(rpcResponse, rpcRequest);<br>    <span class="hljs-keyword">return</span> rpcResponse.getData();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过注解注册/消费服务</p><p>我们这里借用了 Spring 容器相关的功能。核心代码都放在了 ： <code>src/main/java/github/javaguide/spring</code>  包下面。</p><p>我们定义两个注解： </p><ul><li>RcpService  ：注册服务</li><li>RpcReference  ：消费服务</li></ul><p><code>RcpService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RpcService &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service version, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">version</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service group, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">group</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>RpcReference.java </code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RpcReference &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service version, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">version</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Service group, default value is empty string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">group</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>﻿</p><p>简单说一下原理。</p><p>我们实现需要 <code>BeanPostProcessor</code> 接口并重写 <code>postProcessBeforeInitialization()</code>方法和 <code>postProcessAfterInitialization() </code>方法。</p><p>Spring bean 在实例化之前会调用<code> postProcessBeforeInitialization()</code>方法，在 Spring bean 实例化之后会调用 <code>postProcessAfterInitialization()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>被我们使用 <code>RpcService</code>和<code>RpcReference</code> 注解的类都算是 Spring Bean。 </p><ul><li>我们可以在<code>postProcessBeforeInitialization()</code>方法中去判断类上是否有<code>RpcService</code> 注解。如果有的话，就取出 <code>group </code>和<code> version</code> 的值。然后，再调用<code> ServiceProvider</code> 的 <code>publishService() </code>方法发布服务即可！</li><li>我们可以在<code>postProcessAfterInitialization()</code>方法中遍历类的属性上是否有 <code>RpcReference</code> 注解。如果有的话，我们就通过反射将这个属性赋值即可！</li></ul><h1 id="（优化）使用CompletableFuture优化接受服务提供端返回结果"><a href="#（优化）使用CompletableFuture优化接受服务提供端返回结果" class="headerlink" title="（优化）使用CompletableFuture优化接受服务提供端返回结果"></a>（优化）使用CompletableFuture优化接受服务提供端返回结果</h1><h2 id="使用-AttributeMap-接受服务端返回结果"><a href="#使用-AttributeMap-接受服务端返回结果" class="headerlink" title="使用 AttributeMap 接受服务端返回结果"></a>使用 AttributeMap 接受服务端返回结果</h2><p>最开始的时候是通过 <code>AttributeMap</code> 绑定到Channel上实现的，相关代码如下：</p><p><code>NettyClientTransport.java</code>（用来发送 RpcRequest 请求）</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174156055.png" alt="image-20220705174156055"></p><p><code>NettyClientHandler.java</code> （自定义客户端 ChannelHandler 来处理服务端发过来的数据）</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174227753.png" alt="image-20220705174227753"></p><p>这种是实现的缺点是不清晰，而且你每次都要调用<code>channel.closeFuture().sync();</code> 阻塞来手动等待请求返回。</p><h2 id="使用-CompletableFuture-进行优化"><a href="#使用-CompletableFuture-进行优化" class="headerlink" title="使用 CompletableFuture 进行优化"></a>使用 CompletableFuture 进行优化</h2><p>我使用 <code>CompletableFuture</code> 包装返回结果，对代码进行了重构，重要部分的代码如下：</p><p><code>NettyClientTransport.java</code>（用来发送 RpcRequest 请求）</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174215554.png" alt="image-20220705174215554"></p><p><code>NettyClientHandler.java</code> （自定义客户端 ChannelHandler 来处理服务端发过来的数据）</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174522589.png" alt="image-20220705174522589"></p><p><code>UnprocessedRequests.java </code>存放了未处理的请求（建议限制 map 容器大小，避免未处理请求过多 OOM</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220705174536550.png" alt="image-20220705174536550"></p><p>现在，在你只需要通过下面的方式就能成功接收到客户端返回的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) clientTransport.sendRpcRequest(rpcRequest);<br>rpcResponse = completableFuture.get();<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-什么是-RPC？原理是什么？&quot;&gt;&lt;a href=&quot;#01-什么是-RPC？原理是什么？&quot; class=&quot;headerlink&quot; title=&quot;01 什么是 RPC？原理是什么？&quot;&gt;&lt;/a&gt;01 什么是 RPC？原理是什么？&lt;/h1&gt;&lt;h2 id=&quot;1-什么是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>springcloud</title>
    <link href="http://example.com/2022/07/07/springcloud/"/>
    <id>http://example.com/2022/07/07/springcloud/</id>
    <published>2022-07-06T17:52:47.765Z</published>
    <updated>2022-07-06T17:55:07.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185642516.png" alt="image-20220428185642516"></p><p><strong>优点：</strong>架构简单，部署成本低</p><p><strong>缺点：</strong>耦合度高（维护困难、升级困难）</p><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185707634.png" alt="image-20220428185707634"></p><p><strong>优点：</strong>降低服务耦合，有利于服务升级和拓展</p><p><strong>缺点：</strong>服务调用关系错综复杂</p><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有<strong>很多问题需要思考</strong>：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p><strong>人们需要制定一套行之有效的标准来约束分布式架构。</strong></p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185738700.png" alt="image-20220428185738700"></p><p>微服务的上述特性<strong>其实是在给分布式架构制定一个标准</strong>，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p><strong>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</strong></p><p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185807546.png" alt="image-20220428185807546"></p><p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185819931.png" alt="image-20220428185819931"></p><h2 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h2><p>需要学习的微服务知识内容</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185933999.png" alt="image-20220428185933999"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185914756.png" alt="image-20220428185914756"></p><h2 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428190002468.png" alt="image-20220428190002468"></p><h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><p><strong>服务拆分注意事项</strong></p><p>单一职责：不同微服务，不要重复开发相同业务</p><p>数据独立：不要访问其它微服务的数据库</p><p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090745.png"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090745.png" alt="img"></a></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li><li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li><li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li></ul><p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090750.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090750.png" alt="img"></a></p><p>启动完成后，访问 <a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>正如上面的服务拆分要求中所提到，</p><blockquote><p>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</p></blockquote><p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090814.png" alt="img"></p><p>发送请求，自动序列化为 Java 对象。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090846.png" alt="img"></p><p>启动完成后，访问：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090909.png" alt="img"></p><p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p><h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>最广为人知的注册中心就是 Eureka，其结构如下：</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090919.png"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090919.png" alt="img"></a></p><p><strong>order-service 如何得知 user-service 实例地址？</strong></p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li></ul><p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p><ul><li>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</li></ul><p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p><ul><li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，，可以拉取到最新的信息，将故障实例排除了</li></ul><h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p><strong>搭建 eureka-server</strong></p><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编写启动类</strong></p><p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xn2001.eureka;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写配置文件</strong></p><p>编写一个 application.yml 文件，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p><p>启动完成后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote><p>将 user-service、order-service 都注册到 eureka</p></blockquote><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>client</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在启动类上添加注解：<code>@EnableEurekaClient</code></p><p>在 application.yml 文件，添加下面的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>      <span class="hljs-comment">#name：orderservice</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http:127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><p>3个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p>[<img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090958.png" alt="img"></p><p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901091005.png" alt="img"></p><p>4个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h2><blockquote><p>在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</p></blockquote><p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901091216.png" alt="img"></p><p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。</p><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p><p><strong>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204718544.png" alt="image-20220502204718544"></p><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204740323.png" alt="image-20220502204740323"></p><p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，即 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id <code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li></ul><p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p><p>继续跟入 <code>execute()</code> 方法：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204800776.png" alt="image-20220502204800776">ps://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901091330.png)</p><ul><li><code>getLoadBalancer(serviceId)</code>：根据服务id获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务 id 去 eureka 中获取服务列表。</li><li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li></ul><p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204807870.png" alt="image-20220502204807870">210901091345.png)</p><p>我们继续跟入：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204829178.png" alt="image-20220502204829178"></p><p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204841773.png" alt="image-20220502204841773"></p><p>我们看看这个 <code>rule</code> 是谁：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204854794.png" alt="image-20220502204854794"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204904472.png" alt="image-20220502204904472"></p><p>负载均衡默认使用了轮训算法，当然我们也可以自定义。</p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p><p>基本流程如下：</p><ul><li>拦截我们的 <code>RestTemplate</code> 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205148614.png" alt="image-20220502205148614"></p><p>不同规则的含义如下：</p><table><thead><tr><th align="left"><strong>内置负载均衡规则类</strong></th><th align="left"><strong>规则描述</strong></th></tr></thead><tbody><tr><td align="left">RoundRobinRule</td><td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td align="left">AvailabilityFilteringRule</td><td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td></tr><tr><td align="left">WeightedResponseTimeRule</td><td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td align="left"><strong>ZoneAvoidanceRule</strong></td><td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td align="left">BestAvailableRule</td><td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td align="left">RandomRule</td><td align="left">随机选择一个可用的服务器。</td></tr><tr><td align="left">RetryRule</td><td align="left">重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p><h2 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205114259.png" alt="image-20220502205114259"></p><p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一般用默认的负载均衡规则，不做修改。</p><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205135263.png" alt="image-20220502205135263"></p><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 项目启动时直接去拉取userservice的集群，多个用&quot;,&quot;隔开</span><br></code></pre></td></tr></table></figure><h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，在国外也有大量的使用。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205234666.png" alt="image-20220502205234666"></p><p>解压启动 Nacos，详细请看 <a href="https://www.xn2001.com/archives/661.html">Nacos安装指南</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">startup</span><span class="hljs-selector-class">.cmd</span> <span class="hljs-selector-tag">-m</span> <span class="hljs-selector-tag">standalone</span><br></code></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p><h2 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。</p><p><strong>引入依赖</strong></p><p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置nacos地址</strong></p><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址： </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure><p><strong>还需要配置服务名称</strong></p><p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214602344.png" alt="image-20220502214602344"></p><p>浏览器访问：<a href="http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p><h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214517868.png" alt="image-20220502214517868"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>接下来我们给 user-service <strong>配置集群</strong></p><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称 HZ杭州</span><br></code></pre></td></tr></table></figure><p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<br></code></pre></td></tr></table></figure><p>查看 nacos 控制台：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214544922.png" alt="image-20220502214544922"></p><h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">iRule</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//默认为轮询规则，这里自定义为随机规则</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRule();<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment">#负载均衡规则 </span><br></code></pre></td></tr></table></figure><p>然后，再对 orderservice 配置集群。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure><p>现在我启动了四个服务，分别是：</p><ul><li>orderservice - HZ</li><li>userservice - HZ</li><li>userservice1 - HZ</li><li>userservice2 - SH</li></ul><p>访问地址：<a href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p><p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p><p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p><p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214629993.png" alt="image-20220502214629993"></p><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p><p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214643631.png" alt="image-20220502214643631"></p><p>在弹出的编辑窗口，修改权重</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214655845.png" alt="image-20220502214655845"></p><p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到 0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>Nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214708111.png" alt="image-20220502214708111"></p><h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214721702.png" alt="image-20220502214721702"></p><p>我们可以点击页面新增按钮，添加一个 namespace：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214733491.png" alt="image-20220502214733491"></p><p>然后，填写表单：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214750406.png" alt="image-20220502214750406"></p><p>就能在页面看到一个新的 namespace：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214801507.png" alt="image-20220502214801507"></p><h3 id="配置namespace"><a href="#配置namespace" class="headerlink" title="配置namespace"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间ID</span><br></code></pre></td></tr></table></figure><p>重启 order-service 后，访问控制台。</p><p><strong>public</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214821277.png" alt="image-20220502214821277"></p><p><strong>dev</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214833255.png" alt="image-20220502214833255"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214845028.png" alt="image-20220502214845028"></p><h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p><ul><li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li><li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure><p>另外，Nacos 集群<strong>默认采用AP方式(可用性)**，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p><h1 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200723770.png" alt="image-20220503200723770"></p><p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p><h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200736172.png" alt="image-20220503200736172"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200754869.png" alt="image-20220503200754869"></p><p><strong>注意：</strong>项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。这里的后缀名最好写<code>.yaml</code>。</p><h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200813407.png" alt="image-20220503200813407"></p><p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200824188.png" alt="image-20220503200824188"></p><p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p><p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200923259.png" alt="image-20220503200923259"></p><p><strong>引入 nacos-config 依赖</strong></p><p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>添加 bootstrap.yml</strong></p><p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201041580.png" alt="image-20220503201041580"></p><p>使用代码来验证是否拉取成功</p><p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String dateformat;<br><br><span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">now</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//格式化时间</span><br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200944583.png" alt="image-20220503200944583"></p><p>启动服务后，访问：<a href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201114911.png" alt="image-20220503201114911"></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p><h3 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201128313.png" alt="image-20220503201128313"></p><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。</p><p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatternProperties</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String dateformat;<br>&#125;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br><span class="hljs-meta">@GetMapping(&quot;now2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">now2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//格式化时间</span><br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li><li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li></ul><p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p><p><strong>添加一个环境共享配置</strong></p><p>我们在 nacos 中添加一个 userservice.yaml 文件：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201156476.png" alt="image-20220503201156476"></p><p><strong>在 user-service 中读取共享配置</strong></p><p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092314.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092314.png" alt="img"></a></p><p>在 user-service 服务中，修改 UserController，添加一个方法：</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092331.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092331.png" alt="img"></a></p><p><strong>运行两个 UserApplication，使用不同的profile</strong></p><p>修改 UserApplication2 这个启动项，改变其profile值：</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092345.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092345.png" alt="img"></a></p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092338.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092338.png" alt="img"></a></p><p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p><p>启动 UserApplication 和 UserApplication2</p><p>访问地址：<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092400.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092400.png" alt="img"></a></p><p>访问地址：<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092419.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092419.png" alt="img"></a></p><p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p><p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p><p>通过下面的两种方式来指定：</p><ul><li>extension-configs</li><li>shared-configs</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">extends-configs:</span> <span class="hljs-comment"># 多微服务间共享的配置列表</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">common.yaml</span> <span class="hljs-comment"># 要共享的配置文件id</span><br><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 多微服务间共享的配置列表</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">common.yaml</span> <span class="hljs-comment"># 要共享的配置文件id</span><br></code></pre></td></tr></table></figure><h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092501.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092501.png" alt="img"></a></p><p>更细致的配置</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092520.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092520.png" alt="img"></a></p><h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092616.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092616.png" alt="img"></a></p><ul><li>代码可读性差，编程体验不统一</li><li>参数复杂URL难以维护</li></ul><p>Feign 是一个声明式的 http 客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092639.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092639.png" alt="img"></a></p><h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p><p>我们在 order-service 引入 feign 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>添加注解</strong></p><p>在 order-service 启动类添加注解开启 Feign</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092704.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092704.png" alt="img"></a></p><p><strong>请求接口</strong></p><p>在 order-service 中新建一个接口，内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.client;<br><br><span class="hljs-keyword">import</span> cn.itcast.order.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p><p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p><p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p><p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserClient userClient;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">queryOrderAndUserById</span><span class="hljs-params">(Long orderId)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.查询订单</span><br>    Order order = orderMapper.findById(orderId);<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 2021/8/20 使用feign远程调用</span><br>    User user = userClient.findById(order.getUserId());<br>    <span class="hljs-comment">// 3. 将用户信息封装进订单</span><br>    order.setUser(user);<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th align="left">类型</th><th align="left">作用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>feign.Logger.Level</strong></td><td align="left">修改日志级别</td><td align="left">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td align="left">feign.codec.Decoder</td><td align="left">响应结果的解析器</td><td align="left">http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td align="left">feign.codec.Encoder</td><td align="left">请求参数编码</td><td align="left">将请求参数编码，便于通过http请求发送</td></tr><tr><td align="left">feign.Contract</td><td align="left">支持的注解格式</td><td align="left">默认是SpringMVC的注解</td></tr><tr><td align="left">feign.Retryer</td><td align="left">失败重试机制</td><td align="left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p><p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p><strong>也可以针对所有服务：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li></ul><p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFeignConfiguration</span>  </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.<span class="hljs-function">Level <span class="hljs-title">feignLogLevel</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p><ul><li><strong>URLConnection</strong>：默认实现，不支持连接池</li><li><strong>Apache HttpClient</strong> ：支持连接池</li><li><strong>OKHttp</strong>：支持连接池</li></ul><p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p><p>另外，日志级别应该尽量用 basic/none，可以有效提高性能。</p><p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p><p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置连接池</strong></p><p>在 order-service 的 application.yml 中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure><p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092729.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092729.png" alt="img"></a></p><p>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 HttpClient</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092737.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092737.png" alt="img"></a></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p><p>2）Feign 客户端、Controller 都集成该接口</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092803.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092803.png" alt="img"></a></p><p>优点</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li></ul><h3 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p><p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092811.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092811.png" alt="img"></a></p><p>接下来我们就用该方法在代码中实现</p><p><strong>首先创建一个 module，命名为 feign-api</strong></p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092835.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092835.png" alt="img"></a></p><p>在 feign-api 中然后引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>order-service中的 UserClient、User 都复制到 feign-api 项目中</p><p><a href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092848.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092848.png" alt="img"></a></p><p><strong>在order-service中使用 feign-api</strong></p><p>首先，删除 order-service 中的 UserClient、User</p><p>在 order-service 中引入 feign-api</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xn2001.feign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修改注解</strong></p><p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p><p>修改 order-service 启动类上的 @EnableFeignClients 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.xn2001.feign.clients&quot;)</span><br></code></pre></td></tr></table></figure><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173727591.png" alt="image-20220521173727591"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在 SpringCloud 中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol><li>创建 SpringBoot 工程 gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建 application.yml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p><p>重启网关，访问 <a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a href="http://userservice/user/1">http://userservice/user/1</a></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173845186.png" alt="image-20220521173845186"></p><p>多个 predicates 的话，要同时满足规则，下文有例子。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173917312.png" alt="image-20220521173917312"></p><p>路由配置包括：</p><ol><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ol><h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p><p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie=chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header=X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host=<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method=GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path=/red/{segment},/blue/**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query=name, Jack或者- Query=name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr=192.168.1.1/24</td></tr><tr><td align="left">Weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><blockquote><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p></blockquote><p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">predicates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">After=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173935022.png" alt="image-20220521173935022"></p><p>Spring提供了31种不同的路由过滤器工厂。</p><blockquote><p>官方文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p></blockquote><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">AddRequestHeader</td><td align="left">给当前请求添加一个请求头</td></tr><tr><td align="left">RemoveRequestHeader</td><td align="left">移除请求中的一个请求头</td></tr><tr><td align="left">AddResponseHeader</td><td align="left">给响应结果中添加一个响应头</td></tr><tr><td align="left">RemoveResponseHeader</td><td align="left">从响应结果中移除有一个响应头</td></tr><tr><td align="left">RequestRateLimiter</td><td align="left">限制请求的流量</td></tr></tbody></table><p>下面我们以 AddRequestHeader 为例：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174021064.png" alt="image-20220521174021064"></p><p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p><p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=sign,</span> <span class="hljs-string">xn2001.com</span> <span class="hljs-string">is</span> <span class="hljs-string">eternal</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure><p>如何验证，我们修改 userservice 中的一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="hljs-meta">@RequestHeader(value = &quot;sign&quot;, required = false)</span> String sign)</span> </span>&#123;<br>    log.warn(sign);<br>    <span class="hljs-keyword">return</span> userService.queryById(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>重启两个服务，访问：<a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p><p>可以看到控制台打印出了这个请求头</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174034929.png" alt="image-20220521174034929"></p><p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=sign,</span> <span class="hljs-string">xn2001.com</span> <span class="hljs-string">is</span> <span class="hljs-string">eternal</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p><p><strong>需求：</strong>定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p><ul><li>参数中是否有 authorization</li><li>authorization 参数值是否为 admin</li></ul><p>如果同时满足则放行，否则拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-comment">// 测试：http://localhost:10010/order/101?authorization=admin</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取第一个 authorization 参数</span><br>        String authorization = exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(authorization))&#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 设置拦截状态码信息</span><br>        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>        <span class="hljs-comment">// 设置拦截</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置过滤器优先级，值越低优先级越高</span><br>    <span class="hljs-comment">// 也可以使用 @Order 注解</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p><p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174102554.png" alt="image-20220521174102554"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li><li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li><li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure><h1 id="ELasticsearch搜索引擎"><a href="#ELasticsearch搜索引擎" class="headerlink" title="ELasticsearch搜索引擎"></a>ELasticsearch搜索引擎</h1><p>ELasticsearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容，可以用来实现搜索、日志统计、分析、系统监控等功能。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><strong>首先，倒排索引的概念是基于 MySQL 这样的正向索引而言的。</strong></p><p>那么我们先讲何为正向索引。例如给下表（tb_goods）中的 id 创建索引</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135704943.png" alt="image-20220522135704943"></p><p>如果是根据 id 查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：</p><ol><li>用户搜索数据，条件是 title 符合 <code>&quot;%手机%&quot;</code></li><li>逐行获取数据，比如 id 为 1 的数据</li><li>判断数据中的 title 是否符合用户搜索条件</li><li>如果符合则放入结果集，不符合则丢弃。然后回到步骤1</li></ol><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是。。。</p><p>而倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档 id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引</li></ul><p>如图：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135727991.png" alt="image-20220522135727991"></p><p><strong>倒排索引的搜索流程</strong>如下（以搜索”华为手机”为例）</p><ol><li>用户输入条件<code>&quot;华为手机&quot;</code>进行搜索</li><li>对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code></li><li>拿着词条在倒排索引中查找，可以得到包含词条的文档 id 有 1、2、3</li><li>拿着文档 id 到正向索引中查找具体文档</li></ol><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135742748.png" alt="image-20220522135742748"></p><p><strong>虽然要先查询倒排索引，再查询正向索引，但是词条和文档id 都建立了索引，查询速度非常快！无需全表扫描。</strong></p><p>为什么一个叫做正向索引，一个叫做倒排索引呢？</p><p><strong>正向索引</strong>是最传统的，根据 id 索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong></p><p><strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据得到的文档 id 获取该文档。是<strong>根据词条找文档的过程</strong></p><h2 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h2><p>elasticsearch 是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 json 格式后存储在 elasticsearch</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135806235.png" alt="image-20220522135806235"></p><p>而 JSON 文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><h2 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h2><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135826088.png" alt="image-20220522135826088"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><p><strong>mysql 与 elasticsearch</strong></p><table><thead><tr><th align="left"><strong>MySQL</strong></th><th align="left"><strong>Elasticsearch</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Table</td><td align="left">Index</td><td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td align="left">Row</td><td align="left">Document</td><td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="left">Column</td><td align="left">Field</td><td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="left">Schema</td><td align="left">Mapping</td><td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="left">SQL</td><td align="left">DSL</td><td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用 MySQL 实现</li><li>对查询性能要求较高的搜索需求，使用 ELasticsearch 实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135845119.png" alt="image-20220522135845119"></p><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>：智能切分，粗粒度</li><li><code>ik_max_word</code>：最细切分，细粒度</li></ul><h2 id="扩展词词典"><a href="#扩展词词典" class="headerlink" title="扩展词词典"></a>扩展词词典</h2><p>在上面的IK分词器我们可以随着热点词来扩展，可以自己添加，比如 ”钟老师应该是一个热点词“，另外你也可以配置一些停用掉的敏感词，让其不进行分词。</p><p>打开IK分词器 config 目录是 <code>IKAnalyzer.cfg.xml</code>，添加一个文件名，我们以 <code>ext.dic</code> 文件名为例。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140038286.png" alt="image-20220522140038286"></p><p>我们去创建 <code>ext.dic</code> ，在其中添加热点词就好了，一个词一行。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140052838.png" alt="image-20220522140052838"></p><p>重启elasticsearch。</p><h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><h3 id="Mapping属性映射"><a href="#Mapping属性映射" class="headerlink" title="Mapping属性映射"></a>Mapping属性映射</h3><p>索引库就类似数据库表，<strong>mapping 映射就类似表的结构</strong></p><p>我们要向 es 中存储数据，必须先创建“库”和“表”</p><p>mapping 是对索引库中文档的约束，常见的 mapping 属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li><strong>index：是否创建索引，默认为 true</strong></li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>我们以需要存储下面的 JSON 为例来讲解</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">&quot;weight&quot;</span>: <span class="hljs-number">52.1</span>,<br>    <span class="hljs-attr">&quot;isMarried&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;钟老师真菜&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;jialna@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: [<span class="hljs-number">99.1</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">98.9</span>],<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;湖&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;心&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对应的每个字段映射（mapping）情况如下：</p><ul><li>age：类型为 integer；参与搜索，index 为 true；无需分词器</li><li>weight：类型为 float；参与搜索，index 为 true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，index 为 true；无需分词器</li><li>info：类型为字符串，需要分词，因此是 text；参与搜索，index为true；分词器可以用 ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，index 为 false；无需分词器</li><li>score：虽然是数组，<strong>但是我们只看元素的类型</strong>，类型为 float；参与搜索，index 为 true；无需分词器</li><li>name：类型为 object，需要定义多个子属性<ul><li>name.firstName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li><li>name.lastName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li></ul></li></ul><h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p>上面我们了解了 Mapping 属性映射，接下来我们就去看看如何创建索引库及映射。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;字段名&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;字段名2&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;false&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;字段名3&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;子字段&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// ...略</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>PUT /hotel<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;name&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;address&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;price&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;score&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;brand&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;city&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;starName&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;business&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;location&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;geo_point&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;pic&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;all&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值利用 <code>copy_to</code> 合并，提供给用户搜索，这样一来就只需要搜索一个字段就可以得到结果，性能更好。</li></ul><blockquote><p>ES中支持两种地理坐标数据类型：</p><ul><li>geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：”32.8752345, 120.2981576”</li><li>geo_shape：有多个 geo_point 组成的复杂几何图形。例如一条直线，”LINESTRING (-77.03653 38.897676, -77.009051 38.889939)”</li></ul></blockquote><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改 mapping</strong></p><p>虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，不会对倒排索引产生影响。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_mapping<br>&#123;<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;新字段名&quot;</span>:&#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名<br></code></pre></td></tr></table></figure><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /数据库名<br></code></pre></td></tr></table></figure><h2 id="DSL文档操作"><a href="#DSL文档操作" class="headerlink" title="DSL文档操作"></a>DSL文档操作</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br>&#123;<br>    <span class="hljs-attr">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-attr">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-attr">&quot;字段3&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;子属性1&quot;</span>: <span class="hljs-string">&quot;值3&quot;</span>,<br>        <span class="hljs-attr">&quot;子属性2&quot;</span>: <span class="hljs-string">&quot;值4&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>POST /xn2001/_doc/1<br>&#123;<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;我不会Java&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;jialna@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;钟&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;弟弟&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>修改文档有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><p><strong>全量修改</strong>是覆盖原来的文档，其本质是：</p><ul><li>根据指定的 id 删除文档</li><li>新增一个相同 id 的文档</li></ul><p><strong>注意</strong>：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就是变成了新增操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /&#123;索引库名&#125;/_doc/id<br>&#123;<br>    <span class="hljs-attr">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-attr">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-comment">// ... 略</span><br>&#125;<br>PUT /xn2001/_doc/1<br>&#123;<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;我也不会敲代码&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;3300123589@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;弟弟&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;钟&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>增量修改</strong>是只修改指定 id 匹配的文档中的部分字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /&#123;索引库名&#125;/_update/文档id<br>&#123;<br>    <span class="hljs-attr">&quot;doc&quot;</span>: &#123;<br>         <span class="hljs-attr">&quot;字段名&quot;</span>: <span class="hljs-string">&quot;新的值&quot;</span>,<br>    &#125;<br>&#125;<br>POST /heima/_update/1<br>&#123;<br>  <span class="hljs-attr">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;update@qq.com&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /&#123;索引库名称&#125;/_doc/&#123;id&#125;<br></code></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /&#123;索引库名&#125;/_doc/&#123;id&#125;<br></code></pre></td></tr></table></figure><h2 id="RestClient文档操作"><a href="#RestClient文档操作" class="headerlink" title="RestClient文档操作"></a>RestClient文档操作</h2><p>ES 官方提供了各种不同语言的客户端，用来操作 ES。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><h3 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h3><p>在 elasticsearch 提供的 API 中，elasticsearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 elasticsearch 的连接。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot 默认的 ES 版本是 7.6.2，我们需要覆盖默认的ES版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>初始化 RestHighLevelClient，初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">RestHighLevelClient client = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure><p>我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 <code>@BeforeEach</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/19 17:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelIndexTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.restHighLevelClient);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//指定索引库名</span><br>    CreateIndexRequest hotel = <span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">//写入JSON数据，这里是Mapping映射</span><br>    hotel.source(HotelConstants.MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">//创建索引库</span><br>    restHighLevelClient.indices().create(hotel, RequestOptions.DEFAULT);<br>&#125;<br><br><span class="hljs-comment">//具体的json数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelConstants</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String MAPPING_TEMPLATE = <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    DeleteIndexRequest hotel = <span class="hljs-keyword">new</span> DeleteIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    restHighLevelClient.indices().delete(hotel,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断索引库"><a href="#判断索引库" class="headerlink" title="判断索引库"></a>判断索引库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">existHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    GetIndexRequest hotel = <span class="hljs-keyword">new</span> GetIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-keyword">boolean</span> exists = restHighLevelClient.indices().exists(hotel, RequestOptions.DEFAULT);<br>    System.out.println(exists);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/19 17:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelDocumentTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.restHighLevelClient);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Hotel hotel = hotelService.getById(<span class="hljs-number">61083L</span>);<br>        HotelDoc hotelDoc = <span class="hljs-keyword">new</span> HotelDoc(hotel);<br>        <span class="hljs-comment">// 1.准备Request对象</span><br>        IndexRequest hotelIndex = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());<br>        <span class="hljs-comment">// 2.准备Json文档</span><br>        hotelIndex.source(JSON.toJSONString(hotelDoc), XContentType.JSON);<br>        <span class="hljs-comment">// 3.发送请求</span><br>        restHighLevelClient.index(hotelIndex, RequestOptions.DEFAULT);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    GetRequest hotel = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求，得到响应</span><br>    GetResponse hotelResponse = restHighLevelClient.get(hotel, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.解析响应结果</span><br>    String hotelDocSourceAsString = hotelResponse.getSourceAsString();<br>    <span class="hljs-comment">// 4.json转实体类</span><br>    HotelDoc hotelDoc = JSON.parseObject(hotelDocSourceAsString, HotelDoc.class);<br>    System.out.println(hotelDoc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    DeleteRequest hotel = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    restHighLevelClient.delete(hotel,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><p>前面我们说过，修改文档有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><p>在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>所以全量修改写法与新增文档一样，下面我们主要是介绍增量修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testUpdateDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    UpdateRequest request = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.doc(<br>        <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-string">&quot;952&quot;</span>,<br>        <span class="hljs-string">&quot;starName&quot;</span>, <span class="hljs-string">&quot;四钻&quot;</span><br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    restHighLevelClient.update(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h3><p>案例需求：利用 <code>BulkRequest</code> 批量将数据库数据导入到索引库中。</p><ul><li>利用 mybatis-plus 查询酒店数据</li><li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li><li>利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档</li></ul><p>批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。</p><p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140530912.png" alt="image-20220522140530912"></p><p>利用这一点，我们可以写出自己需要的代码，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testBulk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    BulkRequest bulkRequest = <span class="hljs-keyword">new</span> BulkRequest();<br>    List&lt;Hotel&gt; hotelList = hotelService.list();<br>    hotelList.forEach(item -&gt; &#123;<br>        HotelDoc hotelDoc = <span class="hljs-keyword">new</span> HotelDoc(item);<br>        bulkRequest.add(<span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                .id(hotelDoc.getId().toString())<br>                .source(JSON.toJSONString(hotelDoc), XContentType.JSON));<br>    &#125;);<br>    restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>总之，在 Java 代码中，client 针对操作索引库还是文档，基本都是一样的代码</p><p>restHighLevelClient.indices().xxx，代表操作索引库</p><p>restHighLevelClient.xxx，代表操作文档</p><p>而其中所需要的参数，我们直接通过 <strong>ctrl+p</strong> 这样的快捷键去查看就可以，不需要单独记住。</p><h2 id="DSL文档查询"><a href="#DSL文档查询" class="headerlink" title="DSL文档查询"></a>DSL文档查询</h2><p>Elasticsearch 提供了基于 JSON 的 DSL(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>)来定义查询。常见的查询类型包括：</p><p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p><p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul><hr><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 查询所有</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>使用场景：全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>常见的全文检索查询包括：</p><ul><li>match 查询：单字段查询</li><li>multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match 查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mulit_match 查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span>,<br>      <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;FIELD1&quot;</span>, <span class="hljs-string">&quot; FIELD12&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们将 brand、name、business 值都利用 <strong>copy_to</strong> 复制到了 <strong>all</strong> 字段中，你根据三个字段搜索，和根据 all字段搜索效果是一样的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;all&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br>GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span>,<br>      <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;brand&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>搜索字段越多，对查询性能影响越大，因此建议采用 copy_to 将多个字段合并为一个，然后使用单字段查询的方式。</strong></p><h3 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h3><p>精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以<strong>不会</strong>对搜索条件分词。</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><h4 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h4><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// term查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;VALUE&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;brand&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p>基本语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// range查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 这里的gte代表大于等于，gt则代表大于</span><br>        <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">20</span> <span class="hljs-comment">// lte代表小于等于，lt则代表小于</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140701446.png" alt="image-20220522140701446"></p><p>精确查询常见的有哪些？</p><ul><li>term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段</li><li>range 查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h3 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h3><p>地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><blockquote><p>矩形范围查询</p></blockquote><p>矩形范围查询，也就是 <code>geo_bounding_box</code> 查询，查询坐标落在某个矩形范围的所有文档</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164127368.png" alt="image-20220522164127368"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_bounding_box查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;geo_bounding_box&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;top_left&quot;</span>: &#123; <span class="hljs-comment">// 左上点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span>: <span class="hljs-number">31.1</span>,<br>          <span class="hljs-attr">&quot;lon&quot;</span>: <span class="hljs-number">121.5</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;bottom_right&quot;</span>: &#123; <span class="hljs-comment">// 右下点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span>: <span class="hljs-number">30.9</span>,<br>          <span class="hljs-attr">&quot;lon&quot;</span>: <span class="hljs-number">121.7</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>附近查询</p></blockquote><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档</p><p>在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164158386.png" alt="image-20220522164158386"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_distance 查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;geo_distance&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;distance&quot;</span>: <span class="hljs-string">&quot;15km&quot;</span>, <span class="hljs-comment">// 半径</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;31.21,121.5&quot;</span> <span class="hljs-comment">// 圆心</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以根据距离排序</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;location&quot;</span>: <span class="hljs-string">&quot;31.034661,121.612282&quot;</span>, <span class="hljs-comment">//圆心</span><br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">//排序</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">//单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;hits&quot; : [<br>    &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;hotel&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;2056298828&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>            ...<br>        &#125;,<br>        &quot;sort&quot; : [<br>            <span class="hljs-number">4.8541199685347785</span> <span class="hljs-comment">//这里的结果为离圆心的距离</span><br>        ]<br>    &#125;,<br></code></pre></td></tr></table></figure><p>注意：输出结果中的 <strong>sort</strong> 为距离，比较常用。</p><p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的</p><h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h3 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h3><blockquote><p>这部分内容作为了解即可。</p></blockquote><p>当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">17.850193</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;虹桥如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">12.259849</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;外滩如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">11.91091</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;迪士尼如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><p>根据相关度打分是比较合理的需求，但有时候也不能够满足我们的需求。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁给的钱多排名就越靠前。</p><p><strong>要想认为控制相关性算分，就需要利用 elasticsearch 中的 function score 查询了。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164427295.png" alt="image-20220522164427295"></p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query 部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter 部分，符合该条件的文档才会<strong>重新算分</strong></li><li><strong>算分函数</strong>：符合 filter 条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用 function score 替换 query score</li><li>sum、avg、max、min</li></ul></li></ul><p>function score 的运行流程如下：</p><ol><li>根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>根据<strong>过滤条件</strong>，过滤文档</li><li>符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ol><p>因此，其中的关键点是</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><p>例如：我们给“如家”这个品牌的酒店排名靠前一些</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;function_score&quot;</span>: &#123;<br>      &quot;query&quot;: &#123;  .... &#125;, // 原始查询，可以是任意条件<br>      &quot;functions&quot;: [ // 算分函数<br>        &#123;<br>          <span class="hljs-attr">&quot;filter&quot;</span>: &#123; <span class="hljs-comment">// 满足的条件，品牌必须是如家</span><br>            <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;如家&quot;</span><br>            &#125;<br>          &#125;,<br>          <span class="hljs-attr">&quot;weight&quot;</span>: <span class="hljs-number">10</span> <span class="hljs-comment">// 算分权重为10</span><br>        &#125;<br>      ],<br>      &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试，在未添加算分函数时，如家得分如下</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164516047.png" alt="image-20220522164516047"></p><p>添加了算分函数后，如家得分就提升了</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164530125.png" alt="image-20220522164530125"></p><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤</p><p><strong>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool查询了。</strong></p><p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分</li><li>其它过滤条件，采用 filter 查询，不参与算分</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;must&quot;</span>: [<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;city&quot;</span>: <span class="hljs-string">&quot;上海&quot;</span> &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;should&quot;</span>: [<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;皇冠假日&quot;</span> &#125;&#125;,<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;华美达&quot;</span> &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;must_not&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;range&quot;</span>: &#123; <span class="hljs-attr">&quot;price&quot;</span>: &#123; <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">500</span> &#125; &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;filter&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;range&quot;</span>: &#123;<span class="hljs-attr">&quot;score&quot;</span>: &#123; <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">45</span> &#125; &#125;&#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。</p><ul><li>名称搜索，属于全文检索查询，应该参与算分，放到 must 中</li><li>价格不高于 400，用 range 查询，属于过滤条件，不参与算分，放到 must_not 中</li><li>周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分，放到 filter 中</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164728363.png" alt="image-20220522164728363"></p><p>bool 查询的几种逻辑关系</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h2 id="搜索结果处理"><a href="#搜索结果处理" class="headerlink" title="搜索结果处理"></a>搜索结果处理</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>elasticsearch 默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等</p><p>keyword、数值、日期类型排序的语法基本一致。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>  <span class="hljs-comment">// 排序字段、排序方式ASC、DESC</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序。</p><p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164754555.png" alt="image-20220522164754555"></p><p>地理坐标排序略有不同</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;FIELD&quot;</span> : <span class="hljs-string">&quot;纬度，经度&quot;</span>, <span class="hljs-comment">// 文档中geo_point类型的字段名、目标坐标点</span><br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">// 排序方式</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">// 排序的距离单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;location&quot;</span>: <span class="hljs-string">&quot;31.034661,121.612282&quot;</span>, <br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat</a></p></blockquote><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>elasticsearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。</p><p>elasticsearch 通过修改 from、size 参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>深度分页问题</p></blockquote><p>现在，我要查询990~1000的数据，查询逻辑要这么写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">990</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>注意：elasticsearch 内部分页时，必须先查询 0~1000条，然后截取其中的 990 ~ 1000 的这10条</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164937837.png" alt="image-20220522164937837"></p><p>查询TOP1000，如果 es 是单点模式，这并无太大影响。</p><p>但是 elasticsearch 将来一定是集群，例如我集群有5个节点，我要查询 TOP1000 的数据，并不是每个节点查询200条就可以了。节点A的 TOP200，在另一个节点可能排到10000名以外了。</p><p><strong>因此要想获取整个集群的 TOP1000，必须先查询出每个节点的 TOP1000，汇总结果后，重新排名，重新截取 TOP1000。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164952750.png" alt="image-20220522164952750"></p><p><strong>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此 elasticsearch 会禁止from+ size 超过10000的请求。</strong></p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul><hr><p>分页查询的常见实现方案以及优缺点</p><ul><li><code>from + size</code><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><code>after search</code><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><code>scroll</code><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165015423.png" alt="image-20220522165015423"></p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span> <span class="hljs-comment">// 查询条件，高亮一定要使用全文检索查询</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;highlight&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;fields&quot;</span>: &#123; <span class="hljs-comment">// 指定要高亮的字段</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;em&gt;&quot;</span>,  <span class="hljs-comment">// 用来标记高亮字段的前置标签</span><br>        <span class="hljs-attr">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span> <span class="hljs-comment">// 用来标记高亮字段的后置标签</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：<code>required_field_match=false</code></li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165033153.png" alt="image-20220522165033153"></p><blockquote><p>DSL 总体结构如下：</p></blockquote><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165048231.png" alt="image-20220522165048231"></p><h2 id="RestClient文档查询"><a href="#RestClient文档查询" class="headerlink" title="RestClient文档查询"></a>RestClient文档查询</h2><h3 id="发起查询请求"><a href="#发起查询请求" class="headerlink" title="发起查询请求"></a>发起查询请求</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165109299.png" alt="image-20220522165109299"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/10/16 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelSearchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match_All</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        request.source()<br>                .query(QueryBuilders.matchAllQuery());<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一步，创建<code>SearchRequest</code>对象，指定索引库名</li><li>第二步，利用<code>request.source()</code>构建 DSL，DSL 中可以包含查询、分页、排序、高亮等<ul><li><code>query()</code>：代表查询条件，利用 <code>QueryBuilders.matchAllQuery()</code> 构建一个 match_all 查询的 DSL</li></ul></li><li>第三步，利用 <code>client.search()</code> 发送请求，得到响应</li></ul><p>关键的 API 有两个，一个是 <code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165155892.png" alt="image-20220522165155892"></p><p>另一个是 <code>QueryBuilders</code>，其中包含 match、term、function_score、bool 等各种查询</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165215501.png" alt="image-20220522165215501"></p><h3 id="解析查询响应"><a href="#解析查询响应" class="headerlink" title="解析查询响应"></a>解析查询响应</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165233745.png" alt="image-20220522165233745"></p><p>Elasticsearch 返回的结果是一个 JSON 字符串，结构包含</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个 json 对象<ul><li><code>_source</code>：文档中的原始数据，也是 json 对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下</p><ul><li><code>SearchHits</code>：通过 <code>response.getHits()</code> 获取，就是 json 中的最外层的 hits，代表命中的结果<ul><li><code>SearchHits.getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits.getHits()</code>：获取 SearchHit 数组，也就是文档数组<ul><li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的 <code>_source</code>，也就是原始的 json 文档数据</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/10/16 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelSearchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match_All</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        request.source()<br>                .query(QueryBuilders.matchAllQuery());<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        SearchHits searchHits = response.getHits();<br>        System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>        SearchHit[] hits = searchHits.getHits();<br>        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>            String sourceAsString = hit.getSourceAsString();<br>            HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>            System.out.println(hotelDoc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165256103.png" alt="image-20220522165256103"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source()<br>            .query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>,<span class="hljs-string">&quot;如家&quot;</span>));<br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multiMatchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source()<br>            .query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;如家&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;brand&quot;</span>));<br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询主要是两者</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165330608.png" alt="image-20220522165330608"></p><h3 id="布尔查询-1"><a href="#布尔查询-1" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是用 must、must_not、filter等方式组合其它查询，代码示例如下</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165341669.png" alt="image-20220522165341669"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    request.source()<br>            .query(<br>                    QueryBuilders.boolQuery()<br>                            .must(QueryBuilders.termQuery(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>))<br>                            .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">300</span>))<br>            );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序、分页"><a href="#排序、分页" class="headerlink" title="排序、分页"></a>排序、分页</h3><p>搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 <code>request.source()</code> 来设置。</p><p>对应的API如下</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165400398.png" alt="image-20220522165400398"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPageAndSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 页码，每页大小</span><br>    <span class="hljs-keyword">int</span> page = <span class="hljs-number">1</span>, size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 2.2.排序 sort</span><br>    request.source().sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>    <span class="hljs-comment">// 2.3.分页 from、size</span><br>    request.source().from((page - <span class="hljs-number">1</span>) * size).size(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h3><ul><li>查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。</li><li>结果解析：结果除了要解析 <code>_source</code> 文档数据，还要解析高亮结果</li></ul><p><strong>高亮请求的构建 API</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165415263.png" alt="image-20220522165415263"></p><p>上述代码省略了查询条件部分，但是高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;如家&quot;</span>));<br>    <span class="hljs-comment">// 2.2.高亮</span><br>    request.source().highlighter(<span class="hljs-keyword">new</span> HighlightBuilder().field(<span class="hljs-string">&quot;name&quot;</span>).requireFieldMatch(<span class="hljs-keyword">false</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response); <span class="hljs-comment">//代码在下文</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高亮结果解析</strong></p><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><p>因此解析高亮的代码需要额外处理：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165433204.png" alt="image-20220522165433204"></p><ul><li>第一步：从结果中获取 source。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json 字符串，需要反序列为 HotelDoc 对象</li><li>第二步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个 Map，key 是高亮字段名称，值是HighlightField 对象，代表高亮值</li><li>第三步：从 map 中根据高亮字段名称，获取高亮字段值对象 HighlightField</li><li>第四步：从 HighlightField 中获取 Fragments，并且转为字符串。<strong>这部分是真正的高亮字符串</strong></li><li>第五步：用高亮的结果替换 HotelDoc 中的非高亮结果</li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> </span>&#123;<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    <span class="hljs-comment">// 4.1.获取总条数</span><br>    <span class="hljs-keyword">long</span> total = searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 4.2.文档数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 获取文档source</span><br>        String json = hit.getSourceAsString();<br>        <span class="hljs-comment">// 反序列化</span><br>        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);<br>        <span class="hljs-comment">// 获取高亮结果</span><br>        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;<br>            <span class="hljs-comment">// 根据字段名获取高亮结果</span><br>            HighlightField highlightField = highlightFields.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (highlightField != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 获取高亮值</span><br>                String name = highlightField.getFragments()[<span class="hljs-number">0</span>].string();<br>                <span class="hljs-comment">// 覆盖非高亮结果</span><br>                hotelDoc.setName(name);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;hotelDoc = &quot;</span> + hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Sentine流量组件"><a href="#Sentine流量组件" class="headerlink" title="Sentine流量组件"></a>Sentine流量组件</h1><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><blockquote><p>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</p></blockquote><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183034937.png" alt="image-20220520183034937"></p><p>如图，如果服务提供者I 发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I 的业务似乎不受影响。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183059877.png" alt="image-20220520183059877"></p><p>但是，依赖服务I 的业务请求被阻塞，则 tomcat 的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183114168.png" alt="image-20220520183114168"></p><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，<strong>从而导致所有其它服务都不可用</strong>。</p><p>综上，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，这就是雪崩问题。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183129914.png" alt="image-20220520183129914"></p><p>解决雪崩问题的常见方式有四种</p><ol><li>超时处理</li><li>线程隔离</li><li>降级熔断</li><li>限流</li></ol><blockquote><p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p><p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p></blockquote><p>1.超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183203519.png" alt="image-20220520183203519"></p><p>2.线程隔离</p><p>是一种舱壁模式，如下图，船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此也叫线程隔离。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183217487.png" alt="image-20220520183217487"></p><p>3.降级熔断</p><p>是一种断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p><p>断路器会统计访问某个服务的请求数量，异常比例。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183301761.png" alt="image-20220520183301761"></p><p>当发现访问服务 D 的请求异常比例过高时，认为服务 D 有导致雪崩的风险，会拦截访问服务 D 的一切请求，形成熔断。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183317450.png" alt="image-20220520183317450"></p><p>4.限流</p><p><strong>流量控制</strong>：限制业务访问的 QPS，避免服务因流量的突增而故障。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183330199.png" alt="image-20220520183330199"></p><p>在 SpringCloud 当中支持多种服务保护技术</p><ul><li><a href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></li><li><a href="https://github.com/alibaba/Sentinel">Sentinel</a></li><li><a href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li></ul><p>早期比较流行的是 Hystrix 框架，但目前国内实用最广泛的还是阿里巴巴的 Sentinel 框架，这里我们做下对比：</p><table><thead><tr><th align="left"></th><th align="left"><strong>Sentinel</strong></th><th align="left"><strong>Hystrix</strong></th></tr></thead><tbody><tr><td align="left">隔离策略</td><td align="left">信号量隔离</td><td align="left">线程池隔离/信号量隔离</td></tr><tr><td align="left">熔断降级策略</td><td align="left">基于慢调用比例或异常比例</td><td align="left">基于失败比率</td></tr><tr><td align="left">实时指标实现</td><td align="left">滑动窗口</td><td align="left">滑动窗口（基于 RxJava）</td></tr><tr><td align="left">规则配置</td><td align="left">支持多种数据源</td><td align="left">支持多种数据源</td></tr><tr><td align="left">扩展性</td><td align="left">多个扩展点</td><td align="left">插件的形式</td></tr><tr><td align="left">基于注解的支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">限流</td><td align="left">基于 QPS，支持基于调用关系的限流</td><td align="left">有限的支持</td></tr><tr><td align="left">流量整形</td><td align="left">支持慢启动、匀速排队模式</td><td align="left">不支持</td></tr><tr><td align="left">系统自适应保护</td><td align="left">支持</td><td align="left">不支持</td></tr><tr><td align="left">控制台</td><td align="left">开箱即用，可配置规则、查看秒级监控、机器发现等</td><td align="left">不完善</td></tr><tr><td align="left">常见框架的适配</td><td align="left">Servlet、Spring Cloud、Dubbo、gRPC 等</td><td align="left">Servlet、Spring Cloud Netflix</td></tr></tbody></table><h2 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h2><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p><p>Sentinel 具有以下特征</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h2 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h2><p>下载后 jar 包后，运行代码：<code>java -jar sentinel-dashboard-1.8.1.jar</code></p><p>如果要修改 Sentinel 的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th align="left"><strong>配置项</strong></th><th align="left"><strong>默认值</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">server.port</td><td align="left">8080</td><td align="left">服务端口</td></tr><tr><td align="left">sentinel.dashboard.auth.username</td><td align="left">sentinel</td><td align="left">默认用户名</td></tr><tr><td align="left">sentinel.dashboard.auth.password</td><td align="left">sentinel</td><td align="left">默认密码</td></tr></tbody></table><p>例如，修改端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改其他配置也在配置项前面添加-D，注意不要在最后添加，会不起作用</span><br><span class="hljs-comment"># 也可以使用java -jar sentinel-dashboard-1.8.1.jar --server.port=9090 修改端口</span><br>java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar<br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080/">http://localhost:8080</a> 页面，就可以看到 Sentinel 的控制台了。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183712354.png" alt="image-20220520183712354"></p><p>账号和密码默认都是：sentinel</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183727720.png" alt="image-20220520183727720"></p><p>此时空白一片，还需要我们来整合进 SpringCloud</p><p>准备好我们的项目，在资料中，结构如下：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183803497.png" alt="image-20220520183803497"></p><p>我们在 order-service 中整合 Sentinel，并连接 Sentinel 的控制台，步骤如下</p><p>1）引入 Sentinel 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sentinel--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改 application.yml 文件，添加下面内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>3）访问 order-service 的任意端点</p><p>打开浏览器，访问 <a href="http://localhost:10010/order/101%EF%BC%8C%E5%A4%9A%E8%AE%BF%E9%97%AE%E5%87%A0%E6%AC%A1%EF%BC%8C%E5%A4%9A%E7%82%B9%E5%87%A0%E6%AC%A1%E5%88%B7%E6%96%B0%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A6%E5%8F%91">http://localhost:10010/order/101，多访问几次，多点几次刷新，这样才能触发</a> Sentinel 的监控。</p><p>然后再访问 Sentinel 的控制台，查看效果。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183830014.png" alt="image-20220520183830014"></p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>雪崩问题虽有四种方案，但是<strong>限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。</strong>学过毛中特的都知道，《预判风险所在是防范风险的前提》，我们先学习流量控制。</p><h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>当请求进入微服务时，首先会访问 DispatcherServlet，然后进入 Controller、Service、Mapper，这样的一个调用链就叫做 <strong>簇点链路</strong>。</p><p><strong>簇点链路中被监控的每一个接口就是一个资源</strong>。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点（Endpoint，也就是 Controller 中的方法），因此 SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>例如，我们刚才访问的 order-service 中的 OrderController 中的端点：/order/{orderId}</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183901596.png" alt="image-20220520183901596"></p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><ul><li>流控：流量控制</li><li>降级：降级熔断</li><li>热点：热点参数限流，是限流的一种</li><li>授权：请求的权限控制</li></ul><p>点击资源 /order/{orderId} 后面的流控按钮，就可以弹出表单。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183920103.png" alt="image-20220520183920103"></p><p>表单中可以填写限流规则，如下</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183935131.png" alt="image-20220520183935131"></p><p>其含义是限制 /order/{orderId} 这个资源的单机 QPS 为 1，即每秒只允许 1 次请求，超出的请求会被拦截并报错。</p><blockquote><p>需求：给 /order/{orderId} 这个资源设置流控规则，QPS 不能超过 5，然后测试。</p></blockquote><p>1）首先在 sentinel 控制台添加限流规则</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183948014.png" alt="image-20220520183948014"></p><p>2）利用 jmeter 测试</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184005873.png" alt="image-20220520184005873"></p><p>20 个用户，2 秒内运行完，这样的话 QPS 就是 10，超过了我们在 sentinel 设置的 5</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184026072.png" alt="image-20220520184026072"></p><p>可以看到，成功的请求每次只有 5 个。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184048177.png" alt="image-20220520184048177"></p><h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong></p><h4 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h4><ul><li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式<ul><li>直接对当前资源限流</li></ul></li><li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流<ul><li>相当于高优先级资源触发阈值，对低优先级资源限流。</li></ul></li><li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流<ul><li>是针对请求来源的限流</li></ul></li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184103693.png" alt="image-20220520184103693"></p><p>上面我们测试的就是直接模式，默认就是直接模式。</p><h4 id="关联模式"><a href="#关联模式" class="headerlink" title="关联模式"></a>关联模式</h4><p>统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。</p><p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184127009.png" alt="image-20220520184127009"></p><p>例如：配置规则，<strong>当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184142345.png" alt="image-20220520184142345"></p><p>我们去程序中模拟：</p><ul><li>在 OrderController 新建两个端点：/order/query 和 /order/update，无需实现业务</li><li>配置流控规则，当 /order/ update 资源被访问的 QPS 超过 5 时，对 /order/query 请求限流</li></ul><p>1）定义 /order/query 端点，模拟订单查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）定义 /order/update 端点，模拟订单更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;更新订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启服务，查看 Sentinel 控制台的簇点链路。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184209929.png" alt="image-20220520184209929"></p><p>3）配置流控规则</p><p>想要对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询 /order/query 限流</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184223704.png" alt="image-20220520184223704"></p><p>在表单中填写流控规则</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184240617.png" alt="image-20220520184240617"></p><h4 id="链路模式"><a href="#链路模式" class="headerlink" title="链路模式"></a>链路模式</h4><p>只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p><p>例如有两条请求链路</p><ul><li>/test1 –&gt; /common</li><li>/test2 –&gt; /common</li></ul><p>如果只希望统计从 /test2 进入到 /common 的请求，则可以这样配置</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184302231.png" alt="image-20220520184302231"></p><p><strong>实战案例</strong></p><p>有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p><ol><li>在 OrderService 中添加一个 queryGoods 方法，不用实现业务</li><li>在 OrderController 中，改造 /order/query 端点，调用 OrderService 中的 queryGoods 方法</li><li>在 OrderController 中添加一个 /order/save 端点，调用 OrderService 的 queryGoods 方法</li><li>给 queryGoods 设置限流规则，从 /order/query 进入 queryGoods 的方法限制 QPS 必须小于 2</li></ol><p>1）添加查询商品方法</p><p>在order-service服务中，给 OrderService 类添加一个 queryGoods 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryGoods</span><span class="hljs-params">()</span></span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>2）查询订单时，查询商品</p><p>在 order-service 的 OrderController 中，修改 /order/query 端点的业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;查询订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><p>3）新增订单，查询商品</p><p>在 order-service 的 OrderController 中，修改 /order/save 端点，模拟新增订单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;新增订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;新增订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4）给查询商品添加资源标记</p><p>默认情况下，OrderService 中的方法是不被 Sentinel 监控的，需要我们自己通过注解来标记要监控的方法。</p><p>给 OrderService 的 queryGoods 方法添加 <code>@SentinelResource</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SentinelResource(&quot;goods&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryGoods</span><span class="hljs-params">()</span></span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>链路模式中，是对不同来源的两个链路做监控。但是 Sentinel 默认会给进入 SpringMVC 的所有请求设置同一个 root 资源，会导致链路模式失效。我们需要关闭这种对 SpringMVC 的资源聚合，修改 order-service 服务的 application.yml 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭context整合</span><br></code></pre></td></tr></table></figure><p>重启服务，访问 /order/query 和 /order/save，可以查看到 Sentinel 的簇点链路规则中，出现了新的资源</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184341995.png" alt="image-20220520184341995"></p><p>5）添加流控规则</p><p>点击 goods 资源后面的流控按钮，在弹出的表单中填写下面信息</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184356116.png" alt="image-20220520184356116"></p><p>只统计从 /order/query 进入 /goods 的资源，QPS 阈值为 2，超出则被限流。</p><h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><h3 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h3><p>细心的小伙伴会发现在流控的高级选项中，还有一个流控效果选项，前面我们的测试都是基本快速失败的。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184416829.png" alt="image-20220520184416829"></p><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种</p><ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出 FlowException 异常，是默认的处理方式。</li><li>Warm Up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</li></ul><h3 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h3><p>阈值一般是一个微服务能承担的最大 QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将 QPS 跑到最大值，可能导致服务瞬间宕机。</p><p>Warm Up 也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值初始值是 <code>maxThreshold / coldFactor</code>，持续指定时长后，逐渐提高到 maxThreshold 值。而 coldFactor 的默认值是 3.</p><p>例如，我设置 QPS 的 maxThreshold 为 10，预热时间为 5 秒，那么初始阈值就是 10 / 3 = 3，然后在 5 秒后逐渐增长到 10</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184435351.png" alt="image-20220520184435351"></p><p><strong>案例</strong>：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用 Warm Up 效果，预热时长为 5 秒。</p><p>1）配置流控规则</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184540453.png" alt="image-20220520184540453"></p><p>用官方的话讲，该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p><h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p>当请求超过 QPS 阈值时，「快速失败」和 「Warm Up」会拒绝新的请求并抛出异常。</p><p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><p>例如：QPS = 5，意味着每 200ms 处理一个队列中的请求；timeout = 2000，意味着<strong>预期等待时长</strong>超过 2000ms 的请求会被拒绝并抛出异常。</p><p>比如现在一下子来了 12 个请求，因为每 200ms 执行一个请求，那么预期等待时长就是：</p><ul><li>第6个请求的<strong>预期等待时长</strong> = 200 * (6 - 1) = 1000ms</li><li>第12个请求的预期等待时长 = 200 * (12-1) = 2200ms</li></ul><p>又比如下图：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184551503.png" alt="image-20220520184551503"></p><p>现在，第 1 秒同时接收到 10 个请求，但第 2 秒只有 1 个请求，此时 QPS 的曲线这样的</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184614143.png" alt="image-20220520184614143"></p><p>如果使用排队等待的流控效果，所有进入的请求都要排队，以固定的 200ms 的间隔执行，QPS 会变的很平滑</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184630104.png" alt="image-20220520184630104"></p><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><p><strong>案例</strong>：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用排队等待的流控效果，超时时长设置为 5s</p><p>1）添加流控规则</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184650487.png" alt="image-20220520184650487"></p><h2 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而「热点参数限流」是<strong>分别统计参数值相同的请求</strong>，判断是否超过 QPS 阈值。</p><h3 id="全局参数限流"><a href="#全局参数限流" class="headerlink" title="全局参数限流"></a>全局参数限流</h3><p>例如，一个根据 id 查询商品的接口</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184712832.png" alt="image-20220520184712832"></p><p>访问 /goods/{id} 的请求中，id 参数值会有变化，「热点参数限流」会根据参数值分别统计 QPS，统计结果：</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184725180.png" alt="image-20220520184725180"></p><p>当 id=1 的请求触发阈值被限流时，id值不为1的请求则不受影响。</p><p>配置示例：对 hot 这个资源的 0 号参数（也就是第一个参数）做统计，每 1s <strong>相同参数值</strong>的请求数不能超过 5</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184740039.png" alt="image-20220520184740039"></p><h3 id="热点参数限流-1"><a href="#热点参数限流-1" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>假设上面的例子是一个商品查询接口，那么刚才的配置中，对这个接口的所有商品一视同仁，QPS 都限定为 5</p><p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的 QPS 限制与其它商品不一样，高一些。那就需要配置「热点参数限流」的高级选项了。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184755485.png" alt="image-20220520184755485"></p><p>结合上一个配置，这里的含义是对 0 号的 long 类型参数限流，每 1 个相同参数的 QPS 不能超过 5，有如下两个例外</p><ul><li>如果参数值是 100，则每 1s 允许的 QPS 为 10</li><li>如果参数值是 101，则每 1s 允许的 QPS 为 15</li></ul><p><strong>案例需求</strong>：给 /order/{orderId} 这个资源添加「热点参数限流」，规则如下</p><ul><li>默认的热点参数规则是每 1s 请求量不超过 2</li><li>给 102 这个参数设置例外：每 1s 请求量不超过 4</li><li>给 103 这个参数设置例外：每 1s 请求量不超过 10</li></ul><p><strong>注意事项</strong>：热点参数限流对默认的 SpringMVC 资源无效，需要利用 <code>@SentinelResource</code> 注解标记资源。</p><p>1）标记资源</p><p>给 order-service 中的 OrderController 中的 /order/{orderId} 资源添加注解</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184809515.png" alt="image-20220520184809515"></p><p>2）热点参数限流规则</p><p>访问该接口，可以看到我们标记的 hot 资源出现了</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184821804.png" alt="image-20220520184821804"></p><p>点击左侧菜单中<strong>热点规则</strong>菜单</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184835734.png" alt="image-20220520184835734"></p><p>点击左侧菜单中<strong>热点规则</strong>菜单</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184856244.png" alt="image-20220520184856244"></p><p>点击新增，填写表单</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184910985.png" alt="image-20220520184910985"></p><h2 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h2><p>限流只是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p><p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p><p><strong>线程隔离</strong>：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184930101.png" alt="image-20220520184930101"></p><p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184941897.png" alt="image-20220520184941897"></p><p>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong>发起远程调用时做线程隔离、或者服务熔断。</p><p>而我们的微服务远程调用都是基于 Feign 来完成的，因此我们需要将 Feign 与 Sentinel 整合，在 Feign 里面实现线程隔离和服务熔断。</p><h2 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel</h2><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合 Feign 和 Sentinel</p><p>修改配置，开启 Sentinel 功能，修改 OrderService 的 application.yml 文件，开启 Feign 的 Sentinel 功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对sentinel的支持</span><br></code></pre></td></tr></table></figure><p>服务降级：访问失败后，服务</p><p><strong>编写失败降级逻辑代码</strong>，业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p><p>给 FeignClient 编写失败后的降级逻辑</p><p>①方式一：FallbackClass，但无法对远程调用的异常做处理。</p><p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p><p>这里我们演示方式二的失败降级处理。</p><p><strong>步骤一</strong>：在 feing-api 项目中定义类，实现 FallbackFactory</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172651031.png" alt="image-20220521172651031"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xn2001.feign.clients.fallback;<br><br><span class="hljs-keyword">import</span> com.xn2001.feign.clients.UserClient;<br><span class="hljs-keyword">import</span> com.xn2001.feign.pojo.User;<br><span class="hljs-keyword">import</span> feign.hystrix.FallbackFactory;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/5/9 14:24</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserClientFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FallbackFactory</span>&lt;<span class="hljs-title">UserClient</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserClient <span class="hljs-title">create</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> userClient -&gt; &#123;<br>           log.error(<span class="hljs-string">&quot;查询用户失败&quot;</span>,throwable);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>       &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤二</strong>：在 feing-api 项目中的 DefaultFeignConfiguration 类中将 UserClientFallbackFactory 注册为一个Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserClientFallbackFactory <span class="hljs-title">userClientFallbackFactory</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserClientFallbackFactory();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：在 feing-api 项目中的 UserClient 接口中使用 UserClientFallbackFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启后，访问一次订单查询业务，然后查看 Sentinel 控制台，可以看到新的簇点链路</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172853837.png" alt="image-20220521172853837"></p><h2 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h2><p>线程隔离（舱壁模式）有两种方式实现</p><ul><li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果。</li><li>信号量隔离（Sentinel默认采用）：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</li></ul><p>两者的优缺点</p><ul><li>线程池隔离：基于线程池模式，有额外开销，但隔离控制更强</li><li>信号量隔离：基于计数器模式，简单，开销小</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172910064.png" alt="image-20220521172910064"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172923462.png" alt="image-20220521172923462"></p><p><strong>Sentinel 使用的是信号量隔离</strong>，而 Hystrix 则两种线程隔离都可以，18 年Hystrix已经停止更新。</p><p>如何使用呢，在添加限流规则时，可以选择两种阈值类型</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173012300.png" alt="image-20220521173012300"></p><ul><li>QPS：就是每秒的请求数，之前已经演示过。</li><li>线程数：是该资源能使用的 Tomcat 线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</li></ul><p><strong>案例需求</strong>：给 order-service 服务中的 UserClient 的查询用户接口设置流控规则，线程数不能超过 2，然后利用 JMeter 测试。</p><p>1）配置隔离规则，选择 feign 接口后面的流控按钮</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173029388.png" alt="image-20220521173029388"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173038565.png" alt="image-20220521173038565"></p><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p><p>断路器控制熔断和放行是通过状态机来完成的，如下图就是一个断路器的状态机</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173059233.png" alt="image-20220521173059233"></p><p>状态机包括三个状态</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。会去判断是否达到熔断条件，这一步我们叫做「熔断策略」，达到该条件则切换到 open 状态，打开断路器。</li><li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open 状态 5 秒后会进入 half-open 状态。</li><li>half-open：半开状态，会一段时间放行一次请求，根据执行结果来判断接下来的操作。请求成功：则切换到 closed 状态；请求失败：则切换到 open 状态。</li></ul><p>断路器熔断策略有三种：慢调用、异常比例、异常数</p><h4 id="慢调用"><a href="#慢调用" class="headerlink" title="慢调用"></a>慢调用</h4><p>业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p><p>例如下图，设置 RT 超过 500ms 的调用是慢调用，统计最近 10000ms 内的请求，如果请求量超过 10 次，并且慢调用比例不低于 0.5，则触发熔断，熔断时长为 5s，然后进入 half-open 状态，放行一次请求做测试。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173115082.png" alt="image-20220521173115082"></p><p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，慢调用的 RT 阈值为 50ms，统计时间为 1s ，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s；</p><p>1）设置慢调用</p><p>修改 user-service 中的 /user/{id} 这个接口的业务。通过休眠模拟一个延迟时间。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173127987.png" alt="image-20220521173127987"></p><p>2）设置熔断规则</p><p>下面，给 feign 接口设置降级规则，超过 50ms 的请求都会被认为是慢请求。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173148541.png" alt="image-20220521173148541"></p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p><p>例如，异常比例设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 0.4，则触发熔断。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173223974.png" alt="image-20220521173223974"></p><p>异常数设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 2 次，则触发熔断。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173239882.png" alt="image-20220521173239882"></p><p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，统计时间为 1s，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s</p><p>1）设置异常请求</p><p>首先，修改 user-service 中的 /user/{id} 这个接口的业务。手动抛出异常，以触发异常比例的熔断，也就是说，id 为 2时，就会触发异常。</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173259839.png" alt="image-20220521173259839"></p><p>2）设置熔断规则</p><p>在 5 次请求中，只要异常比例超过 0.4，也就是有 2 次以上的异常，就会触发熔断。            </p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173314778.png" alt="image-20220521173314778"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;h2 id=&quot;单体架构&quot;&gt;&lt;a href=&quot;#单体架构&quot; class=&quot;headerlink&quot; title=&quot;单体架构&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JMeter压力测试</title>
    <link href="http://example.com/2022/05/29/Jemeter/"/>
    <id>http://example.com/2022/05/29/Jemeter/</id>
    <published>2022-05-29T14:06:13.704Z</published>
    <updated>2022-05-29T14:27:05.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><a id="more"></a><p>JMeter 依赖于JDK，所以必须确保当前计算机上已经安装了 JDK，并且配置了环境变量。</p><p>Apache Jmeter官网下载，地址：<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182402429.png" alt="image-20220520182402429"></p><p>解压缩即可使用，目录结构如下</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182426302.png" alt="image-20220520182426302"></p><p>其中的 bin 目录就是执行的脚本，其中包含启动脚本</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182445106.png" alt="image-20220520182445106"></p><p>双击即可运行，但是有两点注意</p><ul><li>启动时速度比较慢，要耐心等待。</li><li>启动后终端（黑窗口）不能关闭，否则 JMeter 也跟着关闭。</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182502234.png" alt="image-20220520182502234"></p><h2 id="修改中文"><a href="#修改中文" class="headerlink" title="修改中文"></a>修改中文</h2><p>默认 JMeter 的语言是英文，需要设置</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182516753.png" alt="image-20220520182516753"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182538054.png" alt="image-20220520182538054"></p><p>上面的配置只能保证本次运行是中文，如果要永久中文，需要修改 JMeter 的配置文件。</p><p>打开 JMeter 文件夹，在 bin 目录中找到 <strong>jmeter.properties</strong>，添加下面配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">language</span>=<span class="hljs-string">zh_CN</span><br></code></pre></td></tr></table></figure><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182555036.png" alt="image-20220520182555036"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在测试计划上点鼠标右键，选择「添加 &gt; 线程（用户） &gt; 线程组」</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182612199.png" alt="image-20220520182612199"></p><p>在新增的线程组中，填写线程信息</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182622262.png" alt="image-20220520182622262"></p><p>在线程组这里点鼠标右键，添加 http 请求</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182635810.png" alt="image-20220520182635810"></p><p>编写取样器内容</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182646501.png" alt="image-20220520182646501"></p><p>添加监听报告</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182658504.png" alt="image-20220520182658504"></p><p>汇总报告结果</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182716297.png" alt="image-20220520182716297"></p><p>添加监听结果树</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182815816.png" alt="image-20220520182815816"></p><p>察看结果树</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520182731253.png" alt="image-20220520182731253"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装启动&quot;&gt;&lt;a href=&quot;#安装启动&quot; class=&quot;headerlink&quot; title=&quot;安装启动&quot;&gt;&lt;/a&gt;安装启动&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用优先队列实现对hashmap的排序</title>
    <link href="http://example.com/2022/05/29/%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AF%B9hashmap%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/05/29/%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AF%B9hashmap%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2022-05-29T14:05:56.672Z</published>
    <updated>2022-07-06T17:43:11.576Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="根据hashmap的value值进行排序"><a href="#根据hashmap的value值进行排序" class="headerlink" title="根据hashmap的value值进行排序"></a>根据hashmap的value值进行排序</h1><blockquote><p>在一些场景下，我们使用hashmap进行统计，然后根据hashmap中value的值进行排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-comment">//模拟数据</span><br>        map.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>);<br>        map.put(<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-number">6</span>);<br>        map.put(<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-number">5</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//创建优先队列并设置排序规则， </span><br>        PriorityQueue&lt;Map.Entry&lt;String,Integer&gt;&gt;  queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((e1,e2) -&gt;  e2.getValue() - e1.getValue());<br>        <br>        <span class="hljs-comment">//将map的Entry加入到优先队列中</span><br>        queue.addAll(map.entrySet());<br><span class="hljs-comment">//获取到优先队列的长度，由于下面使用poll来拿到栈顶元素，使用poll方法后长度会减1，因此循环次数需要固定</span><br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <br>        <span class="hljs-comment">//优先队列使用堆来维护的，因此不能够直接遍历优先队列，你会发现直接遍历取出来的值不一定是按顺序</span><br>        <span class="hljs-comment">//这里需要使用取出栈顶元素，取出一个元素后，优先队列会自动维护堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            System.out.println(queue.poll());<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="根据hashmap的key值进行排序"><a href="#根据hashmap的key值进行排序" class="headerlink" title="根据hashmap的key值进行排序"></a>根据hashmap的key值进行排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        HashMap&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        map.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>);<br>        map.put(<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-number">6</span>);<br>        map.put(<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-number">5</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//和上面不同的是这里排序规则是比较key的</span><br>        PriorityQueue&lt;Map.Entry&lt;String,Integer&gt;&gt;  queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((e1,e2) -&gt;  e1.getKey().compareTo(e2.getKey()));<br>        queue.addAll(map.entrySet());<br><br>        <span class="hljs-keyword">int</span> size = queue.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            System.out.println(queue.poll());<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;根据hashmap的value值进行排序&quot;&gt;&lt;a href=&quot;#根据hashmap的value值进行排序&quot; class=&quot;headerlink&quot; title=&quot;根据hashmap的value值进行排序&quot;&gt;&lt;/a&gt;根据hashm</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EasyExcel处理Excel</title>
    <link href="http://example.com/2022/05/29/EasyExcel%E5%A4%84%E7%90%86Excel/"/>
    <id>http://example.com/2022/05/29/EasyExcel%E5%A4%84%E7%90%86Excel/</id>
    <published>2022-05-29T14:05:41.457Z</published>
    <updated>2022-05-29T14:26:47.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现写操作"><a href="#实现写操作" class="headerlink" title="实现写操作"></a>实现写操作</h1><a id="more"></a><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于easyexcel是对poi的一个封装，因此低版本的还需要引入poi的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoData</span> </span>&#123;<br><br>    <span class="hljs-comment">//设置exccel表头名称，使用@ExcelProperty注解</span><br><br>    <span class="hljs-meta">@ExcelProperty(&quot;学生编号&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer sno;<br><br>    <span class="hljs-meta">@ExcelProperty(&quot;学生姓名&quot;)</span><br>    <span class="hljs-keyword">private</span> String sname;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现写操作-1"><a href="#实现写操作-1" class="headerlink" title="实现写操作"></a>实现写操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.EasyExcel;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEasyExcel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//实现excel写操作</span><br><br>        <span class="hljs-comment">//1.设置写入文件地址和名称</span><br>        String filename = <span class="hljs-string">&quot;F:\\write.xlsx&quot;</span>;<br><br>        <span class="hljs-comment">//2.调用easyexcal</span><br>        <span class="hljs-comment">//write方法中两个参数：第一个参数文件路径名称，第二个参数文件实体类class</span><br>        <span class="hljs-comment">//sheet是excel表格底下的分类</span><br>        <span class="hljs-comment">//dowrite需要传入一个列表</span><br>        EasyExcel.write(filename,DemoData.class).sheet(&quot;学生列表<span class="hljs-number">1</span><span class="hljs-string">&quot;).doWrite(getData());</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    private static List&lt;DemoData&gt; getData()&#123;</span><br><span class="hljs-string">        List&lt;DemoData&gt; list = new ArrayList&lt;&gt;();</span><br><span class="hljs-string">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="hljs-string">            DemoData data = new DemoData();</span><br><span class="hljs-string">            data.setSno(i);</span><br><span class="hljs-string">            data.setSname(&quot;</span>lucy<span class="hljs-string">&quot;+i);</span><br><span class="hljs-string">            list.add(data);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        return  list;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>sheet就是这个</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220422141638360.png" alt="image-20220422141638360"></p><h1 id="实现读操作"><a href="#实现读操作" class="headerlink" title="实现读操作"></a>实现读操作</h1><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoData1</span> </span>&#123;<br><br>    <span class="hljs-comment">//表示sno对应的是excel表格中的第一列</span><br>    <span class="hljs-meta">@ExcelProperty(index = 0)</span><br>    <span class="hljs-keyword">private</span> Integer sno;<br><br>    <span class="hljs-meta">@ExcelProperty(index = 1)</span><br>    <span class="hljs-keyword">private</span> String sname;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//继承AnalysisEventListener类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnalysisEventListener</span>&lt;<span class="hljs-title">DemoData1</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">//一行一行的读取excel的内容</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(DemoData1 demoData1, AnalysisContext analysisContext)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;内容&quot;</span>+demoData1);<br>    &#125;<br><br>    <span class="hljs-comment">//读取表头</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeHeadMap</span><span class="hljs-params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;表头&quot;</span>+headMap);<br>    &#125;<br><br>    <span class="hljs-comment">//读取完成之后执行的操作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext analysisContext)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.excel.EasyExcel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEasyExcel1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//定义读取的文件的路径</span><br>        String filename = <span class="hljs-string">&quot;F:\\write.xlsx&quot;</span>;<br><br>        <span class="hljs-comment">//第一个参数是文件路径名</span><br>        <span class="hljs-comment">//第二个是实体类的类信息</span><br>        <span class="hljs-comment">//第三个是监听器</span><br>        EasyExcel.read(filename,DemoData1.class,<span class="hljs-keyword">new</span> ExcelListener()).sheet().doRead();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;实现写操作&quot;&gt;&lt;a href=&quot;#实现写操作&quot; class=&quot;headerlink&quot; title=&quot;实现写操作&quot;&gt;&lt;/a&gt;实现写操作&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mapperLocations属性通配符的使用</title>
    <link href="http://example.com/2022/05/29/mapperLocations%E5%B1%9E%E6%80%A7%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/05/29/mapperLocations%E5%B1%9E%E6%80%A7%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-05-29T14:05:06.876Z</published>
    <updated>2022-05-29T14:05:03.221Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>示例：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">mybatis:<br>  mapper-locations:<br>    - classpath:mapper/*.xml<br>    - classpath*:com/**/mapper/*.xml<br></code></pre></td></tr></table></figure><p>*<em>注意：在classpath后面的</em>必不可少，缺少型号的话后面的通配符不起作用。**</p><p>** 可以表示任意多级目录，如上述文件可以查到 ：[com/pty/mall/tiny/mapper/PmsBrandMapper.xml]</p><p>*表示多个任意字符</p><p>缺少classpath后面的*会报一下错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: <br>### Error querying database.  Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for framework.system.dao.UserDao.getNextUserId_MySQL<br>### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for framework.system.dao.UserDao.getNextUserId_MySQL<br>at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:<span class="hljs-number">75</span>)<br>at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:<span class="hljs-number">371</span>)<br>at com.sun.proxy.$Proxy18.selectOne(Unknown Source)<br>at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:<span class="hljs-number">163</span>)<br>at com.huaxin.framework.core.dao.impl.BaseDaoImpl.selectOne(BaseDaoImpl.java:<span class="hljs-number">298</span>)<br>at com.huaxin.framework.system.dao.impl.UserDaoImpl.getNextUserId(UserDaoImpl.java:<span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis黑马</title>
    <link href="http://example.com/2022/05/29/redis%20%E9%BB%91%E9%A9%AC/"/>
    <id>http://example.com/2022/05/29/redis%20%E9%BB%91%E9%A9%AC/</id>
    <published>2022-05-29T14:02:56.038Z</published>
    <updated>2022-05-30T01:16:37.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><a id="more"></a><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String命名方式"><a href="#String命名方式" class="headerlink" title="String命名方式"></a>String命名方式</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305145240506.png" alt="image-20220305145240506"></p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305145458174.png" alt="image-20220305145458174"></p><p><img src="/.com//blog\java复习\image-20220305150210040.png" alt="image-20220305150210040"></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305153327413.png" alt="image-20220305153327413"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305154418649.png" alt="image-20220305154418649"></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305155510456.png" alt="image-20220305155510456"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305160246063.png" alt=" "></p><p><strong>==用于随机推送==</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305160742714.png" alt="image-20220305160742714"></p><h3 id="sorted-set-zset"><a href="#sorted-set-zset" class="headerlink" title="sorted_set(zset)"></a>sorted_set(zset)</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305162453500.png" alt="image-20220305162453500"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305162845435.png" alt="image-20220305162845435"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305163730760.png" alt="image-20220305163730760"></p><p><strong>做排行榜</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305170913560.png" alt="image-20220305170913560"></p><h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="bitmaps"><a href="#bitmaps" class="headerlink" title="bitmaps"></a>bitmaps</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305215551318.png" alt="image-20220305215551318"></p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p><strong>应用场景：在统计访问量的时候，一个人多次访问一个网站，还是算作一个人。这个时候就需要统计基数。</strong></p><p>==占用的内存是固定的，2^64个不同元素的基数，只需要12kb的内存。==</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306102643155.png" alt="image-20220306102643155"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306102839532.png" alt="image-20220306102839532"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306103049254.png" alt="image-20220306103049254"></p><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p><strong>只能计算水平，不能计算垂直距离，如果你在山下，他在山上，可能距离只有几百米。</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306103528145.png" alt="image-20220306103528145"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306103748591.png" alt="image-20220306103748591"></p><h2 id="服务器的配置"><a href="#服务器的配置" class="headerlink" title="服务器的配置"></a>服务器的配置</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305214048604.png" alt="image-20220305214048604"></p><p><strong>日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频率</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305214235538.png" alt="image-20220305214235538"></p><p>单位是秒</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305214350250.png" alt="image-20220305214350250"></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305174451622.png" alt="image-20220305174451622"></p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="save指令"><a href="#save指令" class="headerlink" title="save指令"></a>save指令</h4><p>使用<code>save</code>命令手动执行保存操作，会生成一个叫<code>dump.rdb</code>的文件来保存快照信息</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305174849937.png" alt="image-20220305174849937"></p><p><strong><code>save</code>指令的执行会阻塞当前redis服务器，知道当前rdb过程完成为止，有可能会造成上时间阻塞，线上环境不建议使用</strong></p><h4 id="bgsave指令"><a href="#bgsave指令" class="headerlink" title="bgsave指令"></a>bgsave指令</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305175814214.png" alt="image-20220305175814214"></p><p>提交保存命令，有服务器后台决定什么时候保存，不是马上保存</p><h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180017057.png" alt="image-20220305180017057"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180026755.png" alt="image-20220305180026755"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180600421.png" alt="image-20220305180600421"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305180951059.png" alt="image-20220305180951059"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181055702.png" alt="image-20220305181055702"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181326611.png" alt="image-20220305181326611"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181842686.png" alt="image-20220305181842686"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305181941904.png" alt="image-20220305181941904"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305182455183.png" alt="image-20220305182455183"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305182937777.png" alt="image-20220305182937777"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305183043020.png" alt="image-20220305183043020"></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305183124698.png" alt="image-20220305183124698"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305183517150.png" alt="image-20220305183517150"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305203544777.png" alt="image-20220305203544777"></p><p><strong>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305203944796.png" alt="image-20220305203944796"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305204337363.png" alt="image-20220305204337363"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305204549831.png" alt="image-20220305204549831"></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305204811840.png" alt="image-20220305204811840"></p><p><strong>在事务之前添加watch，不能在开启事务之后再添加watch</strong></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305205411064.png" alt="image-20220305205411064"></p><p><strong>必须锁同一个对象</strong></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305205943153.png" alt="image-20220305205943153"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305210015123.png" alt="image-20220305210015123"></p><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p><strong>过期数据：</strong>设置了有效期但是已经超时的数据</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305211027639.png" alt="image-20220305211027639"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305211205516.png" alt="image-20220305211205516"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212158883.png" alt="image-20220305212158883"></p><p><img src="/.com//blog\java复习\image-20220305212252768.png" alt="image-20220305212252768"></p><p><strong>redis内部使用了惰性删除和定期删除</strong></p><h3 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212527850.png" alt="image-20220305212527850"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212626026.png" alt="image-20220305212626026"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305212931160.png" alt="image-20220305212931160"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220305213138141.png" alt=" "></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306104858862.png" alt="image-20220306104858862"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306105058615.png" alt="image-20220306105058615"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306105153719.png" alt="image-20220306105153719"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306105912646.png" alt="image-20220306105912646"></p><h3 id="主从复制的工作流程"><a href="#主从复制的工作流程" class="headerlink" title="主从复制的工作流程"></a>主从复制的工作流程</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306110202558.png" alt="image-20220306110202558"></p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306110504327.png" alt="image-20220306110504327"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306111313162.png" alt="image-20220306111313162"></p><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306111841231.png" alt="image-20220306111841231"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306112310778.png" alt="image-20220306112310778"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306112547878.png" alt="image-20220306112547878"></p><h4 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h4><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306112817915.png" alt="image-20220306112817915"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113039939.png" alt="image-20220306113039939"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113445015.png" alt="image-20220306113445015"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113621935.png" alt="image-20220306113621935"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306113656411.png" alt="image-20220306113656411"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306114227118.png" alt="image-20220306114227118"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306114520969.png" alt="image-20220306114520969"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306114806850.png" alt="image-20220306114806850"></p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306120410301.png" alt="image-20220306120410301"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306120502893.png" alt="image-20220306120502893"></p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306153648226.png" alt="image-20220306153648226"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154156940.png" alt="image-20220306154156940"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306154218457.png" alt="image-20220306154218457"></p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306155730705.png" alt="image-20220306155730705"></p><p><strong>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统，避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</strong></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160005562.png" alt="image-20220306160005562"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160056409.png" alt="image-20220306160056409"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160221880.png" alt="image-20220306160221880"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160330647.png" alt="image-20220306160330466"></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160852994.png" alt="image-20220306160852994"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160922045.png" alt="image-20220306160922045"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306160958459.png" alt="image-20220306160958459"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161158132.png" alt="image-20220306161158132"></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161223740.png" alt="image-20220306161223740"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161306116.png" alt="image-20220306161306116"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161347227.png" alt="image-20220306161347227"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161425855.png" alt="image-20220306161425855"></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220306161809827.png" alt="image-20220306161809827"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基础数据类型&quot;&gt;&lt;a href=&quot;#基础数据类型&quot; class=&quot;headerlink&quot; title=&quot;基础数据类型&quot;&gt;&lt;/a&gt;基础数据类型&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>redis配置</title>
    <link href="http://example.com/2022/05/29/redis%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/05/29/redis%E9%85%8D%E7%BD%AE/</id>
    <published>2022-05-29T14:02:19.133Z</published>
    <updated>2022-05-30T07:59:43.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 修改触发生成RDB文件的条件,表示900s内有一个key被就修改，就执行bgsave，如果是save &quot;&quot; 表示禁用RDB<br>save 900 1<br>save 300 10<br>save 60 10000<br><br>#RDB文件名称<br>dbfilename dump.rdb<br><br>#rdb文件保存的目录,默认当前目录<br>dir ./<br><br>#是否压缩，建议不开启，压缩会消耗cpu<br>rdbcompression yes<br></code></pre></td></tr></table></figure><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">#是否开启AOF功能，默认是no<br>appendonly yes<br><br>#AOF文件的名称<br>appendfilename &quot;appendonly.aof&quot;<br><br>#表示每执行一次写命令，立即记录到AOF文件<br>appendfsync always<br><br># 写命令执行完先放入aof缓冲区，每隔一秒将缓冲区文件写入到aof文件，默认方案<br>appendfsync everysec<br><br>#写命令执行完先放入aof缓冲区，由系统决定何时将缓冲区内容写回磁盘<br>appendfsync no<br><br>#AOF文件比上次文件增长超过多少百分比则触发重写<br>auto-aof-rewrite-percentage 100<br><br>#aof文件体积最小多大以上才触发重写<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure><h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><blockquote><p>本次实验准备3个实例，1主2从,主从需要开启rdb</p></blockquote><p>先创建3个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入/tmp目录</span><br>cd /tmp<br><span class="hljs-meta">#</span><span class="bash"> 创建目录</span><br>mkdir 7001 7002 7003<br></code></pre></td></tr></table></figure><p>将redis.conf文件复制到这三个目录,前提是先将redis-6.2.4也放到当前目录，否则需要修改下redis的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 方式一：逐个拷贝</span><br>cp redis-6.2.4/redis.conf 7001<br>cp redis-6.2.4/redis.conf 7002<br>cp redis-6.2.4/redis.conf 7003<br><br><span class="hljs-meta">#</span><span class="bash"> 方式二：管道组合命令，一键拷贝</span><br>echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf<br></code></pre></td></tr></table></figure><p>修改3个实例的端口号和RDB文件保存的地址,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i -e &#x27;s/6379/7001/g&#x27; -e &#x27;s/dir .\//dir \/tmp\/7001\//g&#x27; 7001/redis.conf<br>sed -i -e &#x27;s/6379/7002/g&#x27; -e &#x27;s/dir .\//dir \/tmp\/7002\//g&#x27; 7002/redis.conf<br>sed -i -e &#x27;s/6379/7003/g&#x27; -e &#x27;s/dir .\//dir \/tmp\/7003\//g&#x27; 7003/redis.conf<br></code></pre></td></tr></table></figure><p>修改每个实例的ip信息，如果不是虚拟机，可以不做这个操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 逐一执行</span><br>sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7001/redis.conf<br>sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7002/redis.conf<br>sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7003/redis.conf<br><span class="hljs-meta">#</span><span class="bash"> 或者一键修改</span><br>printf &#x27;%s\n&#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第1个</span><br>redis-server 7001/redis.conf<br><span class="hljs-meta">#</span><span class="bash"> 第2个</span><br>redis-server 7002/redis.conf<br><span class="hljs-meta">#</span><span class="bash"> 第3个</span><br>redis-server 7003/redis.conf<br></code></pre></td></tr></table></figure><h2 id="开启主从"><a href="#开启主从" class="headerlink" title="开启主从"></a>开启主从</h2><p>在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">slaveof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>通过redis-cli命令连接7002，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 连接 7002</span><br>redis-cli -p 7002<br><span class="hljs-meta">#</span><span class="bash"> 执行slaveof</span><br>slaveof 192.168.150.101 7001<br></code></pre></td></tr></table></figure><p>其他结点操作一样。</p><p><strong>在主节点中使用info replication 可以查看从节点的状态</strong></p><h1 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h1><blockquote><p>哨兵可以实现监控、故障转移、通知等功能</p><p>配置3个哨兵结点</p></blockquote><h2 id="创建实例-1"><a href="#创建实例-1" class="headerlink" title="创建实例"></a>创建实例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入/tmp目录</span><br>cd /tmp<br><span class="hljs-meta">#</span><span class="bash"> 创建目录</span><br>mkdir s1 s2 s3<br></code></pre></td></tr></table></figure><p>在s1 s2 s3目录里面创建sentinel.conf文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini">port 27001<br>sentinel announce-ip 192.168.217.4<br>sentinel monitor mymaster 192.168.217.4 2<br>sentinel down-after-milliseconds mymaster 5000<br>sentinel failover-timeout mymaster 60000<br>dir &quot;/tmp/s1&quot;<br></code></pre></td></tr></table></figure><p>解读：</p><ul><li><p><code>port 27001</code>：是当前sentinel实例的端口</p></li><li><pre><code>sentinel monitor mymaster 192.168.150.101 7001 2<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br>  ：指定主节点信息<br><br>  - `mymaster`：主节点名称，自定义，任意写<br>  - `<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">150</span>.<span class="hljs-number">101</span> <span class="hljs-number">7001</span>`：主节点的<span class="hljs-built_in">ip</span>和端口<br>  - `<span class="hljs-number">2</span>`：选举master时的quorum值<br><br>然后将<span class="hljs-built_in">s1</span>/sentinel.conf文件拷贝到<span class="hljs-built_in">s2</span>、<span class="hljs-built_in">s3</span>两个目录中（在/tmp目录执行下列命令）：<br><br>```sh<br><span class="hljs-comment"># 方式一：逐个拷贝</span><br><span class="hljs-symbol">cp</span> <span class="hljs-built_in">s1</span>/sentinel.conf <span class="hljs-built_in">s2</span><br><span class="hljs-symbol">cp</span> <span class="hljs-built_in">s1</span>/sentinel.conf <span class="hljs-built_in">s3</span><br><span class="hljs-comment"># 方式二：管道组合命令，一键拷贝</span><br><span class="hljs-symbol">echo</span> <span class="hljs-built_in">s2</span> <span class="hljs-built_in">s3</span> <span class="hljs-title">| xargs -t -n 1 cp s1/sentinel.conf</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf<br>sed -i -e <span class="hljs-string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="hljs-string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf<br></code></pre></td></tr></table></figure><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第1个</span><br>redis-sentinel s1/sentinel.conf<br><span class="hljs-meta">#</span><span class="bash"> 第2个</span><br>redis-sentinel s2/sentinel.conf<br><span class="hljs-meta">#</span><span class="bash"> 第3个</span><br>redis-sentinel s3/sentinel.conf<br></code></pre></td></tr></table></figure><h2 id="springboot整合哨兵集群"><a href="#springboot整合哨兵集群" class="headerlink" title="springboot整合哨兵集群"></a>springboot整合哨兵集群</h2><p>引入redis的starter依赖</p><p>配置yml文件，<strong>只需要配置哨兵集群的信息，不需要配置redis实例的信息，因为客户端是通过找哨兵结点，然后获取实例的地址，这样当发生故障转移的时候，客户端仍然知道需要去哪里获取数据</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span>   <span class="hljs-comment"># 指定master名称</span><br>      <span class="hljs-attr">nodes:</span>   <span class="hljs-comment">#指定redis-sentinel集群信息</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:27001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:27002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:27003</span><br></code></pre></td></tr></table></figure><p>配置读写分离</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220518161857091.png" alt="image-20220518161857091"></p><h1 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h1><blockquote><p>主从和哨兵可以解决高可用、高并发读的问题，但是仍然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul></blockquote><p>分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave结点</li><li>master之前通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确结点</li></ul><h2 id="创建实例-2"><a href="#创建实例-2" class="headerlink" title="创建实例"></a>创建实例</h2><blockquote><p>此处创建6个实例，7001 7002 7003为master，8001 8002 8003为slave</p></blockquote><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建目录</span><br>mkdir 7001 7002 7003 8001 8002 8003<br></code></pre></td></tr></table></figure><p>自己创建一个新的redis.conf文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ini">port 6379<br><span class="hljs-comment"># 开启集群功能</span><br>cluster-enabled yes<br><span class="hljs-comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span><br>cluster-config-file /tmp/6379/nodes.conf<br><span class="hljs-comment"># 节点心跳失败的超时时间</span><br>cluster-node-timeout 5000<br><span class="hljs-comment"># 持久化文件存放目录</span><br>dir /tmp/6379<br><span class="hljs-comment"># 绑定地址</span><br>bind 0.0.0.0<br><span class="hljs-comment"># 让redis后台运行</span><br>daemonize yes<br><span class="hljs-comment"># 注册的实例ip</span><br>replica-announce-ip 192.168.217.4<br><span class="hljs-comment"># 保护模式</span><br>protected-mode no<br><span class="hljs-comment"># 数据库数量</span><br>databases 1<br><span class="hljs-comment"># 日志</span><br>logfile /tmp/6379/run.log<br></code></pre></td></tr></table></figure><p>将文件拷贝到每个目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入/tmp目录</span><br><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-comment"># 执行拷贝</span><br><span class="hljs-built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf<br></code></pre></td></tr></table></figure><p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改配置文件</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="hljs-string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure><h2 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h2><p>因为配置了后台启动，所以可以直接启动服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 一键启动所有服务</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf<br></code></pre></td></tr></table></figure><p>如果要关闭所有进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">printf</span> <span class="hljs-string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown<br></code></pre></td></tr></table></figure><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><blockquote><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联,我们需要执行命令来创建集群.</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster create --cluster-replicas 1 192.168.217.4:7001 192.168.217.4:7002 192.168.217.4:7003 192.168.217.4:8001 192.168.217.4:8002 192.168.217.4:8003<br></code></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</li><li><code>create</code>：代表是创建集群</li><li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220518165636805.png" alt="image-20220518165636805"></p><p>通过命令可以查看集群状态：<code>redis-cli -p 7001 cluster nodes</code>,端口可以是集群中的任意一个结点</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220518165535210.png" alt="image-20220518165535210"></p><h2 id="给集群添加一个结点"><a href="#给集群添加一个结点" class="headerlink" title="给集群添加一个结点"></a>给集群添加一个结点</h2><p>重新创建一个实例，然后将集群的配置文件放到目录下，修改好路径，启动实例。</p><p>使用<code>redis-cli --cluster add-node 要添加结点的ip端口号  集群中任意一个结点ip端口号</code>将结点添加到集群中。</p><h2 id="分配插槽"><a href="#分配插槽" class="headerlink" title="分配插槽"></a>分配插槽</h2><p>使用<code>redis-cli --cluster reshard 集群任意一个ip端口</code>分配插槽，根据提示信息即可完成</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>master宕机后，会自动完成故障转移。</p><p>在一个slave结点中，使用<code>cluster failover</code>命令可以实现手动故障转移，他的master会变成slave，他自己变成master</p><h2 id="springboot整合分片集群"><a href="#springboot整合分片集群" class="headerlink" title="springboot整合分片集群"></a>springboot整合分片集群</h2><blockquote><p>1.引入redis的starter依赖</p><p>2.配置yml文件</p><p>3.配置读写分离</p></blockquote><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">cluster:</span><br>      <span class="hljs-attr">nodes:</span>   <br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:7001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:7002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:7003</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:8001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:8002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.4</span><span class="hljs-string">:2:8003</span><br></code></pre></td></tr></table></figure><p>配置读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="hljs-title">clientConfigurationBuilderCustomizer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h1&gt;&lt;h2 id=&quot;RDB&quot;&gt;&lt;a href=&quot;#RDB&quot; class=&quot;headerlink&quot; title=&quot;RDB&quot;&gt;&lt;/a&gt;RDB&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/2022/05/29/docker%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/29/docker%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-29T13:57:52.350Z</published>
    <updated>2022-08-12T14:47:09.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li>docker pull：拉取镜像</li><li>docker images：查看安装的镜像</li><li>docker rmi：删除镜像</li><li>docker push：推送镜像到远程服务器</li><li>docker save ：将镜像导出到磁盘    <code>docker save -o nginx.tar nginx:latest</code>   将nginx:latest 镜像导出到磁盘,文件名叫nginx.tar</li><li>docker load：将本地文件加载进docker <code>docker load -i nginx.tar</code>   将nginx.tar 加载进docker</li></ul><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><ul><li>docker run：创建并运行容器<ul><li><code>docker run --name mn-p 80:80 -d nginx</code></li><li>– name：给容器起一个名字</li><li>-p 端口映射，左边是宿主机端口，右边是容器端口</li><li>-d 后台运行容器</li><li>nginx 镜像名称</li></ul></li><li>docker pause: 让容器从运行到暂停</li><li>docker unpause： 从暂停到运行</li><li>docker start：从停止到运行</li><li>docker stop：容器从运行到停止</li><li>docker ps：查看所有运行的容器及状态<ul><li>-a：可以看到被停止的容器信息</li></ul></li><li>docker logs：查看容器运行的日志<ul><li>-f  持续查看日志，和linux中的tail一样，会显示最新的日志</li></ul></li><li>docker exec：进入容器执行命令<ul><li><code>docker exec -it mn bash</code></li><li>-it：给当前进入的容器创建一个标准输入输出端，允许我们与容器交互</li><li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li></ul></li><li>docker rm：删除指定容器<ul><li>-f：强制删除容器</li></ul></li><li>docker cp 容器名称 容器内路径 宿主机路径 ：复制容器内的文件到宿主机上</li><li>docker export 容器名称 &gt; 名称.tar：将容器导出为一个tar归档文件</li><li>cat 名称.tar | docker import -镜像用户/镜像名:镜像版本号: 从tar包中的内容创建一个新的文件系统再导入为镜像</li></ul><h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><ul><li>docker volume create： 创建数据卷</li><li>docker volume ls： 查看所有数据卷</li><li>docker volume inspact：查看某个数据卷具体信息，mountpoint为挂载点</li><li>docker volume rm：删除某个指定的数据卷</li><li>docker volume prune：删除没使用的数据卷</li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220504221503531.png" alt="image-20220504221503531"></p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote><p>docker compose 可以基于compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容易</p><p>compose文件是一个文本文件，通过指定定义集群中的每个容器如何运行</p></blockquote><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220505210454160.png" alt="image-20220505210454160"></p><h1 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>我安装的是7.6.2版本，可以到<code>hub.docker.com</code>上查看支持的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull elasticsearch:7.6.2<br></code></pre></td></tr></table></figure><h2 id="启动Elasticsearch"><a href="#启动Elasticsearch" class="headerlink" title="启动Elasticsearch"></a>启动Elasticsearch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name elascticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; -e &quot;discover.type=single-node&quot; elasticsearch:7.6.2<br></code></pre></td></tr></table></figure><ul><li>9300端口是使用tcp客户端连接使用的端口；9200端口是通过http协议连接es使用的端口；</li><li>-e ES_JAVA_OPTS=”-Xms64m -Xmx512m” 是配置内存大小，如果不配置，我的虚拟机因为内存小，会变得很卡</li><li>-e “discover.type=single-node” 单节点启动</li></ul><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=9200/tcp<br></code></pre></td></tr></table></figure><h1 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h1><h2 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>kibana和Elasticsearch的关系类似于navicat和mysql的关系。kibana可以查看Elasticsearch中的数据，并且提供一些语法提示。</p><p><strong>安装的kibana版本需要和Elasticsearch的版本一致</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull kibana:7.6.2<br></code></pre></td></tr></table></figure><h2 id="启动kibana"><a href="#启动kibana" class="headerlink" title="启动kibana"></a>启动kibana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name kibana -p 5601:5601 kibana:7.6.2<br></code></pre></td></tr></table></figure><h2 id="将kibana和Elasticsearch进行关联"><a href="#将kibana和Elasticsearch进行关联" class="headerlink" title="将kibana和Elasticsearch进行关联"></a>将kibana和Elasticsearch进行关联</h2><p>由于kibana和elasticsearch是运行在docker中的，因此两个之间是相互独立的，没有关联，由于Elasticsearch的9200端口和宿主机的9200端口进行了映射，因此我们可以通过宿主机的9200找到Elasticsearch。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入kibana</span><br>docker exec -it kibana:7.6.2<br><br><span class="hljs-meta">#</span><span class="bash">进入config文件夹</span><br>cd config<br><br><span class="hljs-meta">#</span><span class="bash">修改kibana.yml,注意没有vim指令</span><br>vi kibana.yml<br><span class="hljs-meta">#</span><span class="bash">将elasticsearch.hosts 修改为当前的主机号和端口号</span><br>elasticsearch.hosts: [ &quot;http://192.168.217.4:9200&quot; ]<br></code></pre></td></tr></table></figure><h2 id="重启kibana"><a href="#重启kibana" class="headerlink" title="重启kibana"></a>重启kibana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart kibana<br></code></pre></td></tr></table></figure><h2 id="开放端口-1"><a href="#开放端口-1" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent --add-port=5601/tcp<br></code></pre></td></tr></table></figure><h1 id="一键启动kibana和Elasticsearch"><a href="#一键启动kibana和Elasticsearch" class="headerlink" title="一键启动kibana和Elasticsearch"></a>一键启动kibana和Elasticsearch</h1><h2 id="编写composs"><a href="#编写composs" class="headerlink" title="编写composs"></a>编写composs</h2><p>当我们重新启动一个kibana的容器，都需要重新将他与elasticsearch关联起来。</p><p>同时两个服务也是需要一同启动的因此我们编写一个compose，同时启动两个服务，并且写好配置，将kibana的kibana.yml与宿主机的配置文件进行关联，这样就不需要每次都修改kibana内部的文件。</p><h3 id="复制kibana配置文件"><a href="#复制kibana配置文件" class="headerlink" title="复制kibana配置文件"></a>复制kibana配置文件</h3><p>将配置文件复制到宿主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">创建文件夹</span><br>mkdir /opt/es-kibana<br>cd /opt/es-kibana<br><span class="hljs-meta">#</span><span class="bash">复制文件</span><br>docker cp kibana:/usr/share/kibana/config/kibana.yml /opt/es-kibana<br><span class="hljs-meta">#</span><span class="bash">修改文件内容，因为下面配置了compose，所以可以直接写网络名称</span><br>elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ]<br></code></pre></td></tr></table></figure><h3 id="编写Compose文件"><a href="#编写Compose文件" class="headerlink" title="编写Compose文件"></a>编写Compose文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">编写文件</span><br>vim docker-compose.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.3&quot;</span><span class="hljs-comment">#指定语法的版本格式</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config:</span><br>  <span class="hljs-attr">plugin:</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">es:</span><br><span class="hljs-attr">services:</span><span class="hljs-comment">#定义服务</span><br>   <span class="hljs-attr">elasticsearch:</span><span class="hljs-comment">#服务名称</span><br>     <span class="hljs-attr">image:</span> <span class="hljs-string">elasticsearch:7.6.2</span><span class="hljs-comment">#镜像</span><br>     <span class="hljs-attr">ports:</span><span class="hljs-comment">#端口映射</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9200:9200&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9300:9300&quot;</span><br>     <span class="hljs-attr">networks:</span>                                                  <span class="hljs-comment">#网络</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;es&quot;</span><br>     <span class="hljs-attr">environment:</span><span class="hljs-comment">#容器内部环境变量</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;discovery.type=single-node&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms64m -Xmx512m&quot;</span><br>     <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">data:/usr/share/elasticsearch/data</span>                    <span class="hljs-comment">#挂载数据卷</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">config:/usr/share/elasticsearch/config</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">plugin:/usr/share/elasticsearch/plugins</span><br><br>   <span class="hljs-attr">kibana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">kibana:7.6.2</span><br>    <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5601:5601&quot;</span> <br>    <span class="hljs-attr">networks:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;es&quot;</span> <br>    <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/kibana_config/kibana.yml</span><br><br></code></pre></td></tr></table></figure><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<br><br>chmod +x /usr/local/bin/docker-compose<br><br>docker-compose -v <br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在 docker-compose.yml的当前路径下</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><h1 id="docker启动mysql"><a href="#docker启动mysql" class="headerlink" title="docker启动mysql"></a>docker启动mysql</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d mysql:latest             以后台的方式运行 mysql 版本的镜像，生成一个容器。<br>    --name mysql                           容器名为 mysql<br>    -e MYSQL_ROOT_PASSWORD=123456          设置登陆密码为 123456，登陆用户为 root<br>    -p 3306:3306                           将容器内部 3306 端口映射到 主机的 3306 端口，即通过 主机的 3306 可以访问容器的 3306 端口<br>    -v /usr/mydata/mysql/log:/var/log/mysql    将容器的 日志文件夹 挂载到 主机的相应位置<br>    -v /usr/mydata/mysql/data:/var/lib/mysql   将容器的 数据文件夹 挂载到 主机的相应位置<br>    -v /usr/mydata/mysql/conf:/etc/mysql/conf.d   将容器的 自定义配置文件夹 挂载到主机的相应位置<br>    <br>【查看容器是否启动：】<br>docker ps -a<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /usr/mydata/mysql/log:/var/log/mysql -v /usr/mydata/mysql/data:/var/lib/mysql -v /usr/mydata/mysql/conf:/etc/mysql/conf.d mysql:8.0.2<br></code></pre></td></tr></table></figure><p><strong>在启动mysql的时候需要挂载数据卷，否则如果容器被删除，那么数据库中的数据将全部丢失，这是一个很严重的问题，可以使用 -v 挂载数据卷到宿主机。其次由于没有配置数据库，因此数据库的默认编码是<code>latin1</code>，这时如果插入中文数据会报错，因此我们需要修改配置。使用<code> SHOW VARIABLES LIKE &#39;character%&#39;</code>可以查看编码设置。</strong></p><p><strong>上面的命令已经挂载了数据卷，-v  ：前面的是宿主机的路径，后面是容器的路径。我们在宿主机的conf目录下创建my.cnf文件，然后将下面代码复制到my.cnf文件即可</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[client]<br>default_character_set=utf8<br>[mysqld]<br>collation_server = utf8_general_ci<br>character_set_server = utf8<br></code></pre></td></tr></table></figure><h1 id="docker安装rabbitmq"><a href="#docker安装rabbitmq" class="headerlink" title="docker安装rabbitmq"></a>docker安装rabbitmq</h1><h2 id="拉取镜像-2"><a href="#拉取镜像-2" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p><code>docker pull rabbitmq:3.8.8</code>   后面不选择版本默认是最新版</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220412175244314.png" alt="image-20220412175244314"></p><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3.8.8<br>-d 表示后台启动<br>--name 给容器起个名字，这样后面可以根据名字操作容器<br>-p 映射端口<br>rabbitmq:3.8.8 如果没写后面的版本号，会默认启动最新版，没有最新版会下载<br></code></pre></td></tr></table></figure><h2 id="开放端口-2"><a href="#开放端口-2" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --permanent -add-p=15672/tcp<br>filewall-cmd --permanent -add-p=5672/tcp<br></code></pre></td></tr></table></figure><p><strong>开放服务器5672、15672两个端口</strong></p><h2 id="安装web管理页面"><a href="#安装web管理页面" class="headerlink" title="安装web管理页面"></a>安装web管理页面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入rabbitmq容器</span><br>docker exec -it rabbitmq /bin/bash<br><span class="hljs-meta">#</span><span class="bash">启动插件</span><br>rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><p><strong>此时可以使用服务器ip:15672 进行访问，默认用户名密码都为guest</strong></p><h2 id="安装延时插件"><a href="#安装延时插件" class="headerlink" title="安装延时插件"></a>安装延时插件</h2><ol><li><p>下载插件：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">下载地址</a></p></li><li><p>将插件传输到linux系统中，我是使用xftp上传到 /opt目录下</p></li><li><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将插件拷贝到容器</span><br>docker cp /opt/rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq:/plugins   #前面是插件在linux中的地址，后面的rabbitmq是容器的名字<br><span class="hljs-meta">#</span><span class="bash"> 进入容器内部</span><br>docker exec -it rabbitmq /bin/bash  #rabbimq是容器名字<br><span class="hljs-meta">#</span><span class="bash"> 进入plugins</span><br>cd plugins<br><span class="hljs-meta">#</span><span class="bash"> 安装插件</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure></li><li><p>进入管理页面，看到type有<code>x-delayed-message</code>则成功安装延时插件</p></li></ol><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220412180709472.png" alt="image-20220412180709472"></p><h1 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h1><p><strong>首先在宿主机创建一个redis目录，然后将默认的redis.conf文件复制到该目录下。如果没有，可以使用下面提供的配置。然后修改redis.conf目录下的配置，主要修改：<code>bind</code>，注释或者改为允许连接的ip地址，一般设置为0.0.0.0；<code>requirepass</code> 设置密码；·<code>daemonize</code>修改为no，不是后台启动，否则与docker run -d 冲突。</strong></p><p><strong>然后使用下面的命令启动redis</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p6379:6379 --name redis -v /usr/mydata/redis/redis.conf:/etc/redis/redis.conf -v /us<br>r/mydata/redis/data:/data -d redis:6.2.6 redis-server /etc/redis/redis.conf<br></code></pre></td></tr></table></figure><p><code>redis-server /etc/redis/redis.conf</code>表示读取redis.conf文件启动redis，由于容器内的redis.conf文件和宿主机的关联起来，因此读取的是宿主机的配置文件。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br><span class="line">2517</span><br><span class="line">2518</span><br><span class="line">2519</span><br><span class="line">2520</span><br><span class="line">2521</span><br><span class="line">2522</span><br><span class="line">2523</span><br><span class="line">2524</span><br><span class="line">2525</span><br><span class="line">2526</span><br><span class="line">2527</span><br><span class="line">2528</span><br><span class="line">2529</span><br><span class="line">2530</span><br><span class="line">2531</span><br><span class="line">2532</span><br><span class="line">2533</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539</span><br><span class="line">2540</span><br><span class="line">2541</span><br><span class="line">2542</span><br><span class="line">2543</span><br><span class="line">2544</span><br><span class="line">2545</span><br><span class="line">2546</span><br><span class="line">2547</span><br><span class="line">2548</span><br><span class="line">2549</span><br><span class="line">2550</span><br><span class="line">2551</span><br><span class="line">2552</span><br><span class="line">2553</span><br><span class="line">2554</span><br><span class="line">2555</span><br><span class="line">2556</span><br><span class="line">2557</span><br><span class="line">2558</span><br><span class="line">2559</span><br><span class="line">2560</span><br><span class="line">2561</span><br><span class="line">2562</span><br><span class="line">2563</span><br><span class="line">2564</span><br><span class="line">2565</span><br><span class="line">2566</span><br><span class="line">2567</span><br><span class="line">2568</span><br><span class="line">2569</span><br><span class="line">2570</span><br><span class="line">2571</span><br><span class="line">2572</span><br><span class="line">2573</span><br><span class="line">2574</span><br><span class="line">2575</span><br><span class="line">2576</span><br><span class="line">2577</span><br><span class="line">2578</span><br><span class="line">2579</span><br><span class="line">2580</span><br><span class="line">2581</span><br><span class="line">2582</span><br><span class="line">2583</span><br><span class="line">2584</span><br><span class="line">2585</span><br><span class="line">2586</span><br><span class="line">2587</span><br><span class="line">2588</span><br><span class="line">2589</span><br><span class="line">2590</span><br><span class="line">2591</span><br><span class="line">2592</span><br><span class="line">2593</span><br><span class="line">2594</span><br><span class="line">2595</span><br><span class="line">2596</span><br><span class="line">2597</span><br><span class="line">2598</span><br><span class="line">2599</span><br><span class="line">2600</span><br><span class="line">2601</span><br><span class="line">2602</span><br><span class="line">2603</span><br><span class="line">2604</span><br><span class="line">2605</span><br><span class="line">2606</span><br><span class="line">2607</span><br><span class="line">2608</span><br><span class="line">2609</span><br><span class="line">2610</span><br><span class="line">2611</span><br><span class="line">2612</span><br><span class="line">2613</span><br><span class="line">2614</span><br><span class="line">2615</span><br><span class="line">2616</span><br><span class="line">2617</span><br><span class="line">2618</span><br><span class="line">2619</span><br><span class="line">2620</span><br><span class="line">2621</span><br><span class="line">2622</span><br><span class="line">2623</span><br><span class="line">2624</span><br><span class="line">2625</span><br><span class="line">2626</span><br><span class="line">2627</span><br><span class="line">2628</span><br><span class="line">2629</span><br><span class="line">2630</span><br><span class="line">2631</span><br><span class="line">2632</span><br><span class="line">2633</span><br><span class="line">2634</span><br><span class="line">2635</span><br><span class="line">2636</span><br><span class="line">2637</span><br><span class="line">2638</span><br><span class="line">2639</span><br><span class="line">2640</span><br><span class="line">2641</span><br><span class="line">2642</span><br><span class="line">2643</span><br><span class="line">2644</span><br><span class="line">2645</span><br><span class="line">2646</span><br><span class="line">2647</span><br><span class="line">2648</span><br><span class="line">2649</span><br><span class="line">2650</span><br><span class="line">2651</span><br><span class="line">2652</span><br><span class="line">2653</span><br><span class="line">2654</span><br><span class="line">2655</span><br><span class="line">2656</span><br><span class="line">2657</span><br><span class="line">2658</span><br><span class="line">2659</span><br><span class="line">2660</span><br><span class="line">2661</span><br><span class="line">2662</span><br><span class="line">2663</span><br><span class="line">2664</span><br><span class="line">2665</span><br><span class="line">2666</span><br><span class="line">2667</span><br><span class="line">2668</span><br><span class="line">2669</span><br><span class="line">2670</span><br><span class="line">2671</span><br><span class="line">2672</span><br><span class="line">2673</span><br><span class="line">2674</span><br><span class="line">2675</span><br><span class="line">2676</span><br><span class="line">2677</span><br><span class="line">2678</span><br><span class="line">2679</span><br><span class="line">2680</span><br><span class="line">2681</span><br><span class="line">2682</span><br><span class="line">2683</span><br><span class="line">2684</span><br><span class="line">2685</span><br><span class="line">2686</span><br><span class="line">2687</span><br><span class="line">2688</span><br><span class="line">2689</span><br><span class="line">2690</span><br><span class="line">2691</span><br><span class="line">2692</span><br><span class="line">2693</span><br><span class="line">2694</span><br><span class="line">2695</span><br><span class="line">2696</span><br><span class="line">2697</span><br><span class="line">2698</span><br><span class="line">2699</span><br><span class="line">2700</span><br><span class="line">2701</span><br><span class="line">2702</span><br><span class="line">2703</span><br><span class="line">2704</span><br><span class="line">2705</span><br><span class="line">2706</span><br><span class="line">2707</span><br><span class="line">2708</span><br><span class="line">2709</span><br><span class="line">2710</span><br><span class="line">2711</span><br><span class="line">2712</span><br><span class="line">2713</span><br><span class="line">2714</span><br><span class="line">2715</span><br><span class="line">2716</span><br><span class="line">2717</span><br><span class="line">2718</span><br><span class="line">2719</span><br><span class="line">2720</span><br><span class="line">2721</span><br><span class="line">2722</span><br><span class="line">2723</span><br><span class="line">2724</span><br><span class="line">2725</span><br><span class="line">2726</span><br><span class="line">2727</span><br><span class="line">2728</span><br><span class="line">2729</span><br><span class="line">2730</span><br><span class="line">2731</span><br><span class="line">2732</span><br><span class="line">2733</span><br><span class="line">2734</span><br><span class="line">2735</span><br><span class="line">2736</span><br><span class="line">2737</span><br><span class="line">2738</span><br><span class="line">2739</span><br><span class="line">2740</span><br><span class="line">2741</span><br></pre></td><td class="code"><pre><code class="hljs tex"># Redis configuration file example.<br><br>#<br><br># Note that in order to read the configuration file, Redis must be<br><br># started with the file path as first argument:<br><br>#<br><br># ./redis-server /path/to/redis.conf<br><br> <br><br># Note on units: when memory size is needed, it is possible to specify<br><br># it in the usual form of 1k 5GB 4M and so forth:<br><br>#<br><br># 1k =&gt; 1000 bytes<br><br># 1kb =&gt; 1024 bytes<br><br># 1m =&gt; 1000000 bytes<br><br># 1mb =&gt; 1024*1024 bytes<br><br># 1g =&gt; 1000000000 bytes<br><br># 1gb =&gt; 1024*1024*1024 bytes<br><br>#<br><br># units are case insensitive so 1GB 1Gb 1gB are all the same.<br><br> <br><br>################################## INCLUDES ###################################<br><br> <br><br># Include one or more other config files here.  This is useful if you<br><br># have a standard template that goes to all Redis servers but also need<br><br># to customize a few per-server settings.  Include files can include<br><br># other files, so use this wisely.<br><br>#<br><br># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;<br><br># from admin or Redis Sentinel. Since Redis always uses the last processed<br><br># line as value of a configuration directive, you&#x27;d better put includes<br><br># at the beginning of this file to avoid overwriting config change at runtime.<br><br>#<br><br># If instead you are interested in using includes to override configuration<br><br># options, it is better to use include as the last line.<br><br>#<br><br># include /path/to/local.conf<br><br># include /path/to/other.conf<br><br> <br><br>################################## MODULES #####################################<br><br> <br><br># Load modules at startup. If the server is not able to load modules<br><br># it will abort. It is possible to use multiple loadmodule directives.<br><br>#<br><br># loadmodule /path/to/my_module.so<br><br># loadmodule /path/to/other_module.so<br><br> <br><br>################################## NETWORK #####################################<br><br> <br><br># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens<br><br># for connections from all the network interfaces available on the server.<br><br># It is possible to listen to just one or multiple selected interfaces using<br><br># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.<br><br>#<br><br># Examples:<br><br>#<br><br># bind 192.168.1.100 10.0.0.1<br><br># bind 127.0.0.1 ::1<br><br>#<br><br># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the<br><br># internet, binding to all the interfaces is dangerous and will expose the<br><br># instance to everybody on the internet. So by default we uncomment the<br><br># following bind directive, that will force Redis to listen only into<br><br># the IPv4 loopback interface address (this means Redis will be able to<br><br># accept connections only from clients running into the same computer it<br><br># is running).<br><br>#<br><br># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES<br><br># JUST COMMENT THE FOLLOWING LINE.<br><br># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>#bind 127.0.0.1<br><br> <br><br># Protected mode is a layer of security protection, in order to avoid that<br><br># Redis instances left open on the internet are accessed and exploited.<br><br>#<br><br># When protected mode is on and if:<br><br>#<br><br># 1) The server is not binding explicitly to a set of addresses using the<br><br>#    &quot;bind&quot; directive.<br><br># 2) No password is configured.<br><br>#<br><br># The server only accepts connections from clients connecting from the<br><br># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain<br><br># sockets.<br><br>#<br><br># By default protected mode is enabled. You should disable it only if<br><br># you are sure you want clients from other hosts to connect to Redis<br><br># even if no authentication is configured, nor a specific set of interfaces<br><br># are explicitly listed using the &quot;bind&quot; directive.<br><br>protected-mode no<br><br> <br><br># Accept connections on the specified port, default is 6379 (IANA #815344).<br><br># If port 0 is specified Redis will not listen on a TCP socket.<br><br>port 6379<br><br> <br><br># TCP listen() backlog.<br><br>#<br><br># In high requests-per-second environments you need an high backlog in order<br><br># to avoid slow clients connections issues. Note that the Linux kernel<br><br># will silently truncate it to the value of /proc/sys/net/core/somaxconn so<br><br># make sure to raise both the value of somaxconn and tcp_max_syn_backlog<br><br># in order to get the desired effect.<br><br>tcp-backlog 511<br><br> <br><br># Unix socket.<br><br>#<br><br># Specify the path for the Unix socket that will be used to listen for<br><br># incoming connections. There is no default, so Redis will not listen<br><br># on a unix socket when not specified.<br><br>#<br><br># unixsocket /tmp/redis.sock<br><br># unixsocketperm 700<br><br> <br><br># Close the connection after a client is idle for N seconds (0 to disable)<br><br>timeout 0<br><br> <br><br># TCP keepalive.<br><br>#<br><br># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence<br><br># of communication. This is useful for two reasons:<br><br>#<br><br># 1) Detect dead peers.<br><br># 2) Take the connection alive from the point of view of network<br><br>#    equipment in the middle.<br><br>#<br><br># On Linux, the specified value (in seconds) is the period used to send ACKs.<br><br># Note that to close the connection the double of the time is needed.<br><br># On other kernels the period depends on the kernel configuration.<br><br>#<br><br># A reasonable value for this option is 300 seconds, which is the new<br><br># Redis default starting with Redis 3.2.1.<br><br>tcp-keepalive 300<br><br> <br><br>################################# GENERAL #####################################<br><br> <br><br># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.<br><br># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.<br><br>daemonize no<br><br> <br><br># If you run Redis from upstart or systemd, Redis can interact with your<br><br># supervision tree. Options:<br><br>#   supervised no      - no supervision interaction<br><br>#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode<br><br>#   supervised systemd - signal systemd by writing READY=1 to <span class="hljs-formula">$NOTIFY_SOCKET</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">supervised no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and removes it at exit.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># nothing bad happens, the server will start and run normally.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">pidfile /var/run/redis_6379.pid</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the server verbosity level.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This can be one of:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># warning (only very important / critical messages are logged)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">loglevel notice</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the log file name. Also the empty string can be used to force</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis to log on the standard output. Note that if you use standard</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">logfile &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># syslog-enabled no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the syslog identity.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># syslog-ident redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># syslog-facility local0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">databases 16</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that normally a logo is displayed only in interactive sessions.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">always-show-logo yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ SNAPSHOTTING  ################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Save the DB on disk:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   Will save the DB if both the given number of seconds and the given</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   number of write operations against the DB occurred.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   In the example below the behaviour will be to save:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   after 60 sec if at least 10000 keys changed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   It is also possible to remove all the previously configured save</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   points by adding a save directive with a single empty string argument</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   like in the following example:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   save &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">save 900 1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">save 300 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">save 60 10000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (at least one save point) and the latest background save failed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disaster will happen.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the background saving process will start working again Redis will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># automatically allow writes again.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However if you have setup your proper monitoring of the Redis server</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># continue to work as usual even if there are problems with disk,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># permissions, and so forth.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">stop-writes-on-bgsave-error yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">rdbcompression yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This makes the format more resistant to corruption but there is a performance</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for maximum performances.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tell the loading code to skip the check.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">rdbchecksum yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The filename where to dump the DB</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">dbfilename dump.rdb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The working directory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The DB will be written inside this directory, with the filename specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Append Only File will also be created inside this directory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that you must specify a directory here, not a file name.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">dir ./</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################# REPLICATION #################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   +------------------+      +---------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   |      Master      | ---&gt; |    Replica    |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   | (receive writes) |      |  (exact copy) |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   +------------------+      +---------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    a given number of replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    master if the replication link is lost for a relatively small amount of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    network partition replicas automatically try to reconnect to masters</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    and resynchronize with them.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># directive below) it is possible to tell the replica to authenticate before</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># starting the replication synchronization process, otherwise the master will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># refuse the replica request.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># masterauth &lt;master-password&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When a replica loses its connection with the master, or when the replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is still in progress, the replica can act in two different ways:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    data set may just be empty if this is the first synchronization.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    COMMAND, POST, HOST: and LATENCY.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-serve-stale-data yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># You can configure a replica instance to accept writes or not. Writing against</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a replica instance may be useful to store some ephemeral data (because data</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># written on a replica will be easily deleted after resync with the master) but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># may also cause problems if clients are writing to it because of a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># misconfiguration.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Since Redis 2.6 by default replicas are read-only.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note: read only replicas are not designed to be exposed to untrusted clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Still a read only replica exports by default all the administrative commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># administrative / dangerous commands.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-read-only yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Replication SYNC strategy: disk or socket.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -------------------------------------------------------</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -------------------------------------------------------</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># New replicas and reconnecting replicas that are not able to continue the replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># process just receiving differences, need to do what is called a &quot;full</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># synchronization&quot;. An RDB file is transmitted from the master to the replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The transmission can happen in two different ways:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#                 file on disk. Later the file is transferred by the parent</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#                 process to the replicas incrementally.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#              RDB file to replica sockets, without touching the disk at all.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># can be queued and served with the RDB file as soon as the current child producing</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the RDB file finishes its work. With diskless replication instead once</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the transfer starts, new replicas arriving will be queued and a new transfer</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will start when the current one terminates.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># time (in seconds) before starting the transfer in the hope that multiple replicas</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will arrive and the transfer can be parallelized.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># works better.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">repl-diskless-sync no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to the replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># new replicas arriving, that will be queued for the next RDB transfer, so the server</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># waits a delay in order to let more replicas arrive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">repl-diskless-sync-delay 5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Replicas send PINGs to server in a predefined interval. It&#x27;s possible to change</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this interval with the repl_ping_replica_period option. The default value is 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-ping-replica-period 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The following option sets the replication timeout for:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is important to make sure that this value is greater than the value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># every time there is low traffic between the master and the replica.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-timeout 60</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Linux kernels using a default configuration.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># be reduced but more bandwidth will be used for replication.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># be a good idea.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">repl-disable-tcp-nodelay no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica data when replicas are disconnected for some time, so that when a replica</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># wants to reconnect again, often a full resync is not needed, but a partial</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># resync is enough, just passing the portion of data the replica missed while</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disconnected.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The bigger the replication backlog, the longer the time the replica can be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The backlog is only allocated once there is at least a replica connected.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-backlog-size 1mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># After a master has no longer connected replicas for some time, the backlog</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will be freed. The following option configures the amount of seconds that</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># need to elapse, starting from the time the last replica disconnected, for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the backlog buffer to be freed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that replicas never free the backlog for timeout, since they may be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># resynchronize&quot; with the replicas: hence they should always accumulate backlog.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A value of 0 means to never release the backlog.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># repl-backlog-ttl 3600</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The replica priority is an integer number published by Redis in the INFO output.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is used by Redis Sentinel in order to select a replica to promote into a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master if the master is no longer working correctly.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A replica with a low priority number is considered better for promotion, so</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for instance if there are three replicas with priority 10, 100, 25 Sentinel will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># pick the one with priority 10, that is the lowest.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However a special priority of 0 marks the replica as not able to perform the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># role of master, so a replica with priority of 0 will never be selected by</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis Sentinel for promotion.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default the priority is 100.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-priority 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># N replicas connected, having a lag less or equal than M seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The N replicas need to be in &quot;online&quot; state.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the last ping received from the replica, that is usually sent every second.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are available, to the specified number of seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># min-replicas-to-write 3</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># min-replicas-max-lag 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Setting one or the other to 0 disables the feature.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># min-replicas-max-lag is set to 10.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A Redis master is able to list the address and port of the attached</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># offers this information, which is used, among other tools, by</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis Sentinel in order to discover replica instances.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Another place where this info is available is in the output of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;ROLE&quot; command of a master.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The listed IP and address normally reported by a replica is obtained</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in the following way:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   IP: The address is auto detected by checking the peer address</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   of the socket used by the replica to connect with the master.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   Port: The port is communicated by the replica during the replication</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   handshake, and is normally the port that the replica is using to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   listen for connections.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used, the replica may be actually reachable via different IP and port</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># pairs. The following two options can be used by a replica in order to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and ROLE will report those values.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There is no need to use both the options if you need to override just</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the port or the IP address.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica-announce-ip 5.5.5.5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica-announce-port 1234</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################## SECURITY ###################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># commands.  This might be useful in environments in which you do not trust</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># others with access to the host running redis-server.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This should stay commented out for backward compatibility and because most</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># people do not need auth (e.g. they run their own servers).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 150k passwords per second against a good box. This means that you should</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># use a very strong password otherwise it will be very easy to break.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># requirepass foobared</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Command renaming.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is possible to change the name of dangerous commands in a shared</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># hard to guess so that it will still be available for internal-use tools</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># but not available for general clients.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Example:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is also possible to completely kill a command by renaming it into</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># an empty string:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># rename-command CONFIG &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Please note that changing the name of commands that are logged into the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># AOF file or transmitted to replicas may cause problems.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################### CLIENTS ####################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set the max number of connected clients at the same time. By default</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># able to configure the process file limit to allow for the specified limit</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the max number of allowed clients is set to the current file limit</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># an error &#x27;max number of clients reached&#x27;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxclients 10000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################## MEMORY MANAGEMENT ################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When the memory limit is reached Redis will try to remove keys</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to reply to read-only commands like GET.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># from the used memory count, so that network problems / resyncs will</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of more keys, and so forth until the database is completely emptied.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxmemory &lt;bytes&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is reached. You can select among five behaviors:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-random -&gt; Remove a random key among the ones with an expire set.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># LRU means Least Recently Used</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># LFU means Least Frequently Used</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># randomized algorithms.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       operations, when there are no suitable keys for eviction.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       At the date of writing these commands are: set setnx setex append</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#       getset mset msetnx exec sort</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default is:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxmemory-policy noeviction</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used less recently, you can change the sample size using the following</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># configuration directive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maxmemory-samples 5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (unless it is promoted to master after a failover or manually). It means</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that the eviction of keys will be just handled by the master, sending the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># DEL commands to the replica as keys evict in the master side.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># what you want, however if your replica is writable, or you want the replica to have</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a different memory setting, and you are sure all the writes performed to the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica are idempotent, then you may change this default (but be sure to understand</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># what you are doing).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that since the replica by default does not evict, it may end using more</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># be larger on the replica, or data structures may sometimes take more memory and so</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># forth). So make sure you monitor your replicas and make sure they have enough</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># memory to never hit a real out-of-memory condition before the master hits</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the configured maxmemory setting.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica-ignore-maxmemory yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################# LAZY FREEING ####################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># deletion of the object. It means that the server stops processing new commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># aggregated value containing millions of elements, the server can block for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a long time (even seconds) in order to complete the operation.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are executed in constant time. Another thread will incrementally free the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># object in the background as fast as possible.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># following scenarios:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    in order to make room for new data, without going over the specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    memory limit.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    EXPIRE command) must be deleted from memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    already exist. For example the RENAME command may delete the old key</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    itself removes any old content of the specified key in order to replace</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    it with the specified string.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 4) During replication, when a replica performs a full resynchronization with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    its master, the content of the whole database is removed in order to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    load the RDB file just transferred.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># like if DEL was called. However you can configure each case specifically</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># was called, using the following configuration directives:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lazyfree-lazy-eviction no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lazyfree-lazy-expire no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lazyfree-lazy-server-del no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">replica-lazy-flush no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################## APPEND ONLY MODE ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># good enough in many applications, but an issue with the Redis process or</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the configured save points).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Append Only File is an alternative persistence mode that provides</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># much better durability. For instance using the default data fsync policy</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># dramatic event like a server power outage, or a single write if something</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># still running correctly.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># with the better durability guarantees.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Please check http://redis.io/topics/persistence for more information.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">appendonly no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">appendfilename &quot;appendonly.aof&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis supports three different modes:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># everysec: fsync only one time every second. Compromise.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># it wants, for better performances (but if you can live with the idea of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># everysec.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># More details please check the following article:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If unsure, use &quot;everysec&quot;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># appendfsync always</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">appendfsync everysec</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># appendfsync no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># saving process (a background save or AOF log background rewriting) is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this currently, as even performing fsync in a different thread will block</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># our synchronous write(2) call.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that will prevent fsync() from being called in the main process while a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This means that while another child is saving, the durability of Redis is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># default Linux settings).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">no-appendfsync-on-rewrite no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Automatic rewrite of the append only file.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the AOF at startup is used).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This base size is compared to the current size. If the current size is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is reached but it is still pretty small.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># rewrite feature.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">auto-aof-rewrite-percentage 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">auto-aof-rewrite-min-size 64mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This may happen when the system where Redis is running</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data=ordered option (however this can&#x27;t happen when Redis itself</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># crashes or aborts but the operating system still works correctly).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis can either exit with an error when this happens, or load as much</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data as possible (the default now) and start if the AOF file is found</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to be truncated at the end. The following option controls this behavior.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and refuses to start. When the option is set to no, the user requires</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the server.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the server will still exit with an error. This option only applies when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will be found.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">aof-load-truncated yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   [RDB file][AOF tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tail.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">aof-use-rdb-preamble yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ LUA SCRIPTING  ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Max execution time of a Lua script in milliseconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># still in execution after the maximum allowed time and will start to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># reply to queries with an error.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When a long running script exceeds the maximum execution time only the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used to stop a script that did not yet called write commands. The second</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is the only way to shut down the server in the case a write command was</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># termination of the script.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">lua-time-limit 5000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ REDIS CLUSTER  ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster node enable the cluster support uncommenting the following:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-enabled yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Make sure that instances running in the same system do not have</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># overlapping cluster configuration file names.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-config-file nodes-6379.conf</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for it to be considered in failure state.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Most other internal time limits are multiple of the node timeout.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-node-timeout 15000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A replica of a failing master will avoid to start a failover if its data</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># looks too old.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There is no simple way for a replica to actually have an exact measure of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    in order to try to give an advantage to the replica with the best</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    replication offset (more data from the master processed).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    of the failover a delay proportional to their rank.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2) Every single replica computes the time of the last interaction with</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    its master. This can be the last ping or command received (if the master</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    disconnection with the master (if the replication link is currently down).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    If the last interaction is too old, the replica will not try to failover</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    at all.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the failover if, since the last interaction with the master, the time</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># elapsed is greater than:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica will not try to failover if it was not able to talk with the master</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for longer than 310 seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># elect a replica at all.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to a value of 0, which means, that replicas will always try to failover the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master regardless of the last time they interacted with the master.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># (However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># offset rank).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the cluster will always be able to continue.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-replica-validity-factor 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that are left without working replicas. This improves the cluster ability</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in case of failure if it has no working replicas.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># given number of other working replicas for their old master. This number</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will migrate only if there is at least 1 other working replica for its master</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and so forth. It usually reflects the number of replicas you want for every</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master in your cluster.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># one replica). To disable migration just set it to a very large value.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in production.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-migration-barrier 1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># However sometimes you want the subset of the cluster which is working,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to continue to accept queries for the part of the key space that is still</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># option to no.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-require-full-coverage yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># master during master failures. However the master can still perform a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># manual failover, if forced to do so.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This is useful in different scenarios, especially in the case of multiple</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># data center operations, where we want one side to never be promoted if not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in the case of a total DC failure.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-replica-no-failover no</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In order to setup your cluster make sure to read the documentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># available at http://redis.io web site.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">########################## CLUSTER DOCKER/NAT support  ########################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Docker and other containers).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In order to make Redis Cluster working in such environments, a static</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># configuration where each node knows its public address is needed. The</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># following two options are used for this scope, and are:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># * cluster-announce-ip</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># * cluster-announce-port</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># * cluster-announce-bus-port</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Each instruct the node about its address, client port, and cluster message</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># bus port. The information is then published in the header of the bus packets</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># so that other nodes will be able to correctly map the address of the node</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># publishing the information.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will be used instead.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 10000 will be used as usually.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Example:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-announce-ip 10.1.1.5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-announce-port 6379</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># cluster-announce-bus-port 6380</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################## SLOW LOG ###################################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># execution time. The execution time does not include the I/O operations</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># like talking with the client, sending the reply and so forth,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># but just the time needed to actually execute the command (this is the only</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># stage of command execution where the thread is blocked and can not serve</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># other requests in the meantime).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># command to get logged, and the other parameter is the length of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># queue of logged commands.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to one second. Note that a negative number disables the slow log, while</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a value of zero forces the logging of every command.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">slowlog-log-slower-than 10000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">slowlog-max-len 128</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">################################ LATENCY MONITOR ##############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The Redis latency monitoring subsystem samples different operations</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># at runtime in order to collect data related to possible sources of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># latency of a Redis instance.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Via the LATENCY command this information is available to the user that can</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># print graphs and obtain reports.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The system only logs operations that were performed in a time equal or</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># greater than the amount of milliseconds specified via the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to zero, the latency monitor is turned off.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># impact, that while very small, can be measured under big load. Latency</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># monitoring can easily be enabled at runtime using the command</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">latency-monitor-threshold 0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################# EVENT NOTIFICATION ##############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For instance if keyspace events notification is enabled, and a client</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># messages will be published via Pub/Sub:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># PUBLISH __keyspace@0__:foo del</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># PUBLISH __keyevent@0__:del foo</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># It is possible to select the events that Redis will notify among a set</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of classes. Every class is identified by a single character:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  $</span>     String commands<br><br>#  l     List commands<br><br>#  s     Set commands<br><br>#  h     Hash commands<br><br>#  z     Sorted set commands<br><br>#  x     Expired events (events generated every time a key expires)<br><br>#  e     Evicted events (events generated when a key is evicted for maxmemory)<br><br>#  A     Alias for g<span class="hljs-formula">$lshzxe, so that the &quot;AKE&quot; string means all the events.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  are disabled.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#           event name, use:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  notify-keyspace-events Elg</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#             name __keyevent@0__:expired use:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">  notify-keyspace-events Ex</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  By default all notifications are disabled because most users don&#x27;t need</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#  specify at least one of K or E, no events will be delivered.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#notify-keyspace-events &quot;&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">############################### ADVANCED CONFIG ###############################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># threshold. These thresholds can be configured using the following directives.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hash-max-ziplist-entries 512</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hash-max-ziplist-value 64</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The number of entries allowed per internal list node can be specified</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># as a fixed maximum size or a maximum number of elements.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># per list node.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">list-max-ziplist-size -2</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Lists may also be compressed.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 0: disable all list compression</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    going from either the head or tail&quot;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    but compress all nodes between them.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># etc.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">list-compress-depth 0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of 64 bit signed integers.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The following configuration setting sets the limit in the size of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># set in order to use this special memory saving encoding.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">set-max-intset-entries 512</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># elements of a sorted set are below the following limits:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">zset-max-ziplist-entries 128</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">zset-max-ziplist-value 64</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this limit, it is converted into the dense representation.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># dense representation is more memory efficient.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hll-sparse-max-bytes 3000</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Streams macro node max size / items. The stream data structure is a radix</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># it is possible to configure how big a single node can be in bytes, and the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># maximum number of items it may contain before switching to a new node when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># appending new stream entries. If any of the following settings are set to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># value.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">stream-node-max-bytes 4096</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">stream-node-max-entries 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># by the hash table.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default is to use this millisecond 10 times every second in order to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># If unsure:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to queries with 2 milliseconds delay.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># want to free memory asap when possible.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">activerehashing yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># that are not reading data from the server fast enough for some reason (a</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># publisher can produce them).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The limit can be set differently for the three different classes of clients:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># normal -&gt; normal clients including MONITOR clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># replica  -&gt; replica clients</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the soft limit is reached and remains reached for the specified number of</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># seconds (continuously).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the limit for 10 seconds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># without asking (in a push way), but just after a request, so only</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># than it can read.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Instead there is a default limit for pubsub and replica clients, since</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># subscribers and replicas receive data in a push fashion.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">client-output-buffer-limit normal 0 0 0</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the query buffer. However you can configure it here if you have very special</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># needs, such us huge multi/exec requests or alike.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># client-query-buffer-limit 1gb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># here.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># proto-max-bulk-len 512mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis calls an internal function to perform many background tasks, like</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># never requested, and so forth.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># handled with more precision.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 100 only in environments where very low latency is required.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">hz 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Normally it is useful to have an HZ value which is proportional to the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># number of clients connected. This is useful in order, for instance, to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># avoid too many clients are processed for each background task invocation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to avoid latency spikes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># which will temporary raise when there are many connected clients.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When dynamic HZ is enabled, the actual configured HZ will be used as</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># used as needed once more clients are connected. In this way an idle</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># instance will use very little CPU time while a busy instance will be</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># more responsive.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">dynamic-hz yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># big latency spikes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">aof-rewrite-incremental-fsync yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># When redis saves RDB file, if the following option is enabled</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># big latency spikes.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">rdb-save-incremental-fsync yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># idea to start with the default settings and only change them after investigating</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># understand what the two parameters mean before changing them.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># this way:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3. The counter is incremented only if R &lt; P.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># counter changes with a different number of accesses with different</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># logarithmic factors:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># NOTE: The above table was obtained by running the following commands:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   redis-benchmark -n 1000000 incr foo</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#   redis-cli object freq foo</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># to accumulate hits.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># less &lt;= 10).</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># decay the counter every time it happens to be scanned.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># lfu-log-factor 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># lfu-decay-time 1</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># even in production and manually tested by multiple engineers for some</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># time.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># What is active defragmentation?</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># -------------------------------</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># thus allowing to reclaim back memory.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># away all the data and create it again. However thanks to this feature</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># in an &quot;hot&quot; way, while the server is running.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Basically when the fragmentation is over a certain level (see the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># configuration options below) Redis will start to create new copies of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># will cause the fragmentation to drop back to normal values.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Important things to understand:</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    This is the default with Linux builds.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    issues.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula">#</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># a good idea to leave the defaults untouched.</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Enabled active defragmentation</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># activedefrag yes</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-ignore-bytes 100mb</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Minimum percentage of fragmentation to start active defrag</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-threshold-lower 10</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-threshold-upper 100</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Minimal effort for defrag in CPU percentage</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-cycle-min 5</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Maximal effort for defrag in CPU percentage</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-cycle-max 75</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"> </span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># the main dictionary scan</span><br><span class="hljs-formula"></span><br><span class="hljs-formula"># active-defrag-max-scan-fields 1000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker命令&quot;&gt;&lt;a href=&quot;#docker命令&quot; class=&quot;headerlink&quot; title=&quot;docker命令&quot;&gt;&lt;/a&gt;docker命令&lt;/h1&gt;&lt;h2 id=&quot;镜像命令&quot;&gt;&lt;a href=&quot;#镜像命令&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://example.com/2022/05/29/git/"/>
    <id>http://example.com/2022/05/29/git/</id>
    <published>2022-05-29T13:57:12.875Z</published>
    <updated>2022-05-29T14:26:56.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><a id="more"></a><blockquote><p>Git是一个版本管理控制系统（缩写VCS），它可以在任何时间点， 将文档的状态作为更新记录保存起来，也可以在任何时间点， 将更新记录恢复回来。</p></blockquote><h1 id="Git工作机制"><a href="#Git工作机制" class="headerlink" title="Git工作机制"></a>Git工作机制</h1><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423163817744.png" alt="image-20220423163817744"></p><p><strong>代码托管中心是基于网络服务器的远程代码仓库，我们一般简单称为远程库，如gitee，github</strong></p><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><table><thead><tr><th><strong>命令名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td><strong>git init</strong></td><td><strong>初始化本地库</strong></td></tr><tr><td><strong>git status</strong></td><td><strong>查看本地库状态</strong></td></tr><tr><td><strong>git add 文件名</strong></td><td><strong>添加到暂存区</strong></td></tr><tr><td><strong>git commit m “ 日志信息 “ 文件名</strong></td><td><strong>提交到本地库</strong></td></tr><tr><td><strong>git reflog</strong></td><td><strong>查看历史记录</strong></td></tr><tr><td><strong>git log</strong></td><td><strong>查看历史记录，详细信息</strong></td></tr><tr><td><strong>git reset hard 版本号</strong></td><td><strong>版本穿梭</strong></td></tr></tbody></table><h1 id="Git使用前配置"><a href="#Git使用前配置" class="headerlink" title="Git使用前配置"></a>Git使用前配置</h1><blockquote><p>在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。</p><ol><li><p>配置提交人姓名：git config –global user.name “提交人姓名” # (对当前系统用户有效)</p></li><li><p>配置提交人邮箱：git config –global user.email  “提交人邮箱” # (对当前系统用户有效)</p><p>作用：识别开发人员，与登良github的账户无关</p></li><li><p>查看git配置信息：git config –list</p></li></ol><p>注意<br>1.如果要对配置信息进行修改，重复上述命令即可。</p><ol start="2"><li>配置只需要执行一次。</li></ol><p><strong>自己 <code>C:\Users\Augenestern</code> 下有个 <code>.gitconfig</code> 文件，打开里面就是我们设置的用户签名</strong></p></blockquote><h1 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h1><ul><li>初始化本地库：<code>git init</code><ul><li>git定位到要操作的文件目录，输入<code>git init</code>,生成一个.git的隐藏文件夹</li></ul></li><li>查看本地库状态：<code>git status</code><ul><li><code>git status</code>后有红色的表示该文件未被添加到暂存区</li></ul></li><li>添加暂存区：<code>git add 文件名</code><ul><li>添加成功后，<code>git status</code>会用绿色显示文件名</li><li>使用<code>git rm --cached 文件名</code>删除暂存区文件，只是删除暂存区，工作区文件还在</li><li>使用<code>git rm -r --cached .</code>清空暂存区文件</li></ul></li><li>提交本地库：<code>git commit -m &quot;日志信息&quot; 文件名</code><ul><li>提交之后，<code>git status</code>无文件显示</li></ul></li><li>查看历史版本：<code>git reflog</code>  查看版本信息  <code>git log</code>  查看版本详细信息</li><li>版本穿梭：<code>git reset --hard 版本号</code><ul><li>可以将版本恢复到指定版本号的版本</li></ul></li></ul><h2 id="图文讲解"><a href="#图文讲解" class="headerlink" title="图文讲解"></a>图文讲解</h2><p><strong>设置用户签名</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165805821.png" alt="image-20220423165805821"></p><p><strong>初始化本地库</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165848541.png" alt="image-20220423165848541"></p><p><strong>查看本地库状态</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165926361.png" alt="image-20220423165926361"></p><p><strong>新增文件后查看状态</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423165958038.png" alt="image-20220423165958038"></p><p><strong>添加暂存区</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170017367.png" alt="image-20220423170017367"></p><p><strong>提交本地库</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170032291.png" alt="image-20220423170032291"></p><p><strong>修改文件</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170116877.png" alt="image-20220423170116877"></p><p><strong>查看历史版本</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170213186.png" alt="image-20220423170213186"></p><p><strong>版本穿梭</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170235756.png" alt="image-20220423170235756"></p><p><strong>版本切换原理</strong></p><p>Git 切换版本，底层其实是移动的HEAD 指针</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423170324500.png" alt="image-20220423170324500"></p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><blockquote><ul><li>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支</li><li>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行</li><li>对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本</li></ul><p>分支的好处是同时并行推进多个功能开发，提高开发效率。</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可</p></blockquote><h1 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h1><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><ul><li><p>查看分支：<code>git branch -v</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171330263.png" alt="image-20220423171330263"></p></li><li><p>创建分支：<code>git branch 分支名</code></p></li></ul><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171405996.png" alt="image-20220423171405996"></p><ul><li><p>切换分支：<code>git checkout 分支名</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171442859.png" alt="image-20220423171442859"></p></li><li><p>修改分支</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423171507205.png" alt="image-20220423171507205"></p></li><li><p>合并分支：<code>git merge 分支名</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423173526151.png" alt="image-20220423173526151"></p></li><li><blockquote><p>合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。</p><p>有两套完全不同的修改。 Git无法替我们决定使用哪一个。必须 人为决定新代码内容。</p></blockquote><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/4e603c5ffb3f4383a1082cade9b10a4d.png" alt="在这里插入图片描述"></p></li></ul><p>head 到 == 之前是主分支的代码，== 到 hot-fix 之前是hot-fix的代码，删除掉不需要保留的代码即可，同时删除三个标志位</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/0db79fb0322441b8bbed5c0434e07066.png" alt="在这里插入图片描述"></p><h1 id="Git团队协作"><a href="#Git团队协作" class="headerlink" title="Git团队协作"></a>Git团队协作</h1><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183055973.png" alt="image-20220423183055973"></p><h1 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h1><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183132491.png" alt="image-20220423183132491"></p><h1 id="Git和github"><a href="#Git和github" class="headerlink" title="Git和github"></a>Git和github</h1><h2 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容克隆到本地</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h2 id="推送到github步骤"><a href="#推送到github步骤" class="headerlink" title="推送到github步骤"></a>推送到github步骤</h2><p><strong>创建远程库</strong></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183208786.png" alt="image-20220423183208786"></p><p><strong>起别名</strong>：<code>git remote add 别名 远程地址</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183629968.png" alt="image-20220423183629968"></p><p><strong>推送到远程库</strong>：<code>git push 别名 分支</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220423183701561.png" alt="image-20220423183701561"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概况&quot;&gt;&lt;/a&gt;概况&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux无法ping通外网的问题</title>
    <link href="http://example.com/2022/05/29/Linux%E6%97%A0%E6%B3%95ping%E9%80%9A%E5%A4%96%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/29/Linux%E6%97%A0%E6%B3%95ping%E9%80%9A%E5%A4%96%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-29T13:56:56.955Z</published>
    <updated>2022-05-29T13:55:56.193Z</updated>
    
    <content type="html"><![CDATA[<p>今天重新装了一个Linux系统，下载东西的时候报出如下错误:</p><p><code>Cannot find a valid baseurl for repo: base/7/x86_64</code></p><a id="more"></a><p>然后使用ping命令发现无法ping通外网</p><p>需要设置一下DNS信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">vim /etc/resolv.conf<br><br>在里面加入如下配置<br>nameserver=8.8.8.8<br>nameserver=8.8.4.4<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天重新装了一个Linux系统，下载东西的时候报出如下错误:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cannot find a valid baseurl for repo: base/7/x86_64&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>windows端口命令</title>
    <link href="http://example.com/2022/05/29/window%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/29/window%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-29T13:56:53.473Z</published>
    <updated>2022-05-30T01:09:43.180Z</updated>
    
    <content type="html"><![CDATA[<p>在控制台输入<code>netstat</code> 可以查看所有端口占用情况</p><a id="more"></a><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503110733768.png" alt="image-20220503110733768"></p><p>输入<code>netstat -ano</code>可以查看所有端口占用详细信息，包括父进程的pid</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503110720513.png" alt="image-20220503110720513"></p><p>输入<code>netstat -ano|findstr &quot;端口号&quot;</code>可以查看到具体的端口占用情况，有点类似于linux的 <code>grep</code></p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503110919357.png" alt="image-20220503110919357"></p><p>使用<code>tasklist</code>可以查看所有进程的情况</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503111010735.png" alt="image-20220503111010735"></p><p>使用<code>tasklist|findstr &quot;进程号&quot;</code>可以查看具体进程的情况</p><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503111115078.png" alt="image-20220503111115078"></p><p>使用<code>taskkill /pid 进程号</code>可以杀死一个进程</p><p>使用<code>taskkill /F /pid 进程号</code>可以强制杀死一个进程</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在控制台输入&lt;code&gt;netstat&lt;/code&gt; 可以查看所有端口占用情况&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="http://example.com/2022/05/29/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/29/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-29T13:17:45.495Z</published>
    <updated>2022-05-29T13:31:37.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h2><h3 id="三种常见模式："><a href="#三种常见模式：" class="headerlink" title="三种常见模式："></a>三种常见模式：</h3><ul><li><p>正常模式</p><p>在正常模式下，我们可以使用快捷键。</p></li><li><p>插入模式/编辑模式</p><p>在这个模式下，程序猿可以输入内容。</p></li><li><p>命令行模式</p><p>在这个模式中，可以提供相关指令。</p><a id="more"></a></li></ul><h3 id="快捷键使用练习："><a href="#快捷键使用练习：" class="headerlink" title="快捷键使用练习："></a>快捷键使用练习：</h3><ul><li>yy：拷贝当前行</li><li>5yy：拷贝当前5行</li><li>dd：删除当前行</li><li>5dd：删除当前行向下的5行</li><li>在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个,N向上查找</li><li>设置文件行号：set nu，取消文件行号：set nonu</li><li>编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg</li><li>撤销输入：在正常模式下输入u</li><li>编辑文件，光标移动到某行：shift+g<ul><li>显示行号：set nu</li><li>输入行号这个数</li><li>输入shift+g</li></ul></li></ul><h2 id="关机、重启和用户登录注销"><a href="#关机、重启和用户登录注销" class="headerlink" title="关机、重启和用户登录注销"></a>关机、重启和用户登录注销</h2><ul><li>shutdown -h now：表示立即关机</li><li>shutdown -h 1：表示1分钟后关机</li><li>shutdown -r now：立即重启</li><li>halt：直接使用，关机</li><li>reboot：重启</li><li>sync：把内存的数据同步到磁盘上，<strong>当我们关机或者重启时，都应该先执行一下sync，防止数据丢失</strong>。</li><li>logout：注销用户，<strong>在图形运行级别无效，在运行级别3有效</strong>。</li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>用户，组，家目录。</p><ol><li>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li><li>Linux的用户需要至少要属于一个组。</li></ol><ul><li>添加用户：useradd [选项] 用户名。</li><li>cd：表示change directory，切换目录。</li><li>当创建用户成功后，会自动的创建和用户同名的家目录。</li><li>也可以通过useradd -d 指定目录 新的用户名。</li><li>指定/修改密码：passwd 用户名</li><li>删除用户，保留家目录：userdel 用户名，<strong>一般保留家目录，因为干过的活要留着</strong>。</li><li>删除用户以及家目录：userdel -r 用户名</li><li>查询用户信息：id 用户名</li><li>切换用户：su - 切换用户名，<strong>从权限高切换到权限低的用户不需要输密码</strong>。</li><li>返回切换前的用户：exit</li><li>查看当前用户/登录用户：who am i</li><li>用户组：类似于角色，系统可以对有共性的多个用户进行统一的管理。</li><li>增加组：groupadd 组名</li><li>删除组：groupdel 组名</li><li>增加用户时直接加上组：useradd -g 用户组 用户名</li><li>修改用户组：usermod -g 用户组 用户名</li></ul><ol start="3"><li>/etc/passwd 文件</li></ol><ul><li>用户（user）的配置文件，记录用户的各种信息。</li><li>每行的含义：用户名：口令：用户标识号：注释性描述：主目录：登录shell</li></ul><ol start="4"><li>/etc/shadow 文件</li></ol><ul><li>口令配置文件</li><li>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li></ul><ol start="5"><li>/etc/group 文件</li></ol><ul><li>组（group）的配置文件，记录Linux包含的组的信息。</li><li>每行含义：组名：口令：组标识号：组内用户列表</li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul><li><p>pwd：Print Working Directory，显示当前工作目录的绝对路径。</p></li><li><p>ls：-a：显示当前目录所有的文件和目录，包括隐藏的；-l：以列表的方式显示信息。</p></li><li><p>cd：cd ~：回到自己的家目录；cd ..：回到当前目录的上一级目录。</p></li><li><p>mkdir：创建目录；-p：创建多级目录。</p></li><li><p>rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。</p></li><li><p>touch：创建空文件。可以一次性创建多个文件</p></li><li><p>cp：拷贝文件到指定目录；-r：递归复制整个文件夹。强制覆盖不提示的方法：cp命令改为\cp</p></li><li><p>rm：移除文件或目录；-r：递归删除整个文件夹；-f：强制删除不提示。</p></li><li><p>mv：移动文件与目录或重命名，两种功能！</p></li><li><p>cat：查看文件内容。只能浏览文件，而不能修改文件。-n：显示行号。结尾加上 | more：分页显示，不会全部一下显示完。</p></li><li><p>more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键：</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键（Space）</td><td>向下翻一页</td></tr><tr><td>Enter</td><td>向下翻一行</td></tr><tr><td>q</td><td>立刻离开more，不再显示该文件内容</td></tr><tr><td>Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + B</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>：f</td><td>输出文件名和当前行的行号</td></tr></tbody></table></li><li><p>less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。<strong>对于显示大型文件具有较高的效率。</strong></p></li></ul><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键（Space）</td><td>向下翻一页</td></tr><tr><td>[pagedown]</td><td>向下翻一行</td></tr><tr><td>[pageup]</td><td>向上翻动一页</td></tr><tr><td>/字串</td><td>向下搜寻字串的功能；n向下找，N向上找</td></tr><tr><td>？子串</td><td>向上搜寻字串的功能；n向上找，N向下找   （n正向）</td></tr><tr><td>q</td><td>离开less这个程序</td></tr></tbody></table><ul><li><code>&gt;</code>指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。</li><li><code>&gt;&gt;</code>指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。</li><li>cat是查看，echo是写入，echo （内容） &gt;&gt; 文件</li><li>cal：显示当前月日历。</li><li>echo：输出内容到控制台。</li><li>head：显示文件的开头部分。-n 5：看前面5行内容。</li><li>tail：输出文件中尾部的内容。-n 5：看后面5行内容。-f：时事追踪该文档的所有更新</li><li>ln -s :建立软连接 </li><li>history: 查看历史指令</li></ul><h2 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h2><ul><li>date：显示当前日期和时间</li><li>date “+%Y”：显示当前年份</li><li>date “+%d”：显示当前月份</li><li>date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒</li><li>设置日期：date -s 字符串时间</li><li>cal：查看日历指令；cal 年份：显示某一年一整年的日历</li></ul><h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><ul><li>find：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。<ul><li>find (搜索范围) -name (文件名)：按照指定的文件名查找模式查找文件。</li><li>find (搜索范围) -user (用户名)：按照指定的用户名查找模式查找文件。</li><li>find (搜索范围) -size (+多少/-多少/多少)：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少）</li><li><strong>查询 /目录下所有.txt的文件</strong>：find / -name *.txt</li><li>根据文件名删除文件：<code>find . -name 文件名 | xargs rm -rf</code></li></ul></li><li>locate： locate (搜索文件)<ul><li>可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</li><li>在第一次运行之前，<strong>必须使用updatedb指令创建locate数据库</strong>。</li></ul></li><li>grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。<ul><li>grep [选项] 查找内容 源文件</li><li>-n：显示匹配行及行号。</li><li>-i：忽略大小写字母。</li><li><code>cat hello.txt | grep &quot;yes&quot;</code></li></ul></li></ul><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><ul><li>gzip/gunzip：压缩文件/解压<ul><li>gzip (文件)：压缩为.gz文件，原来文件不保留。</li><li>gunzip (文件)：解压缩，同样也不保留源文件。</li></ul></li><li>zip/unzip：压缩文件/解压<ul><li>zip [选项] (压缩后文件xxx.zip) (将要压缩的文件)</li><li>unzip [选项] (要解压的文件xxx.zip)</li><li>zip -r：递归压缩，即压缩目录</li><li>unzip -d (目录)：指定解压后的文件的存放目录</li></ul></li><li>tar：打包指令，最后打包后的文件是.tar.gz的文件<ul><li>tar [选项] xxx.tar.gz (打包的内容)</li><li>-c：产生.tar打包文件</li><li>-v：显示详细信息</li><li>-f：指定压缩后的文件名</li><li>-z：打包同时压缩</li><li>-x：解压.tar文件</li><li>压缩：tar -zcvf (压缩后文件名) (要压缩的文件)</li><li>解压：tar -zxvf (要解压的文件)</li><li>解压到指定目录：tar -zxvf (要解压的文件) -C (指定目录)，指定解压到的目录要存在。</li></ul></li></ul><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>在Linux中每个用户必须属于一个组，不能独立于组外。每个文件有所有者、所在组、其他组概念</p><ol><li>所有者</li><li>所在组</li><li>其他组</li><li>改变用户所在组</li></ol><ul><li>文件/目录所有者：<ul><li>一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。</li><li>查看文件所有者：ls -ahl</li><li>修改文件所有者：chown (用户名) (文件名)</li><li>文件所在组不一定是文件所有者。</li></ul></li><li>组的创建<ul><li>groupadd (组名)</li></ul></li><li>文件/目录所在组<ul><li>修改文件所在组：chgrp (组名) (文件名)</li></ul></li><li>其他组<ul><li>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</li></ul></li><li>改变用户所在组<ul><li>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组</li><li>改变用户所在组：usermod -g 组名 用户名</li><li>改变用户登录的初始目录：usermod -d 目录名 用户名</li></ul></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rw-r--r--.  1 zwj  root       0 4月   5 18:20 apple.txt<br></code></pre></td></tr></table></figure><p>第0位是符号类型</p><ul><li><p>文件类型：</p><ul><li>-：普通类型</li><li>d：目录</li><li>l：软连接  相当于快捷方式</li><li>c：字符设备【键盘、鼠标等】</li><li>b：块文件【硬盘】</li></ul></li><li><p>rw-：表示文件所有者权限（rw，读写）(第1-3位)</p></li><li><p>r–：表示文件所在组的用户的权限（r，只有读的权限）（第4-6位）</p></li><li><p>r–：表示文件其他组的用户的权限（r，只有读的权限）（第7-9位）</p></li><li><p>1：如果是文件，表示硬连接的数；如果是目录则表示该目录的子目录个数</p></li><li><p>zwj：文件所有者</p></li><li><p>root：文件所在组</p></li><li><p>0：文件的大小，0个字节；如果是目录，则统一为4096</p></li><li><p>July 1 13：40：文件最后的修改时间</p></li><li><p>apple.txt：文件名</p></li></ul><ul><li><p>rwx作用到文件：</p><ul><li>r：read，可读。读取查看。</li><li>w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li><li>x：execute，可执行。可以被执行。</li></ul></li><li><p>rwx作用到目录：</p><ul><li>r：可以读取，ls查看目录内容。</li><li>w：可以修改，目录内创建+删除+重命名目录。</li><li>x：可执行，可以进入该目录。</li></ul></li><li><p>修改权限 chmod</p><ul><li>修改文件或者目录的权限</li><li>u：所有者；g：所在组；o：其他人；a：所有人（u、g、o的总和）</li><li>chmod u=rwx，g=rx，o=x 文件目录名：分别权限</li><li>chmod o+w 文件目录名：给其他人都增加写的权限</li><li>chmod a-x 文件目录名：给所有的用户都减掉执行权限</li></ul></li><li><p>通过数字变更权限</p><ul><li>规则：r=4 w=2 x=1 rwx=4+2+1=7</li><li>chmod u=rwx，g=rx，o=x 文件目录名 <strong>等价于</strong> chmod 751 文件目录名</li></ul></li><li><p>修改文件所有者 chown</p><ul><li>chown newowner file：改变文件的所有者</li><li>chown newowner：newgroup file：改变文件的所有者和所在组</li><li>-R：如果是目录，则使其下所有子文件或目录递归生效</li></ul></li><li><p>修改文件所在组 chgrp</p><ul><li>chgrp newgroup file：改变文件的所有组</li><li>-R：如果是目录，则使其下所</li></ul></li></ul><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><ul><li><p>rond任务调度：crontab进行定时任务调度</p><ul><li>crontab [选项]</li><li>-e：编辑crontab定时任务</li><li>-l：查询crontab任务</li><li>-r：删除当前用户所有的crontab任务</li><li>service crond restart：重启任务调度</li><li>当保存退出后就生效了</li></ul><p><strong>快速入门</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 设置任务调度文件： <br>/etc/crontab<br><br>#设置个人任务调度,执行crontab -e命令，接着输入任务到调度文件，如：<br>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt     #每个* 之前有空格<br>意思是每小时的每分钟执行 ls -l /etc/ &gt; /tmp/to.txt 命令<br></code></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个“*”</td><td>一天当中的第几小时</td><td>0-23</td></tr><tr><td>第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个“*”</td><td>一周当中的星期几</td><td>0-7（0和7都代表星期日）</td></tr></tbody></table></li><li><p>特殊符号说明</p><ul><li><code>*</code>：代表任何时间。比如第一个<code>*</code>就代表一小时中每分钟都执行一次的意思。</li><li><code>,</code>：代表不连续的时间。比如“0 8,12,16 * * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</li><li><code>-</code>：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。</li><li><code>*/n</code>：代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令。</li></ul><p>** 特定时间执行任务案例</p></li></ul><table><thead><tr><th>时间</th><th>含义</th></tr></thead><tbody><tr><td>45 22 * * * 命令</td><td>22点45分执行命令</td></tr><tr><td>0 17 * * 1 命令</td><td>每周一的17点执行</td></tr><tr><td>0 5 1,15 * * 命令</td><td>每月的1号和15号的5点执行</td></tr><tr><td>40 4 * * 1-5 命令</td><td>每周一到周五的4点40执行</td></tr><tr><td>*/10 4 * * * 命令</td><td>每天的4点每隔10分钟执行</td></tr><tr><td>0 0 1,15 * 1 命令</td><td>每月1号和15号、周一的零点执行，星期和几号最好不要同时出现</td></tr></tbody></table><h3 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h3><blockquote><ol><li>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li><li>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li><li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</li><li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</li><li>ps -ef | grep atd //可以检测atd是否在运行    ps - ef 可以查看所有运行的进程</li></ol></blockquote><ul><li>atq：查看当前任务</li><li>atrm: 删除已经设置的任务，atrm 任务编号</li></ul><p><strong>案例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 两分钟后把时间写到xx.log<br>at now + 2 minutes  回车<br>at&gt; date &gt; /home/xx.log   输入完按两次 Ctrl+D<br><br>#两天后的下午5点执行 /bin/li/home<br>at 5pm + 2 days   回车<br>at&gt; /bin/ls/home  输入完按两次 Ctrl+D<br></code></pre></td></tr></table></figure><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><blockquote><p>Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</p><p>Linux采用了一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p></blockquote><ul><li><p>硬盘说明</p><ul><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li>lsblk -f：查看当前系统的分区和挂载情况。（list block）</li><li>lsblk: 查看系统分区情况</li></ul></li><li><p>新增硬盘的操作</p><ul><li>虚拟机添加硬盘</li><li>分区：fdsk  /dev/sdb（sdb是新增加的硬盘的名字)</li><li>格式化：mkfs -t ext4 /dev/sdb1  (sdb1是刚才分区的名字)</li><li>挂载：新建目录：mkdir /home/newdisk；挂载：mount /dev/sdb1 /home/newdisk , ==将sdb1挂载到 /home/newdisk目录下，这样保存到 /home/newdisk目录下的文件就保存到 sdb1硬盘中==</li><li>设置可以自动挂载（永久挂载）：重启系统后，仍然可以挂载。vim etc/fstab 增加挂载信息。mount -a：生效</li><li>取消挂载：unmount /dev/sdb1</li></ul></li><li><p>磁盘情况查询：</p><ul><li>查询系统整体磁盘使用情况：df -h 、  df -l</li><li>查询指定目录的磁盘占用情况：du -h /目录，默认为当前目录<ul><li>-s：指定目录占用大小汇总</li><li>-h：带计量单位</li><li>-a：含文件</li><li>–max-depth=1：子目录深度</li><li>-c：列出明细的同时，增加汇总值</li></ul></li></ul></li><li><p>磁盘情况-工作实用指令</p><ol><li>统计/home文件夹下文件的个数：<code>ls -l /home | grep &quot;^-&quot; | wc -l</code>  <strong>wc的功能是进行统计，“^-” 是正则表达式，以-开头的</strong></li><li>统计/home文件夹下目录的个数：<code>ls -l /home | grep &quot;^d&quot; | wc -l</code></li><li>统计/home文件夹下文件的个数，包括子文件夹里的：<code>ls -lR /home | grep &quot;^-&quot; | wc -l</code></li><li>统计文件夹下目录的个数，包括子文件夹里的：<code>ls -lR /home | grep &quot;^d&quot; | wc -l</code></li><li>以树状显示目录结构：首先安装tree指令：yum install tree，tree</li></ol></li></ul><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><ul><li>指定固定IP：直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-eth33。修改如下只<ul><li>BOOTPROTO=static  <em>静态分配</em></li><li>IPADDR= 192.168.200.139  <em>ip地址</em></li><li>GETWAY=192.168.200.2<em>网关</em></li><li>DNS1=192.168.200.2 <em>域名解析器</em></li><li>重启网络服务 （service network restart)  或重启系统生效(reboot)</li></ul></li><li>设置主机名 : vim/etc/hostname</li><li>查看主机名:hostname</li><li>设置ip和主机名的映射关系<ul><li>windows:  C:\windows\System2\drivers\etc\hosts，添加映射关系</li><li>linux：在etc/hosts 文件中添加</li></ul></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul><li><p>在Linux中，每个执行的<strong>程序（代码）</strong>都称为一个进程。每个进程都分配一个ID号</p></li><li><p>每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。</p></li><li><p>每个进程都可能以两种方式存在：前台和后台</p><ul><li>前台进程：用户目前的屏幕上可以进行操作的。</li><li>后台进程：实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li></ul></li><li><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</p></li><li><p>显示系统执行的进程</p><ul><li>ps：查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。PID：进程识别号；TTY：终端机号；TIME：此进程所消耗的CPU时间；CMD：正在执行的命令或进程名</li><li>ps -a：显示当前终端的所有进程信息。</li><li>ps -u：以用户的格式显示进程信息。</li><li>ps -x：显示后台进程运行的参数。</li><li>ps -axu | grep xxx：过滤得到xxx的信息。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">System V展示风格<br><br>USER:用户名称<br><br>PID:进程号<br><br>%CPU:进程占用CPU的百分比<br><br>%MEM:进程占用物理内存的百分比<br><br>VSZ:进程占用的虚拟内存大小（单位:KB)<br><br>RSS:进程占用的物理内存大小(单位:KB)<br><br>TT:终端名称,缩写<br><br>STAT:进程状态，其中S-睡眠,s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等<br><br>STARTED:进程的启动时间<br><br>TIME:CPU时间，即进程使用CPU的总时间<br><br>COMMAND:启动进程所用的命令和参数，如果过长会被截断显示<br></code></pre></td></tr></table></figure><ul><li>ps -ef：以全格式显示当前所有的进程，查看进程的父进程。</li><li>-e：显示所有进程。</li><li>-f：全格式。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">UID:用户ID<br><br>PID:进程ID<br><br>PPID:父进程ID<br><br>C: CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低;数值越小，表明进程是IO密集型运算，执行优先级会提高<br><br>STIME:进程启动的时间<br><br>TTY:完整的终端名称<br><br>TIME:CPU时间<br><br>CMD:启动进程所用的命令和参数<br></code></pre></td></tr></table></figure></li><li><p>终止进程</p><ul><li>kill [选项] 进程号：通过进程号杀死进程</li><li>killall 进程名称：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</li><li>-9：表示强迫进程立刻停止</li><li>案例1：踢掉非法用户：kill 进程号</li><li>案例2：终止远程登录服务sshd，在适当时候再次重启sshd服务  :kill sshd对应的进程号， 重启： /bin/systemctl start sshd.service</li><li>案例3：终止多个gedit编辑器：killall 进程名称</li><li>案例4：强制杀掉一个终端：kill -9 进程号</li></ul></li><li><p>查看进程树：pstree [选项]</p><ul><li>-p：显示进程的PID</li><li>-u：显示进程的所属用户</li></ul></li></ul><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><ul><li><p>service管理指令：service 服务名 [start | stop | restart | reload | status]</p></li><li><p>在CentOS7.0之后，不再使用service，而是systemctl</p></li><li><p>查看防火墙情况：</p><ul><li>service iptables status</li><li>systemctl status firewalld（7.0之后的版本）</li></ul></li><li><p>运行级别：通常使用3和5，3是无图形界面，5有图形化界面</p><ul><li>查看或修改默认级别：vim /etc/inittab</li><li>systemctl get-default 查看当前的运行级别</li><li>systemctl set-default TARGENT.target 设置当前运行级别为3</li></ul></li><li><p>chkconfig：可以给每个服务的各个运行级别设置自启动/关闭</p><ul><li>查看xxx服务：chkconfig –list | grep xxx</li><li>查看服务的状态：chkconfig 服务名 –list</li><li>给服务的运行级别设置自启动：chkconfig –level 5 服务名 on/off</li><li>要所有运行级别关闭或开启：chkconfig 服务名 on/off</li></ul></li><li><p>systemctl管理指令</p><ul><li>基本语法:systemctl [start | stop | restart | status]服务名</li><li>systemctl指令管理的服务在/usr/lib/systemd/system查看</li><li>systemctl设置服务的自启动状态</li><li>systemctl list-unit-files [l grep 服务名](查看服务开机启动状态, grep可以进行过滤)</li><li>systemctl enable服务名(设置服务开机启动)</li><li>systemctl disable 服务名(关闭服务开机启动)</li><li>systemctl is-enabled服务名(查询某个服务是否是自启动的)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">systemctl status firewalld   #查看firewalld的状况<br>systemctl stop firewalld   #关闭防火墙<br>systemctl start firewalld #重启防火墙<br><br>#以上命令指示临时生效，当系统重启后还是回归以前的配置<br>#如果需要永久生效，使用systemctl [enable|disable] 服务名   进行修改 <br></code></pre></td></tr></table></figure><ul><li>windows 在 cmd下使用 telnet ip  端口号 可以连接端口</li></ul></li><li><p>端口设置</p><ul><li>打开端口：<code>firewall-cmd --permanent --add-port=端口号/协议</code>  如：<code>firewall-cmd --permanent --add-port=111/tcp</code></li><li>关闭端口：<code>firewall-cmd --permanent --remove-port-端口号/协议</code>   如：<code>frewall-cmd --permanent --remove-port=111/tcp</code></li><li>重新载入之后上面的操作才能够生效：<code>firewall-cmd --reload</code></li><li>查询端口是否开放： <code>firewall-cmd --query-port=端口号/协议</code></li><li>查看开放的所有端口：<code>firewall-cmd --zone=public --list-ports</code></li></ul></li></ul><h2 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h2><blockquote><p>top和ps命令很相似。它们都用来显示正在执行的进程。top和ps最大的不同之处在于top在执行一段时间可以更新正在运行的进程。</p></blockquote><ul><li>top [选项]<ul><li>-d 秒数：指定top命令每隔几秒更新。默认是3秒。</li><li>-i：使top不显示任何闲置或者僵死进程。</li><li>-p：通过指定监控进程ID来仅仅监控某个进程的状态。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml">PID：进程号 <br><br>USER：进程所有者的用户名 ( 该 process 所属的使用者 )<br><br>PR：进程的优先级别 ( Priority 的简写，程序的优先执行顺序，越小越早被执行 )<br><br>NI：进程的优先级别数值 ( Nice 的简写，与 Priority 有关，也是越小越早被执行 )<br><br>VIRT：进程占用的虚拟内存值。<br><br>RES：进程占用的物理内存值。<br><br>SHR：进程使用的共享内存值。<br><br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br><br>%CPU：该进程占用的CPU使用率。<br><br>%MEM：该进程占用的物理内存和总内存的百分比。<br><br>TIME＋：该进程启动后占用的总的CPU时间 ( CPU 使用时间的累加 )<br><br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。<br></code></pre></td></tr></table></figure><ul><li>交互操作说明：(在top界面按下对应的选型)<ul><li>P：以CPU使用率排序，默认就是此项</li><li>M：以内存的使用率排序</li><li>N：以PID排序</li><li>q：退出top</li></ul></li><li>案例1：监控特定用户：==top查看进程；u输入用户名。==</li><li>案例2：终止指定的进程：==top查看进程；k输入要结束的进程号。==</li><li>案例3：指定系统状态更新的时间（每隔10秒自动更新，默认是3秒）：top -d 10</li></ul><h2 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h2><ul><li>netstat [选项]<ul><li>-an：按一定顺序排列输出</li><li>-p：显示哪个进程在调用</li></ul></li></ul><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><blockquote><p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成只有.RPM扩展名的文件。RPM是RedHat Package Manager( RedHat软件包管理工具)的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。</p><p>Linux的分发版本都有采用(suse,redhat, centos等等），可以算是公认的行业标准了.</p></blockquote><ul><li>rpm包的查询指令：<ul><li>rpm -qa：查询所安装的所有rpm软件包</li><li>rpm -qa | more</li><li>rpm -qa | grep xx</li><li>rpm -q xx：查询xx软件包是否安装</li><li>rpm -qi xx：查询软件包信息</li><li>rpm -ql xx：查询软件包中的文件</li><li>rpm -qf 文件全路径名：查询文件所属的软件包</li></ul></li><li>卸载rpm包：rpm -e 软件包名称<ul><li>删除时可能会发生依赖错误，忽视依赖强制删除的方法：rpm -e –nodeps 软件包名称</li></ul></li><li>安装rpm包：rpm -ivh 软件包全路径名称<ul><li>i=install：安装</li><li>v=verbose：提示</li><li>h=hash：进度条</li></ul></li></ul><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><blockquote><p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p></blockquote><ul><li>yum list | grep xx：查询yum服务器是否有需要安装的软件</li><li>yum install xx：安装指定的yum包</li><li>yum -y remove xx：卸载指定的yum包</li></ul><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><ol><li><p>使用windows下载jdk1.8的压缩包，使用xftp传输给linux  <em>通常保存到/opt/xxx下</em></p></li><li><p>使用 <code>tar -zxvf xxx</code>解压文件</p></li><li><p>将压缩文件移动到<code>/usr/local/xxx</code>文件夹下,<em>最好先在usr/local下创建文件夹，再使用mv移动文件夹</em></p></li><li><p>配置环境变量 ：<code>vim /etc/profile</code>,添加如下命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">export JAVA_HOME=/usr/local/java/jdk1.8.0_321    #jdk1.8.0_321为你自己的文件夹名字<br>export PATH=$JAVA_HOME/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p>使用<code>source /etc/profile</code>让刚才配置的环境变量生效</p></li><li><p>使用<code>echo $PATH</code>可以查看配置的环境变量是否生效</p></li></ol><h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><blockquote><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便裕兴程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p></blockquote><h3 id="Shell脚本的执行方式："><a href="#Shell脚本的执行方式：" class="headerlink" title="Shell脚本的执行方式："></a>Shell脚本的执行方式：</h3><ul><li>脚本格式要求：<ul><li>脚本以#!/bin/bash 开头</li><li>脚本需要有可执行权限</li></ul></li><li>脚本的常用执行方式：<ul><li>方式1（输入脚本的绝对路径或相对路径）<ul><li>首先要赋予xx.sh脚本的+x权限：chmod 744 myShell.sh</li><li>执行脚本：./myShell.sh</li></ul></li><li>方式2（sh+脚本）：<ul><li>说明：不用赋予+x权限，直接执行即可</li><li>sh ./myShell.sh</li></ul></li></ul></li></ul><h3 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h3><ul><li><p>shell变量的介绍</p><ul><li>Linux Shell的变量分为，系统变量和用户自定义变量</li><li>系统变量：<code>$HOME</code>、<code>$PWD</code>、<code>$SHELL</code>、<code>$USER</code>等等</li><li>显示当前shell中所有变量：set</li></ul></li><li><p>shell变量的定义</p><ul><li><p>基本语法</p><p>定义变量：变量名=值，**=两边不能有空格**</p><p>撤销变量：unset 变量名</p><p>声明静态变量：readonly 变量，注意：不能unset</p><p>输出变量： $变量名</p></li></ul></li><li><p>定义变量的规则</p><ul><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头</li><li>等号两侧不能有空格</li><li>变量名称一般习惯为大写</li></ul></li><li><p>将命令的返回值赋给变量</p><ul><li>A=`date`，使用反引号，运行里面的命令，并把结果返回给变量A</li><li>A=$(date)等价于上面</li></ul></li></ul><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><ul><li><p>基本语法</p><ul><li><p>export 变量名=变量值：将shell变量输出为环境变量/全局变量</p></li><li><p>source 配置文件：让修改后的配置文件信息立即生效</p></li><li><p>echo $变量名：查询环境变量的值</p></li><li><p>多行注释：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">:&lt;&lt;!<br>需要注释的内容<br>!<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><blockquote><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息就可以使用到位置参数变量。比如： ./myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中传参100，200。</p></blockquote><ul><li>基本语法：<ul><li><code>$n</code>：n为数字，<code>$0</code>代表命令本身，<code>$1-$9</code>代表第一到第九个参数，10以上的参数需要用大括号包含，如<code>$&#123;10&#125;</code></li><li><code>$*</code>：这个变量代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体</li><li><code>$@</code>：这个变量也代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待</li><li><code>$#</code>：这个变量代表命令行中所有参数的个数</li></ul></li></ul><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><ul><li>shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</li><li>基本语法：<ul><li><code>$$</code>：当前进程的进程号（PID）</li><li><code>$!</code>：后台运行的最后一个进程的进程号（PID）</li><li><code>$?</code>：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确。</li><li>后台运行：./myShell.sh &amp;</li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>在Shell中进行各种运算操作</li><li>“<code>$</code>((运算式))”或“<code>$</code>[运算时]”</li><li>expr m + n，注意expr运算符间要有空格</li><li>expr m - n</li><li>expr <code>\*</code> / %，乘，除，取余</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul><li>基本语法：[ condition ]，<strong>注意condition前后有空格！</strong></li><li>非空返回true，可使用$?验证（0为true，&gt;1为false）</li><li>两个整数比较<ul><li>=：字符串比较</li><li>-lt：小于</li><li>-le：小于等于</li><li>-eq：等于</li><li>-gt：大于</li><li>-ge：大于等于</li><li>-ne：不等于</li></ul></li><li>按照文件权限进行判断<ul><li>-r：有读的权限</li><li>-w：有写的权限</li><li>-x：有执行的权限</li></ul></li><li>按照文件类型进行判断<ul><li>-f：文件存在并且是一个常规的文件</li><li>-e：文件存在</li><li>-d：文件存在并且是一个目录</li></ul></li></ul><h3 id="流程控制if语句"><a href="#流程控制if语句" class="headerlink" title="流程控制if语句"></a>流程控制if语句</h3><ul><li><p>if判断基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>then<br>代码<br>fi<br></code></pre></td></tr></table></figure></li><li><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br><br> then<br>程序<br>elif [ 条件判断式 ]<br>then<br>程序<br>fi<br></code></pre></td></tr></table></figure></li></ul><h3 id="流程控制case语句"><a href="#流程控制case语句" class="headerlink" title="流程控制case语句"></a>流程控制case语句</h3><ul><li><p>case语句基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br><br>“值1”)<br><br>如果变量的值等于值1，则执行程序1<br><br>;;<br><br>“值2”)<br><br>如果变量的值等于值2，则执行程序2<br><br>;;<br><br>…省略其他分支…<br><br>*)<br><br>如果变量的值都不是以上的值，则执行此程序<br><br>;;<br><br>esac<br></code></pre></td></tr></table></figure></li></ul><h3 id="流程控制for循环"><a href="#流程控制for循环" class="headerlink" title="流程控制for循环"></a>流程控制for循环</h3><ul><li><p>for循环基本语法1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3…<br><br> do<br><br> 程序<br><br> done<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>for循环基本语法2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shel">for ((初始值;循环控制条件;变量变化))<br><br> do<br><br> 程序<br><br> done<br></code></pre></td></tr></table></figure></li></ul><h3 id="流程控制while循环"><a href="#流程控制while循环" class="headerlink" title="流程控制while循环"></a>流程控制while循环</h3><ul><li><p>while循环基本语法1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]     #条件判断和括号之间有空格<br><br> do<br><br> 程序<br><br> done<br></code></pre></td></tr></table></figure></li></ul><h3 id="read读取控制台的输入"><a href="#read读取控制台的输入" class="headerlink" title="read读取控制台的输入"></a>read读取控制台的输入</h3><ul><li>read [选项] (参数)</li><li>-p：指定读取值时的提示符</li><li>-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。</li><li>参数：变量：指定读取值的变量名</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>系统函数</p><ul><li>basename：<strong>返回完整路径最后/的部分，常用于获取文件名</strong><ul><li>basename [pathname] [suffix]</li><li>basename [string] [suffix]</li><li>basename命令会删掉所有的前缀包括最后一个/</li><li>选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</li></ul></li><li>dirname：返回完整路径最后/的前面的部分，常用于返回路径部分<ul><li>dirname 文件绝对路径：从给定的包含绝对路径的文件名中出去文件名（非目录部分），然后返回剩下的路径（目录部分）</li></ul></li><li><strong>反正两个系统函数都不要最后一个/</strong></li></ul></li><li><p>自定义函数</p><ul><li><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">function funname()<br><br>&#123;<br><br> Action;<br><br> [return int;]<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用直接写函数名：funname（不用写括号），然后在后面写参数</p></li></ul></li></ul><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><blockquote><p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。<br>可以这样理解日志是用来记录重大事件的工具。</p></blockquote><ul><li><blockquote><ul><li>基本介绍<br>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。这些信息有些非常敏感，所以在 Linux 中这些日志文件只有 root 用户可以读取。<br>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。<br>可以这样理解日志是用来记录重大事件的工具。</li><li>系统常用的日志<br>/var/log/ 目录就是系统日志文件的保存位置</li></ul><table><thead><tr><th align="center">日志文件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/var/log/boot.log</td><td align="center">系统启动日志</td></tr><tr><td align="center">/var/log/cron</td><td align="center">记录与系统定时任务相关的日志</td></tr><tr><td align="center">/var/log/cups/</td><td align="center">记录打印信息的曰志</td></tr><tr><td align="center">/var/log/dmesg</td><td align="center">记录了系统在开机时内核自检的信总。也可以使用 dmesg 命令直接查看内核自检信息</td></tr><tr><td align="center">/var/log/btmp</td><td align="center">记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用 lastb 命令查看</td></tr><tr><td align="center">/var/log/lasllog</td><td align="center">记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件。不能直接用Vi查看，而要使用lastlog命令查看</td></tr><tr><td align="center">/var/log/mailog</td><td align="center">记录邮件信息的日志</td></tr><tr><td align="center">/var/log/message</td><td align="center">记录系统里要佶息的日志.这个日志文件中会记录 Linux 系统的绝大多数重要信息。如果系统出现问题，首先要检查的应该就是这个日志文件</td></tr><tr><td align="center">/var/log/secure</td><td align="center">记录验证和授权方面的倍息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh 的登录、su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</td></tr><tr><td align="center">/var/log/wtmp</td><td align="center">永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用 last 命令查看</td></tr><tr><td align="center">/var/tun/ulmp</td><td align="center">记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用 w、who、users 等命令查看</td></tr><tr><td align="center">除系统默认的日志之外，采用 RPM 包方式安装的系统服务也会默认把日志记录在 /var/log/ 目录中（源码包安装的服务日志存放在源码包指定的目录中）。不过这些日志不是由 rsyslogd 服务来记录和管理的，而是各个服务使用自己的日志管理文档来记录自身的日志。以下介绍的日志目录在你的 Linux 上不一定存在，只有安装了相应的服务，日志才会出现。</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">日志文件</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">/var/log/httpd/</td><td align="center">RPM 包安装的apache取务的默认日志目录</td></tr><tr><td align="center">/var/log/mail/</td><td align="center">RPM 包安装的邮件服务的额外日志因录</td></tr><tr><td align="center">/var/log/samba/</td><td align="center">RPM色安装的Samba服务的日志目录</td></tr><tr><td align="center">/var/log/sssd/</td><td align="center">守护进程安全服务目录</td></tr></tbody></table></blockquote><ul><li><strong>日志管理服务 rsyslogd</strong></li></ul><blockquote><p>CentOS 7.6日志服务是 rsyslogd，CentOS 6.x 日志服务是 syslogd，rsyslogd 功能更强大。rsyslogd 的使用、日志文件的格式，和 syslogd 服务兼容的。</p><ul><li>查询 Linux 中的 rsyslogd 服务是否启动<ul><li>ps aux | grep “rsyslog” | grep -v “grep”</li></ul></li><li>查询 rsyslogd 服务的自启动状态<ul><li>systemctl list-unit-files | grep rsyslog</li></ul></li><li>配置文件：/etc/rsyslog.conf<ul><li>编辑文件时的格式：*.*，其中第一个 * 代表日志类型，第二个 * 代表日志类别</li></ul></li></ul><blockquote><blockquote><table><thead><tr><th align="center">日志类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">auth</td><td align="center">安全和认证相关消息，pam 产生的日志（不推荐使用 authpriv 替代）</td></tr><tr><td align="center">authpirv</td><td align="center">安全和认证相关信息，ssh、ftp 等登录信息的验证信息（私有的）</td></tr><tr><td align="center">cron</td><td align="center">系统定时任务 crond 和 at 产生的日志</td></tr><tr><td align="center">daemon</td><td align="center">和各个守护进程相关的日志</td></tr><tr><td align="center">ftp</td><td align="center">ftp 守护进程产生的日志</td></tr><tr><td align="center">kern</td><td align="center">内核产生的日志（不是用户进程产生的）</td></tr><tr><td align="center">lpr</td><td align="center">打印产生的日志</td></tr><tr><td align="center">mail</td><td align="center">邮件收发信息</td></tr><tr><td align="center">news</td><td align="center">与新闻服务器相关的日志</td></tr><tr><td align="center">syslog</td><td align="center">有syslogd服务产生的日志信息（虽然服务名称已经改了 rsyslogd 服务，但是很多配置都还是沿用了 syslogd 的，这里并没有修改服务名）</td></tr><tr><td align="center">user</td><td align="center">用户等级类别的日志信息</td></tr><tr><td align="center">uucp</td><td align="center">uucp 子系统的日志信息，uucp 时早期 Linux 系统进行数据传递的协议，后来也经常用在新闻组服务中</td></tr><tr><td align="center">local0-local7</td><td align="center">为本地使用预留的服务</td></tr></tbody></table></blockquote></blockquote><blockquote><blockquote><table><thead><tr><th align="center">日志级别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">debug</td><td align="center">一般的调试信息说明，日志通信最多</td></tr><tr><td align="center">info</td><td align="center">基本的通知信息</td></tr><tr><td align="center">notice</td><td align="center">普通信息，但是有一定的重要性</td></tr><tr><td align="center">warning</td><td align="center">警告信息，但是还不会影响到服务或系统的运行</td></tr><tr><td align="center">err</td><td align="center">错误信息，一般达到 err 等级的信息已经可以影响到服务或系统的运行了</td></tr><tr><td align="center">crit</td><td align="center">严重错误信息，比 err 等级还要严重，系统或整个软件不能正常工作</td></tr><tr><td align="center">alert</td><td align="center">需要立刻修改的信息，比 crit 还要严重，必须立即采取行动</td></tr><tr><td align="center">emerg</td><td align="center">内核崩溃等重要信息，系统已经无法使用了</td></tr><tr><td align="center">none</td><td align="center">什么都不记录</td></tr><tr><td align="center">注意：日志级别从上到下，级别从低到高，记录信息越来越少，优先处理的等级就越高，危害就越大。</td><td align="center"></td></tr></tbody></table></blockquote></blockquote><ul><li><p>由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下4列：</p><ul><li>事件产生的时间</li><li>发生事件的服务器的主机名</li><li>产生事件的服务名或程序名</li><li>事件的具体信息</li></ul></li><li><p>日志管理服务应用实例</p><p>在 /etc/rsyslog.conf 中添加一个日志文件 /var/log/hsp.log，当有事件发送时，该文件会接收到信息并保存。</p><ul><li>在 /etc/rsyslog.conf 文件中增加如下命令</li></ul></li></ul><blockquote><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">*.*                         <span class="hljs-regexp">/var/</span>log/hsp.log<br></code></pre></td></tr></table></figure></blockquote></blockquote><ul><li>新建 /var/log/hsp.log 文件，重启系统，再查看该文件内容。</li></ul></blockquote><ul><li><strong>日志轮替</strong></li></ul><blockquote><ul><li><p>基本介绍</p><ul><li>日志是重要的系统文件，记录和保存了系统中所有的重要事件。但是日志文件也需要进行定期的维护，因为日志文件是不断增长的，如果完全不进行日志维护，而任由其随意递增，那么用不了多久，我们的硬盘就会被写满。</li><li>日志维护的最主要的工作就是把旧的日志文件删除，从而腾出空间保存新的日志文件。这项工作如果靠管理员手工来完成，那其实是非常烦琐的，而且也容易忘记。那么 Linux 系统是否可以自动完成日志的轮替工作呢？</li><li>logrotate 就是用来进行日志轮替（也叫日志转储）的，也就是把旧的日志文件移动并改名，同时创建一个新的空日志文件用来记录新日志，当旧日志文件超出保存的范围时就删除。</li></ul></li><li><p>日志轮替文件的命名规则</p><ul><li>日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围时就删除。那么，旧的日志文件改名之后，如何命名呢？主要依靠 /etc/logrotate.conf 配置文件中的“dateext”参数。</li><li>如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，如“secure-20130605”。这样日志文件名不会重叠，也就不需要对日志文件进行改名，只需要保存指定的日志个数，删除多余的日志文件即可。</li><li>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志；当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志；以此类推。</li></ul></li><li><p>配置文件：/etc/logrotate.conf</p><p>可以设置全局的日志轮替规则，当然也可以单独给某个日志文件指定策略。</p><p>在这个配置文件中，主要分为三部分：</p><ul><li>第一部分是默认设置，如果需要转储的日志文件没有特殊配置，则遵循默认设置的参数；</li><li>第二部分是读取 /etc/logrotate.d/ 目录中的日志轮替的子配置文件，也就是说，在 /etc/logrotate.d/ 目录中的所有符合语法规则的子配置文件也会进行日志轮替；</li><li>第三部分是对 wtmp 和 btmp 日志文件的轮替进行设定，如果此设定和默认参数冲突，则当前设定生效（如 wtmp 的当前参数设定的轮替时间是每月，而默认参数的轮替时间是每周，则对 wtmp 这个日志文件来说，轮替时间是每月，当前的设定参数生效）。</li></ul></li><li><p>logrotate 配置文件的主要参数</p></li></ul><table><thead><tr><th align="center">参数</th><th align="center">参数说明</th></tr></thead><tbody><tr><td align="center">daily</td><td align="center">日志的轮替周期是毎天</td></tr><tr><td align="center">weekly</td><td align="center">日志的轮替周期是每周</td></tr><tr><td align="center">monthly</td><td align="center">日志的轮控周期是每月</td></tr><tr><td align="center">rotate 数宇</td><td align="center">保留的日志文件的个数。0指没有备份</td></tr><tr><td align="center">compress</td><td align="center">当进行日志轮替时，对旧的日志进行压缩</td></tr><tr><td align="center">create mode owner group</td><td align="center">建立新日志，同时指定新日志的权限与所有者和所属组。如 create 0600 root utmp</td></tr><tr><td align="center">mail address</td><td align="center">当进行日志轮替时.输出内存通过邮件发送到指定的邮件地址</td></tr><tr><td align="center">missingok</td><td align="center">如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td align="center">nolifempty</td><td align="center">如果曰志为空文件，則不进行日志轮替</td></tr><tr><td align="center">minsize 大小</td><td align="center">日志轮替的最小值。也就是日志一定要达到这个最小值才会进行轮持，否则就算时间达到也不进行轮替</td></tr><tr><td align="center">size 大小</td><td align="center">日志只有大于指定大小才进行日志轮替，而不是按照时间轮替，如 size 100k</td></tr><tr><td align="center">dateext</td><td align="center">使用日期作为日志轮替文件的后缀，如 secure-20130605</td></tr><tr><td align="center">sharedscripts</td><td align="center">在此关键宇之后的脚本只执行一次</td></tr><tr><td align="center">prerotate/cndscript</td><td align="center">在日志轮替之前执行脚本命令。endscript 标识 prerotate 脚本结束</td></tr><tr><td align="center">postrolaie/endscripl</td><td align="center">在日志轮替之后执行脚本命令。endscripi 标识 postrotate 脚本结束</td></tr></tbody></table><ul><li><p>把自己的日志加入日志轮替</p><p>如果有些日志默认没有加入日志轮替（比如源码包安装的服务的日志，或者自己添加的日志），那么这些日志默认是不会进行日志轮替的，这样当然不符合我们对日志的管理要求。如果需要把这些日志也加入日志轮替，那该如何操作呢？</p><p>这里有两种方法：</p><ul><li>第一种方法是直接在 /etc/logrotate.conf 配置文件中写入该日志的轮替策略，从而把日志加入轮替；</li><li>第二种方法是在 /etc/logrotate.d/ 目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被包含到主配置文件中，所以也可以把日志加入轮替。<br>推荐第二种方法，因为系统中需要轮替的日志非常多，如果全部直接写入 /etc/logrotate.conf 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</li></ul></li><li><p>日志轮替服务应用实例</p><p>对于自己设置的 /var/log/hsp.log 日志，不是系统默认日志，而是通过 /etc/rsyslog.conf 配置文件自己生成的日志，所以默认这个日志是不会进行轮替的。如果需要把这个日志加入。就采用第二种方法，在 /etc/logrotate.d/ 目录中建立此日志的轮替文件。</p><ul><li>先创建 /etc/logrotate.d/hsplog 轮替文件</li><li>在文件中写入命令，即事先约定好的日志轮替规则</li></ul></li></ul><blockquote><blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">/var/<span class="hljs-built_in">log</span>/hsp.<span class="hljs-built_in">log</span> &#123;<br>     missingok<br>     daily<br>     copytruncate<br>     rotate <span class="hljs-number">7</span><br>     nolifempty<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote><ul><li>日志轮替机制原理<ul><li>logrotate 在很多 Linux 发行版上都是默认安装的。系统会定时运行 logrotate，一般是每天一次。系统是这么实现按天执行的。crond 会每天定时执行 /etc/cron.daily 目录下的脚本，而这个目录下有个文件叫 logrotate。logrotate 通过这个文件依赖定时任务执行的。</li></ul></li></ul></blockquote><ul><li><strong>查看内存日志</strong></li></ul><blockquote><ul><li>基本介绍<br>日志管理工具 journalctl 是CentOS 7上专有的日志管理工具，该工具是从 message 这个文件里读取信息。Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf</li><li>journalctl 用法<ul><li>查看所有日志（默认情况下 ，只保存本次启动的日志）：journalctl</li><li>查看内核日志（不显示应用日志）：journalctl -k</li><li>查看系统本次启动的日志：journalctl -b</li><li>实时滚动显示最新日志：journalctl -f</li><li>显示尾部的最新10行日志：journalctl -n </li></ul></li></ul></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;vi和vim编辑器&quot;&gt;&lt;a href=&quot;#vi和vim编辑器&quot; class=&quot;headerlink&quot; title=&quot;vi和vim编辑器&quot;&gt;&lt;/a&gt;vi和vim编辑器&lt;/h2&gt;&lt;h3 id=&quot;三种常见模式：&quot;&gt;&lt;a href=&quot;#三种常见模式：&quot; class=&quot;headerlink&quot; title=&quot;三种常见模式：&quot;&gt;&lt;/a&gt;三种常见模式：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正常模式&lt;/p&gt;
&lt;p&gt;在正常模式下，我们可以使用快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插入模式/编辑模式&lt;/p&gt;
&lt;p&gt;在这个模式下，程序猿可以输入内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令行模式&lt;/p&gt;
&lt;p&gt;在这个模式中，可以提供相关指令。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2021/12/07/java%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
    <id>http://example.com/2021/12/07/java%E5%9F%BA%E7%A1%80%E9%A2%98/</id>
    <published>2021-12-07T14:37:16.649Z</published>
    <updated>2022-05-30T01:09:59.186Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>1、列举出四种及以上Java的容器类（即集合类）？<br>Set、List、Queue、Map、ArrayList、HashSet、HashMap</p><a id="more"></a><p>2、简单说说Java事件处理由哪四部分组成？<br>Java事件由四部分组成：<br>事件源：产生事件的对象，例如：各个组件<br>事件对象：事件类<br>监听器：监听器接口(里面定义了响应事件的抽象方法)<br>“注册”：产生事件的对象，通过调用一个方法，通知“监听器”。</p><p>3、Java网络编程主要基于两个协议，是哪两个协议，其作用各是什么？（7分）<br>答：是TCP协议和UDP协议（1分）<br>    TCP协议：是面向连接的传输层协议。 进程（应用程序）在使用TCP协议之前，必须先建立连接，在数据传输完毕后要释放已建立的连接。（3分）<br>    UDP协议：是无连接的传输层协议。进程（应用程序）使用UDP无须建立连接，当然，数据传输结束时也没有连接需要释放。因此，用UDP能减少开销和发送数据之前的时延。（3分）</p><p>4、X公司承接了一个软件项目，目前正在做可行性分析。项目经理偏向于采用Java语言开发此项目，但有少数员工提出也可以用其他语言开发如C++或C#等，为统一思想。项目经理委托小张收集数据，并给大家分析下Java的特点或优势。（请列举Java的特点至少6点，并简单进行分析说明）<br>答：简单、面向对象、支持分布式(即网络功能)、健壮性（少出低级错误）、安全（被破解的可能性）、体系结构中立（跨平台）、可移植性、解释执行、高性能、多线程、动态</p><p>5、Java相对于C、C++语言，更适合应用型软件的开发，这主要是Java语言本身就相对C++语言作出了一些变化，请分析出至少Java相对C++语言在语法上6个及更多的不同点。<br>答：1）全局变量：Java中没有全局变量。2）指针：Java不支持指针，但对象变量实际上都是指针。3）数据类型的支持：Java在不同平台上数据类型都统一。4）类型转换：Java有类型相容性检查。5）结构和联合：Java只支持类。6）多重继承：Java用接口实现类似多重继承的功能。7）内存管理：Java自动回收无用内存。8）头文件：Java支持包引入import。9）宏定义和预处理：Java不支持宏定义。</p><p>6、什么是JDBC，在什么时候会用到它？<br>答、JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p><p>7、列举出任意四个JDBC连接数据库相关的Java类？<br>答：DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等</p><p>8、JDBC操作数据库的步骤？<br>答：注册数据库驱动。<br>建立数据库连接。<br>操作数据库：包括创建一个Statement，执行SQL语句，处理结果集等。<br>关闭数据库连接</p><p>9、有哪些不同类型的JDBC驱动，每种驱动的特点是什么？<br>答：有四类JDBC驱动。<br>1） JDBC-ODBC Bridge plus ODBC Driver（类型1）：它使用ODBC驱动连接数据库。需要安装ODBC以便连接数据库，正因为这样，这种方式现在已经基本淘汰了。<br>2） Native API partly Java technology-enabled driver（类型2）：这种驱动把JDBC调用适配成数据库的本地接口的调用。<br>3） Pure Java Driver for Database Middleware（类型3）：这个驱动把JDBC调用转发给中间件服务器，由它去和不同的数据库进行连接。用这种类型的驱动需要部署中间件服务器。这种方式增加了额外的网络调用，导致性能变差，因此很少使用。<br>4） Direct-to-Database Pure Java Driver（类型4）：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。不过使用这种方式的话，需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQL Connector/J是MySQL数据库的驱动。</p><p>10、JDBC是如何实现Java程序和JDBC驱动的松耦合的？<br>答：JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。在这里可以看到更多JDBC的使用示例。</p><p>11、JDBC的DriverManager是用来做什么的？<br>答：JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p><p>=======================================================<br>论述题：</p><p>对Java中JDBC的分析和理解？<br>   （1、可以从JDBC的含义；JDBC连接数据库相关的常用Java类；当前主要使用哪种类型的JDBC驱动；JDBC是如何实现Java程序和JDBC驱动的松耦合的；JDBC的DriverManager是用来做什么的；JDBC的DriverManager的理解等等角度进行分析（但不限于这些角度）<br>     2、能正确答出3个及以上点，且字数超过200字，则得满分<br>    ）。<br>答：<br>  1、JDBC的含义<br>  JDBC的全称是Java DataBase Connection，也就是Java数据库连接，我们可以用它来操作关系型数据库。JDBC接口及相关类在java.sql包和javax.sql包里。我们可以用它来连接数据库，执行SQL查询，存储过程，并处理返回的结果。JDBC接口让Java程序和JDBC驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p><p>  2、JDBC连接数据库相关的常用Java类包括（列举4个及以上，并可以简单说说列举的类的作用或含义）：<br>  DriverManager、Connection、Statement、ResultSet、PreparedStatement、SQLException、Types、ClassNotFoundException等  </p><p>  3、主要使用的JDBC驱动类型<br>  Direct-to-Database Pure Java Driver：这个驱动把JDBC转化成数据库使用的网络协议。这种方案最简单，也适合通过网络连接数据库。需要根据不同数据库选用特定的驱动程序，比如OJDBC是Oracle开发的Oracle数据库的驱动，而MySQLConnector/J是MySQL数据库的驱动。</p><p>  4、JDBC如何实现Java程序和JDBC驱动的松耦合的<br>JDBC API使用Java的反射机制来实现Java程序和JDBC驱动的松耦合。随便看一个简单的JDBC示例，你会发现所有操作都是通过JDBC接口完成的，而驱动只有在通过Class.forName反射机制来加载的时候才会出现，它使得应用程序和驱动程序之间进行了隔离，让迁移数据库的工作变得更简单。</p><p>  5、JDBC的DriverManager<br>JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面，然后我们会把数据库配置信息传成DriverManager. getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p><p>=======================================================</p><p>12、在Java程序中，如何获取数据库服务器的相关信息？<br>答：使用DatabaseMetaData可以获取到服务器的信息。当和数据库的连接成功建立了之后，可以通过调用getMetaData()方法来获取数据库的元信息。DatabaseMetaData里面有很多方法，通过它们可以获取到数据库的产品名称，版本号，配置信息等。相关代码为：<br>DatabaseMetaData metaData = con.getMetaData();<br>String dbProduct = metaData.getDatabaseProductName();</p><p>13、JDBC的Statement是什么？<br>答：Statement是JDBC中用来执行数据库SQL查询语句的接口。通过调用连接对象的getStatement()方法我们可以生成一个Statement对象。我们可以通过调用它的execute()，executeQuery()，executeUpdate()方法来执行静态SQL查询。由于SQL语句是程序中传入的，如果没有对用户输入进行校验的话可能会引起SQL注入的问题。<br>另外，默认情况下，一个Statement同时只能打开一个ResultSet。如果想操作多个ResultSet对象的话，需要创建多个Statement。Statement接口的所有execute方法开始执行时都默认会关闭当前打开的ResultSet。</p><p>14、execute，executeQuery，executeUpdate的区别是什么？<br>答：1）execute方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。<br>2）executeQuery方法用来执行查询(select)，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。<br>3）executeUpdate方法用来执行添删改操作，即insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。<br>4）只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p><p>15、JDBC的PreparedStatement是什么？<br>答：PreparedStatement对象代表的是一个预编译的SQL语句。用它提供的setter方法可以传入查询的变量。<br>由于PreparedStatement是预编译的，通过它可以将对应的SQL语句高效的执行多次。由于PreparedStatement自动对特殊字符转义，避免了SQL注入攻击，因此应当尽量的使用它。</p><p>16、PreparedStatement中如何注入NULL值？<br>答：可以使用它的setNull方法来把null值绑定到指定的变量上。setNull方法需要传入参数的索引以及SQL字段的类型，像这样：<br>ps.setNull(10, java.sql.Types.INTEGER);.</p><p>17、Statement中的getGeneratedKeys方法有什么用？<br>答：有的时候表会生成主键，这时候就可以用Statement的getGeneratedKeys()方法来获取这个自动生成的主键的值了。</p><p>18、相对于Statement，PreparedStatement的优点是什么？<br>答：它和Statement相比优点在于：<br>1）PreparedStatement有助于防止SQL注入，因为它会自动对特殊字符转义。<br>2）PreparedStatement可以用来进行动态查询。<br>3）PreparedStatement执行更快。尤其当你重用它或者使用它的拼量查询接口执行多条语句时。<br>4）使用PreparedStatement的setter方法更容易写出面向对象的代码，而Statement的话，我们得拼接字符串来生成查询语句。如果参数太多了，字符串拼接看起来会非常难看并且容易出错。</p><p>19、JDBC中大数据量的分页解决方法?<br>答：最好的办法是利用sql语句进行分页，这样每次查询出的结果集中就只包含某页的数据内容。<br>mysql语法：<br>    SELECT *<br>    FROM 表名<br>    LIMIT [START], length;<br>oracle语法：<br>    SELECT *FROM (<br>        SELECT 列名,列名,ROWNUM rn<br>        FROM 表名<br>        WHERE ROWNUM&lt;=(currentPage*lineSize)) temp<br>    WHERE temp.rn&gt;(currentPage-1)*lineSize;</p><p>简答和分析题集</p><p>20 java中有几种类型的流?JDK为每种类型的流提供了一些抽象类以提供继承，请说出他们分别是哪些类？<br>答：<br>（1）字节流，字符流。<br>（2）字节流继承于InputStream，OutputStream。<br>（3）字符流继承于Reader Writer。</p><p>21 使用处理流的优势有哪些？如何识别所使用的流是处理流还是节点流？<br>答：<br>优势：对开发人员来说，使用处理流进行输入/输出操作更简单。使用处理流的执行效率更高。<br>识别：处理流的构造器的参数不是一个物理节点，而是已经存在的流。而节点流都是直接以物理 IO 及节点作为构造器参数的。</p><p>22 什么是标准的IO流？<br>答：在java语言中用stdin表示键盘，用stdout表示监视器。它们被封装在System类的类变量 in 和 out 中，对应系统调用System,in 和 System,out。这样的两个流加上System.err统称为标准流。<br>System类中声明的3个类变量：<br>（1）public static InputStream in;<br>（2）public static PrinStream out;<br>（3）public static PriStram err;</p><p>23  什么能被序列化？什么不能被序列化？<br>答：<br>能被序列化：<br>（1）属性<br>（2）类型；<br>不能被序列化：<br>（1）static的属性；<br>（2）方法，<br>（3）加了transient修饰符的属性。</p><p>24 什么是java序列化，如何实现java序列化？<br>答：<br>（1）序列化而就是一种处理对象流的机制，所谓对象流也就是对象的内容进行流化。<br>（2）实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputSream对象，接着使用ObjectOutputSream对象的writeObject方法就可以将参数obj对象写出，要恢复的话则使用输入流。</p><p>1.抽象：<br>　答：<br>  抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p><p>2.继承：<br>　答：<br>  继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p><p>3.封装：<br>　答：<br>   封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p><ol start="4"><li>多态性：<br> 答：<br> 　多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</li></ol><p>5、String是最基本的数据类型吗?<br>　答：<br>  基本数据类型有8个，包括byte、short、int、long、char、float、double和boolean。<br>　java.lang.String是类，不属于基本数据类型。</p><p>6、int 和 Integer 有什么区别<br>　Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。</p><p>小张到X软件公司实习，第一天程序员老李为摸底，问了他一个问题：Java中的有8个基本数据类型，这破坏了面向对象的思想，为此Java提供了封装类，那么这些封装类具体有哪些？请代小张回答（至少回答出其中六个即可得满分）</p><p>Java为每个原始类型提供了封装类。<br>原始类型       封装类<br>boolean      Boolean<br>char          Character<br>byte          Byte<br>short          Short<br>int          Integer<br>long          Long<br>float          Float<br>double      Double<br>　引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p><p>7、实习程序员小张，接到X项目组经理命令完成某模块代码开发。在设计中，该模块算法中特别提到将有大量字符串的拼接。编码过程中，小张准备使用自己熟悉的String对象类完成这段代码，并向程序员老王征求意见，谁知老王否定了小张用String类型的方案，并建议他此处使用StringBuffer对象更合适，这令小张有些困惑。请帮小张分析下为何此处要用StringBuffer？<br>  即回答：String 和StringBuffer的区别<br>　答：<br>  JAVA平台提供了两个类：String和StringBuffer。<br>  String不是简单类型，而是一个类，它被用来表示字符序列。String的特点是一旦赋值，便不能更改其指向的字符对象，如果更改，则会生成一个新的字符串对象。<br>  StringBuffer是一个具有对象引用传递特点的字符串对象。StringBuffer对象可以调用其方法动态的进行增加、插入、修改和删除操作，从而实现多次插入字符，而不用担心像String类那样不断产生新对象而消耗内存，因而在字符串变化较多的操作中，效率更高。</p><p>9、&amp;和&amp;&amp;的区别。<br>   答： &amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p><p>10、final, finally的区别。<br>　　答：final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改（相当于常量）。被声明为final的方法也同样只能使用，不能覆盖。<br>    finally是异常处理语句结构的一部分，表示总是执行。一般在异常处理时提供 finally 块来执行任何清除操作。</p><p>11、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?<br>　  答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p><p>12、error和exception有什么区别?<br>　 答：error 表示恢复不是不可能但很困难的情况下的一种严重问题，是一种系统性的错误，程序本身不能处理这样的情况，比如说内存溢出。<br>      exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，是不会发生这种错误的。</p><p>13、abstract class和interface有什么区别?<br>　  答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。     Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>　   接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><p>14、GC是什么? 为什么要有GC?<br>　　答：1）GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或错误的内存回收会导致程序或系统的不稳定，甚至崩溃；2）Java提供的垃圾回收机制（GC）可以自动监测对象是否超过作用域从而达到自动回收内存的目的；3）Java不提供显示释放已分配内存的操作方法。</p><p>15、分析题<br>    1）short s1 = 1; s1 = s1 + 1;有什么错?<br>    答：short s1 = 1; s1 = s1 + 1; （s1+1运算结果是int型，int数据1给short型变量s1，需要强制转换类型）<br>    2）short s1 = 1; s1 += 1;有什么错?<br>    答：本题无措short s1 = 1; s1 += 1;（可以正确编译）</p><p>16、分析题：Math.round(11.5)等於多少? Math.round(-11.5)等於多少?<br>    答：Math.round(11.5)==12<br>        Math.round(-11.5)==-11<br>        round方法返回与参数最接近的长整数，参数加1/2后求其floor.</p><p>17、String s = new String(“xyz”);创建了几个String Object?<br>    答：两个对象，一个是在字符串池中的对象“xyx”,引用对象s指向的堆空间的对象“xyx”。其中，堆空间的对象“xyz”是字符串池中字符串“xyz”的副本。    </p><p>18、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?<br>　  答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。</p><p>19、数组有没有length()这个方法? String有没有length()这个方法？<br>　  答：数组没有length()这个方法，只有length的属性，用来得到数组元素个数。<br>        String有length()这个方法，用来得到字符串长度。</p><p>20、构造器Constructor是否可被override?<br>　  答：构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。</p><p>21、是否可以继承String类?<br>　  答：String类是final类，故不可以继承。</p><p>22、swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?<br>　  答：switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。<br>       long,string 都不能作用于swtich。</p><p>23、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?<br>　  答：会执行，在return前执行。</p><p>24、编程题: 用最有效率的方法算出2乘以8等於几?<br>    答：用位运算符“&lt;&lt;”，语句写为：2 &lt;&lt; 3;</p><p>25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<br>　  答：<br>    是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p><p>26、Java中的异常处理机制的简单原理和应用。<br>　   答：<br>     当JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。</p><p>27、描述一下JVM加载class文件的原理机制?<br>　  答：JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><p>28、char型变量中能不能存贮一个中文汉字?为什么?<br>　  答：能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的</p><p>29、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?<br>    答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>    同步的实现方面有两种，分别是synchronized,wait与notify</p><p>30、线程的基本概念、线程的基本状态以及状态之间的关系<br>　 答：<br>   线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。<br>   Java中的线程有四种状态分别是：运行、就绪、挂起、结束。 </p><p>=============================================<br>论述题<br>31、谈谈对Java语言中异常处理的理解？（<br>    1）可以从异常处理包含哪些关键字；每个关键字的含义或作用；引用异常处理后对开发有哪些帮助；异常处理机制的类体系结构；异常处理实现的底层机制等角度进行分析（但不限于这些角度）；<br>    2）能正确答出3个及以上点，且字数超过200字，则得满分。答案仅供参考，不唯一<br>   ）<br>    答：<br>    1、基本概念<br>    Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。</p><pre><code>2、5个主要关键字的作用用try来指定一块预防所有&quot;异常&quot;的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的&quot;异常&quot;的类型。finally为确保一段代码不管发生什么&quot;异常&quot;都被执行一段代码。throw语句用来明确地抛出一个&quot;异常&quot;。throws用来标明一个成员函数可能抛出的各种&quot;异常&quot;。3、实现的机制Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。4、采用异常处理机制的好处可以提高Java语言的处理错误能力；可以帮助程序员调试程序，发现开发中的问题，提高开发效率；可以让Java程序有健壮性，程序不容易崩溃；</code></pre><p>===========================================================</p><p>32、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>   答：1）可以。<br>       2）只有一个类的类名能与Java程序的该源文件名相同。</p><p>33、java中实现多态的机制是什么（Java借助什么实现多态性）？<br>　 答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。<br>      重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。</p><p>34、在JAVA中，如何跳出当前的多重嵌套循环？<br>    答：用break; return 方法。</p><p>35、Java是从（  B  ）语言改进重新设计而发展来的？<br>A. Ada    B. C++    C.Pascal  D.BASIC<br>分析：Java是从C、C++发展过来的</p><p>36、研究下面Java代码<br>public class TestException{<br>    public static void main(String args[]){<br>        try{<br>            System.out.println(“hello,jr”);<br>            System.exit(0);<br>        }finally{<br>            System.out.println(“88”);<br>        }<br>    }<br>}<br>输出结果为：（  A  ）<br>A. hello,jr<br>B. 88<br>C. hello,jr后是88<br>D. 不能编译<br>分析：System.exit(0);会中断程序，即使是finally都无法被执行</p><p>37、下面说法正确的有（  C   ）<br>A. class中的contructor不可省略<br>B. contructor必须与class同名，但方法不能与class同名<br>C. contructor在一个对象被new时执行<br>D. 一个class只能定义一个contructor</p><p>分析：contructor就是指的构造方法，普通方法也可以和类同名</p><p>38、在java中，已定义两个接口B和C，要定义一个实现这两个接口的类，以下语句正确的是（  C  ）<br>A. interface A extends B,C<br>B. interface A implements B,C<br>C. class A implements B,C<br>D. class A implements B,implements C</p><p>分析：类实现接口的基本语法</p><p>39、当编译并允许下面程序时，会发生什么结果？（   D   ）<br>public class Demo{<br>    protected Demo(){<br>        for(int i=0;i&lt;10;i++){<br>            System.out.println(i);<br>        }<br>    }</p><pre><code>public static void main(String args[])&#123;    Demo d=new Demo();&#125;</code></pre><p>}<br>A. 编译错误，构造方法不能被声明为protected<br>B. 允许错误，构造方法不能被声明为protected<br>C. 编译并运行输出0到10<br>D. 编译并运行输出0到9</p><p>分析：本题程序无错误可正常运行，构造方法是可以定义为protected的。</p><p>40、当编译和运行下面程序时，哪项描述可以最准确的表达发生了什么事情（   B    ）<br>public class MyAr{</p><pre><code>public void amethod()&#123;    int i;    System.out.println(i);    &#125;public static void main(String args[])&#123;    MyAr m=new MyAr();    m.amethod();&#125;</code></pre><p>}<br>A. 编译并输出0<br>B. 编译错误<br>C. 编译并输出null<br>D. 运行错误</p><p>分析： 方法amethod()中定义的变量：int i; 是一个方法级别的变量，必须手动赋予初值，否则编译错误。<br>       注意：成员变量系统给默认值，如果不显示手动赋值，依然是正确的。</p><p>41、给定java代码如下，关于super的用法，以下描述正确的是（    C   ）<br>class C extends B{<br>    public C(){<br>        super();<br>    }<br>}<br>A. 用来调用类B中定义的super()方法<br>B. 用来调用类C中定义的super()方法<br>C. 用来调用类B中的无参构造方法<br>D. 用来调用类B中第一个出现的构造方法</p><p>分析：super()的含义是用来调用父类（B）中不带参数的构造方法。super()的用法，一般出现在子类构造方法中第一行。</p><p>42、下列语句正确的是（   A  ）<br>A) 形式参数可被视为local variable<br>B) 形式参数可被字段修饰符修饰<br>C) 形式参数为方法被调用时，真正被传递的参数<br>D) 形式参数不可以是对象</p><p>分析：B项无此说法，C中被真正传递的是实参，D中形参可以使对象</p><p>43、以下代码输出结果为（  C    ）<br>public class Test{<br>    public static String output=””;</p><pre><code>public static void foo(int i)&#123;    try&#123;        if(i==1)            throw new Exception();        output+=&quot;1&quot;;                &#125;catch(Exception e)&#123;        output+=&quot;2&quot;;        return ;    &#125;finally&#123;        output+=&quot;3&quot;;        output+=&quot;4&quot;;    &#125;&#125;public static void main(String args[])&#123;    foo(0);    foo(1);    System.out.println(output);&#125;</code></pre><p>}<br>A. 1342        B. 123        C. 134234    D. 13423</p><p>分析：本题中，foo(0)时，if语句if(i==1)throw new Exception();不满足条件，不会抛出异常，因此此时output值为“134”；<br>      紧接着执行foo(1)时，if语句if(i==1)throw new Exception();满足条件，抛出异常，执行catch语句，output值变成“1342”；<br>      最难点在于此时碰到了return，是否还会执行finally语句，答案是会执行，因此最后output值变成“134234”；答案为C。</p><p>44、在Java中，下列（  D    ）类不能派生出子类？<br>A) public class MyClass{ … }<br>B) class MyClass{ … }<br>C) abstract class MyClass{ … }<br>D) final class MyClass{    … }</p><p>分析：类前面可以有public和默认两种权限，一般都能被子类继承，因此A、B答案可以派生子类<br>      C答案是抽象类，也可以被继承<br>      D答案是final修饰的类，是最终类，不允许被继承。</p><p>45、编译和运行下面代码时显示结果是（     ）<br>public class Conv{<br>    public static void main(String argv[]){<br>            Conv c=new Conv();<br>            String s=new String(“ello”);<br>            c.amethod(s);<br>    }<br>    public void amethod(String s){<br>            char c=’H’;<br>            c+=s;<br>            System.out.println(c);<br>    }<br>}<br>A、Hello<br>B、ello<br>C、elloH<br>D、编译错误<br>解答：D<br>分析：c是字符类型，s是字符串类型，字符型无法自动转换成字符串类型，因此语句c+=s;类型不兼容，有语法错误，故答案是D<br>修改方案：将char c=’H’;语句变为String c=”H”;</p><p>46、当下列程序执行时，其输出结果是（     ）。<br>int i=9;<br>switch (i) {<br> default:<br> System.out.println(“default”);<br> case 0:<br> System.out.println(“zero”);<br> break;<br> case 1:<br> System.out.println(“one”);<br> case 2:<br> System.out.println(“two”);<br>}<br>A、default<br>B、default, zero<br>C、错误： default 子句没有定义<br>D、没有输出结果<br>解答：Ｂ<br>原因：程序开始遇到default关键字，会执行其语句块中语句，输出“default”；<br>由于default语句块中没有结束switch语句的关键字break;<br>所以程序会继续执行其他case块中语句，并且无需验证case的值匹配；运行到case 0语句块时，首先输出“zero”，最后碰到break语句，结束整个switch语句块。<br>故最后输出结果：<br>default<br>zero</p><p>47、阅读下列代码，其正确的结果是（     ）。<br>publicclass Test2 {<br>    static boolean foo(char c) {<br>       System.out.print(c);<br>       return true;<br>    }<br>    Public static void main(String[] argv) {<br>       int i = 0;<br>       //for(65;88&amp;&amp;(i&lt;2);67)<br>       for (foo(‘A’); foo(‘B’) &amp;&amp; (i &lt; 2); foo(‘C’)) {<br>           i++;<br>           foo(‘D’);<br>       }<br>    }<br>}<br>A. ABDCBDCB<br>B. ABCDABCD<br>C. Compilation fails.<br>D. An exception is thrown at runtimeB、1<br>解答：A</p><p>48、有以下程序段：<br>class MyThread extends Thread {<br>    public static void main(String args[]) {<br>        MyThread t = new MyThread();<br>        MyThread s = new MyThread();<br>        t.start();<br>        System.out.print(“one.”);<br>        s.start();<br>        System.out.print(“two.”);<br>    }<br>    public void run() {<br>        System.out.print(“Thread”);<br>    }<br>}<br>则下列选项说法正确的是（     ）。<br>A、编译失败<br>B、程序运行结果为：one.Threadtwo.Thread<br>C、程序运行结果是：one.two.ThreaThread<br>D、程序运行结果不确定<br>解答：D<br>分析：线程是并行运行，故结果输出顺序是不确定。<br>部分同学计算机运行几次时，可能会发现结果确定，<br>是因计算机速度太快导致，可以多次运行十几次或几十次，可以发现结果有变化</p><p>49、仔细分析下面程序，其正确的输出结果是（     ）。<br>publicclass Test1 {<br>    public static void changeStr(String str){   //②str<br>        str=”welcome”;<br>    }<br>    public staticvoid main(String[] args) {<br>        String str=”1234”;               //①str<br>        changeStr(str);<br>        System.out.println(str);<br>    }<br>}<br>A、welcome<br>B、welcome1234<br>C、1234<br>D、1234welcome<br>解答：C</p><p>分析：<br>1）主方法中的①号变量str是实际参数，changeStr(String str)中的②号str是形式参数，虽然是两个同名字变量，但实际是两个变量。</p><p>2）Java字符串基于字符串池实现，虽然①号str传值给了②号str，并且传的是引用，<br>   但②号str中执行语句str=”welcome”;后，并没有修改”1234”这个值本身，而是在字符串池中，新增加了一个字符串常量”welcome”，<br>   ②号str的引用指向了新的”welcome”值，但①号str指向的值”1234”没有被修改，因此主方法中打印输出的①号str的值还是1234</p><p>3）这里要注意，正常情况下，给方法的参数传值，当值是对象类型时，是引用传递。（若是基本数据类型，则是值传递）<br>   引用传递的确是可以利用方法来修改引用指向对的成员变量值的，字符串类（String）因其实现的机制是基于字符串池，故情况特殊<br>   参见下面代码对比：</p><p>class Stu{<br>    int stuAge;<br>}<br>public class Test1 {<br>    public static void changeStu(Stu stu){<br>        stu.stuAge=100;<br>    }<br>    public static void changeStr(String str){<br>        str=”welcome”;<br>    }<br>    public static void main(String[] args) {<br>        String str=”1234”;<br>        changeStr(str);               //Java字符串基于字符串池实现，因此不是简单的传递引用<br>        System.out.println(str);<br>//        Stu s=new Stu();<br>//        s.stuAge=20;<br>//        changeStu(s);                //对象类型传的是引用<br>//        System.out.println(s.stuAge);//输出100<br>    }<br>}  </p><p>50、下面2个文件位于相同目录下，编译运行后会出现的情况是（      ）。<br>//File P1.java<br>package MyPackage;<br>class P1{<br>void afancymethod(){<br>        System.out.println(“What a fancy method”);<br>        }<br>}<br>//File P2.java<br>public class P2 extends P1{<br>    public static void main(String argv[]){<br>    P2 p2 = new P2();<br>    p2.afancymethod();<br>    }<br>}<br>A、2个文件都可以编译，P2运行输出“What a fancy method”<br>B、2个文件都不能编译<br>C、2个文件都可以编译，P2运行时报错误<br>D、P1编译成功，P2编译时报错误<br>解答：D</p><p>51、编译和运行下面代码时显示的结果是（     ）。<br>public class MyClass{<br> static int i;<br> public static void main(String argv[]){<br>     System.out.println(i);<br> }<br>}<br>A、Error Variable i may not have been initializenull<br>C、1<br>D、0<br>解答：D<br>分析：本题能正常运行，static int i;中定义的i是静态成员变量，Java中成员变量默认给了初值，整型的初值是0，故此题正确</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;1、列举出四种及以上Java的容器类（即集合类）？&lt;br&gt;Set、List、Queue、Map、ArrayList、HashSet、HashMap&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>fastapi多文件</title>
    <link href="http://example.com/2021/07/22/fastapi%E5%A4%9A%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/07/22/fastapi%E5%A4%9A%E6%96%87%E4%BB%B6/</id>
    <published>2021-07-22T04:04:43.122Z</published>
    <updated>2021-07-22T04:04:22.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><a id="more"></a><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">├── app<br>│   ├── __init__.<span class="hljs-keyword">py</span><br>│   ├── main.<span class="hljs-keyword">py</span><br>│   ├── dependencies.<span class="hljs-keyword">py</span><br>│   └── routers<br>│   │   ├── __init__.<span class="hljs-keyword">py</span><br>│   │   ├── <span class="hljs-built_in">items</span>.<span class="hljs-keyword">py</span><br>│   │   └── users.<span class="hljs-keyword">py</span><br>│   └── internal<br>│       ├── __init__.<span class="hljs-keyword">py</span><br>│       └── admin.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><ul><li><code>app</code> 目录包含了所有内容。并且它有一个空文件 <code>app/__init__.py</code>，因此它是一个「Python 包」（「Python 模块」的集合）：<code>app</code>。</li><li>它包含一个 <code>app/main.py</code> 文件。由于它位于一个 Python 包（一个包含 <code>__init__.py</code> 文件的目录）中，因此它是该包的一个「模块」：<code>app.main</code>。</li><li>还有一个 <code>app/dependencies.py</code> 文件，就像 <code>app/main.py</code> 一样，它是一个「模块」：<code>app.dependencies</code>。</li><li>有一个子目录 <code>app/routers/</code> 包含另一个 <code>__init__.py</code> 文件，因此它是一个「Python 子包」：<code>app.routers</code>。</li><li>文件 <code>app/routers/items.py</code> 位于 <code>app/routers/</code> 包中，因此它是一个子模块：<code>app.routers.items</code>。</li><li>同样适用于 <code>app/routers/users.py</code>，它是另一个子模块：<code>app.routers.users</code>。</li><li>还有一个子目录 <code>app/internal/</code> 包含另一个 <code>__init__.py</code> 文件，因此它是又一个「Python 子包」：<code>app.internal</code>。</li><li><code>app/internal/admin.py</code> 是另一个子模块：<code>app.internal.admin</code>。</li></ul><h2 id="APIRouter"><a href="#APIRouter" class="headerlink" title="APIRouter"></a>APIRouter</h2><p>可以使用<code>APIRouter</code>为模块创建路径操作，可以与<code>FastAPI</code>类相同的方式创建一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入APIRouter</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter<br><span class="hljs-comment">#创建一个实例</span><br>router = APIRouter()<br><br><span class="hljs-comment">#像FastAPI一样创建路径操作，相当于一个迷你的FastAPI类</span><br><span class="hljs-meta">@router.get(&quot;/users/&quot;, tags=[&quot;users&quot;])</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_users</span>():</span><br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;Rick&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;Morty&quot;</span>&#125;]<br><br><br><span class="hljs-meta">@router.get(&quot;/users/me&quot;, tags=[&quot;users&quot;])</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_user_me</span>():</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;fakecurrentuser&quot;</span>&#125;<br><br><br><span class="hljs-meta">@router.get(&quot;/users/&#123;username&#125;&quot;, tags=[&quot;users&quot;])</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_user</span>(<span class="hljs-params">username: str</span>):</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: username&#125;<br></code></pre></td></tr></table></figure><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><p><code>dependencies</code> 模块（<code>app/dependencies.py</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Header, HTTPException<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_token_header</span>(<span class="hljs-params">x_token: str = Header(<span class="hljs-params">...</span>)</span>):</span><br><br>    <span class="hljs-keyword">if</span> x_token != <span class="hljs-string">&quot;fake-super-secret-token&quot;</span>:<br><br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&quot;X-Token header invalid&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_query_token</span>(<span class="hljs-params">token: str</span>):</span><br>    <span class="hljs-keyword">if</span> token != <span class="hljs-string">&quot;jessica&quot;</span>:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&quot;No Jessica token provided&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="其他使用APIRouter的模块"><a href="#其他使用APIRouter的模块" class="headerlink" title="其他使用APIRouter的模块"></a>其他使用APIRouter的模块</h2><p><code>app/routers/items.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Depends, HTTPException<br><br><span class="hljs-keyword">from</span> ..dependencies <span class="hljs-keyword">import</span> get_token_header<br><br><span class="hljs-comment">#给该模块下的所有路径操作进行统一的设置</span><br>router = APIRouter(<br>    prefix=<span class="hljs-string">&quot;/items&quot;</span>,  <span class="hljs-comment">#设置了路径， 地址都变成了 /items/xxxx</span><br>    tags=[<span class="hljs-string">&quot;items&quot;</span>],   <span class="hljs-comment">#设置了标签</span><br>    dependencies=[Depends(get_token_header)],  <span class="hljs-comment">#设置了依赖</span><br>    responses=&#123;<span class="hljs-number">400</span>:&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;NOT found&quot;</span>&#125;&#125;  <span class="hljs-comment">#设置了response</span><br>)<br><br>fake_items_db = &#123;<span class="hljs-string">&quot;plumbus&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;pty&quot;</span>&#125;,<span class="hljs-string">&quot;gun&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;gun&quot;</span>&#125;&#125;<br><br><br><span class="hljs-meta">@router.get(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_items</span>():</span><br>    <span class="hljs-keyword">return</span> fake_items_db<br><br><span class="hljs-meta">@router.get(&quot;/&#123;item_id&quot;)  #路径变为：/items/&#123;item_id&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_item</span>(<span class="hljs-params">item_id:str</span>):</span><br>    <span class="hljs-keyword">if</span> item_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> fake_items_db:<br>        <span class="hljs-keyword">raise</span>  HTTPException(status_code=<span class="hljs-number">400</span>,detail=<span class="hljs-string">&quot;not found&quot;</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:fake_items_db[item_id][<span class="hljs-string">&quot;name&quot;</span>],<span class="hljs-string">&quot;item_id&quot;</span>:item_id&#125;<br><br><span class="hljs-comment">#还可以再为某个路径操作单独设置，这样会和之前统一设置的进行叠加</span><br><span class="hljs-meta">@router.put(</span><br>    <span class="hljs-string">&quot;/&#123;item_id&#125;&quot;</span>,<br>    tags=[<span class="hljs-string">&quot;custom&quot;</span>],  <span class="hljs-comment">#有两个tags，items和custom</span><br>    responses=&#123;<span class="hljs-number">403</span>:&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;operation&quot;</span>&#125;&#125; <span class="hljs-comment">#有两个response：404和403</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_item</span>(<span class="hljs-params">item_id:str</span>):</span><br>    <span class="hljs-keyword">if</span> item_id!=<span class="hljs-string">&quot;plumbus&quot;</span>:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">403</span>,detail=<span class="hljs-string">&quot;you can only update plumbus&quot;</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;item_id&quot;</span>:item_id,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;the great&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>需要设置<code>dependencies</code>的时候的格式，<code>dependencies=[Depends(get_token_header)]</code>      <code>Depends</code>要用[]括起来了，我之前没括起来，报错</strong></p><h2 id="FastAPI主体"><a href="#FastAPI主体" class="headerlink" title="FastAPI主体"></a>FastAPI主体</h2><p>位于 <code>app/main.py</code> 的模块，在这里导入并使用<code>FastAPI</code>类，这将是你的应用程序中将所有内容联结在一起的主文件。</p><p>由于大部分逻辑都存在于自己的特定模块中，所以主文件的内容将非常简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends<br><br><span class="hljs-keyword">from</span> .dependencies <span class="hljs-keyword">import</span> get_token_header, get_query_token<br><span class="hljs-keyword">from</span> .internal <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .routers <span class="hljs-keyword">import</span> items, users<br><br><span class="hljs-comment">#需要注意这里的格式，Depends用[]括起来了，我之前没括起来，报错</span><br>app=FastAPI(dependencies=[Depends(get_query_token)])<br><br><span class="hljs-comment">#</span><br>app.include_router(items.router)<br>app.include_router(users.router)<br><br><span class="hljs-comment">#可以在主文件中对其他文件的router进行设置</span><br><span class="hljs-comment">#对interal/admin.py进行router设置</span><br>app.include_router(<br>    admin.router,<br>    prefix=<span class="hljs-string">&quot;/admin&quot;</span>,<br>    tags=[<span class="hljs-string">&quot;admin&quot;</span>],<br>    dependencies=[Depends(get_token_header)],<br>    responses=&#123;<span class="hljs-number">418</span>:&#123;<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;i&#x27;m a teapot&quot;</span>&#125;&#125;<br>)<br><br>app.get(<span class="hljs-string">&quot;/&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span>():</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="避免名称冲突"><a href="#避免名称冲突" class="headerlink" title="避免名称冲突"></a>避免名称冲突</h3><p>我们将直接导入 <code>items</code> 子模块，而不是仅导入其 <code>router</code> 变量。</p><p>这是因为我们在 <code>users</code> 子模块中也有另一个名为 <code>router</code> 的变量。</p><p>如果我们一个接一个地导入，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> .routers.items <span class="hljs-keyword">import</span> router<br><span class="hljs-keyword">from</span> .routers.users <span class="hljs-keyword">import</span> router<br></code></pre></td></tr></table></figure><p>来自 <code>users</code> 的 <code>router</code> 将覆盖来自 <code>items</code> 中的 <code>router</code>，我们将无法同时使用它们。</p><h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p>在上面我们会看到这样的代码，这些是从我们的文件中导入的模块，他们是怎么工作的呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .dependencies <span class="hljs-keyword">import</span> get_token_header, get_query_token<br><span class="hljs-keyword">from</span> .internal <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .routers <span class="hljs-keyword">import</span> items, users<br></code></pre></td></tr></table></figure><p>一个单点 <code>.</code>，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> .<span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">import</span> get_token_header<br></code></pre></td></tr></table></figure><p>表示：</p><ul><li>从该模块（<code>app/routers/items.py</code> 文件）所在的同一个包（<code>app/routers/</code> 目录）开始…</li><li>找到 <code>dependencies</code> 模块（一个位于 <code>app/routers/dependencies.py</code> 的虚构文件）…</li><li>然后从中导入函数 <code>get_token_header</code>。</li></ul><p>两个点 <code>..</code>，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> ..<span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">import</span> get_token_header<br></code></pre></td></tr></table></figure><p>表示：</p><ul><li>从该模块（<code>app/routers/items.py</code> 文件）所在的同一个包（<code>app/routers/</code> 目录）开始…</li><li>跳转到其父包（<code>app/</code> 目录）…</li><li>在该父包中，找到 <code>dependencies</code> 模块（位于 <code>app/dependencies.py</code> 的文件）…</li><li>然后从中导入函数 <code>get_token_header</code>。</li></ul><p>同样，如果我们使用了三个点 <code>...</code>，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">from</span> ...<span class="hljs-keyword">dependencies</span> <span class="hljs-keyword">import</span> get_token_header<br></code></pre></td></tr></table></figure><p>那将意味着：</p><ul><li>从该模块（<code>app/routers/items.py</code> 文件）所在的同一个包（<code>app/routers/</code> 目录）开始…</li><li>跳转到其父包（<code>app/</code> 目录）…</li><li>然后跳转到该包的父包（该父包并不存在，<code>app</code> 已经是最顶层的包 😱）…</li><li>在该父包中，找到 <code>dependencies</code> 模块（位于 <code>app/</code> 更上一级目录中的 <code>dependencies.py</code> 文件）…</li><li>然后从中导入函数 <code>get_token_header</code>。</li></ul><p><code>from .routers import items, users</code></p><p>表示：</p><ul><li>从该模块（<code>app/main.py</code> 文件）所在的同一个包（<code>app/</code> 目录）开始…</li><li>寻找 <code>routers</code> 子包（位于 <code>app/routers/</code> 的目录）…</li><li>从该包中，导入子模块 <code>items</code> (位于 <code>app/routers/items.py</code> 的文件) 以及 <code>users</code> (位于 <code>app/routers/users.py</code> 的文件)…</li></ul><p><code>items</code> 模块将具有一个 <code>router</code> 变量（<code>items.router</code>）。这与我们在 <code>app/routers/items.py</code> 文件中创建的变量相同，它是一个 <code>APIRouter</code> 对象。</p><p>然后我们对 <code>users</code> 模块进行相同的操作。</p><h3 id="绝对引入"><a href="#绝对引入" class="headerlink" title="绝对引入"></a>绝对引入</h3><p><code>from app.routers import items, users</code>    如果是这种样子的话，就是绝对引入</p><h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><p><img src="/.com//Users\彭天怡\AppData\Roaming\Typora\typora-user-images\image-20210721180819459.png" alt="image-20210721180819459"></p><p><strong>API文档界面如上，可以看到因为给每个模块设置了tags，所以分成了不同的类，而<code>/items/&#123;item_id&#125;</code>因为设置了两个tags(统一设置了一个items，自己单独设置了custom)，所以显示出了两个。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;文件结构&quot;&gt;&lt;a href=&quot;#文件结构&quot; class=&quot;headerlink&quot; title=&quot;文件结构&quot;&gt;&lt;/a&gt;文件结构&lt;/h2&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python连接mysql</title>
    <link href="http://example.com/2021/07/22/python%20%E8%BF%9E%E6%8E%A5mysql/"/>
    <id>http://example.com/2021/07/22/python%20%E8%BF%9E%E6%8E%A5mysql/</id>
    <published>2021-07-22T04:04:40.972Z</published>
    <updated>2021-07-22T06:36:30.951Z</updated>
    
    <content type="html"><![CDATA[<p>在看fastapi的官方文档，然后感觉sql部分挺难的，于是写下一篇博客来记录下。</p><h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><p>首先要安装两个东西</p><p><code>pip install sqlalchemy</code></p><p><code>pip install pymysql</code></p><p>前者是一个ORM框架，在ORM中，你创建一个类就会通过SQLAlchemy将其自动转成一张表，在类中的每一个属性就会转成表中的字段。</p><p>后者是用来连接数据库的</p><a id="more"></a><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>└── <span class="hljs-selector-tag">sql_app</span><br>    ├── __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">crud</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">database</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span><br>    ├── <span class="hljs-selector-tag">models</span><span class="hljs-selector-class">.py</span><br>    └── <span class="hljs-selector-tag">schemas</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><ul><li>sql_app是包名，注意是创建一个包，而不是创建一个目录</li><li><code>_init_.py</code>是一个空文件，创建sql_app会自动创建这个文件</li><li><code>crud.py</code>是用来进行crud操作的文件</li><li><code>database.py</code>是用来连接数据库的</li><li><code>main.py</code>是用来接受前端请求，类似于controller层</li><li><code>models.py</code>是用来创建SQLAlchemy模型的，也就是创建表</li><li><code>schemas.py</code>是用来创建Pydentic模型的</li></ul><h2 id="database-py"><a href="#database-py" class="headerlink" title="database.py"></a>database.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, declarative_base<br><br><span class="hljs-comment">#连接数据库的url</span><br>SQLALCHEMY_DATABASES_URL =<span class="hljs-string">&quot;mysql+pymysql://root:123456@localhost:3306/python&quot;</span><br><br><span class="hljs-comment">#echo=True表示引擎将用repr()函数记录所有语句及其参数列表到日志</span><br>engine = create_engine(SQLALCHEMY_DATABASES_URL,encoding=<span class="hljs-string">&quot;utf8&quot;</span>,echo=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment">#SQLAlchemy中，CRUD是通会话进行管理的，所以需要先创建会话</span><br><span class="hljs-comment">#每一个SessionLocal实例就是一个数据库会话</span><br><span class="hljs-comment">#commit是指提交事务，将变更保存到数据库</span><br><span class="hljs-comment">#flush是指发送到数据库语句到数据库，但数据库不一定执行写入磁盘</span><br><span class="hljs-comment">#autocommit和autoflush是可以不写的</span><br>SessionLocal = sessionmaker(autocommit=<span class="hljs-literal">False</span>,autoflush=<span class="hljs-literal">False</span>,bind=engine)<br><br><span class="hljs-comment">#创建基本映射类</span><br>Base = declarative_base()<br></code></pre></td></tr></table></figure><p><strong>在数据库相关的配置文件中，首先创建一个SQLAlchemy的”engine”，然后创建SessionLocal实例进行会话，最后创建模型类的基类。</strong></p><h2 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Integer, String, Boolean, ForeignKey<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> relationship<br><br><span class="hljs-keyword">from</span> .database <span class="hljs-keyword">import</span> Base<br><br><span class="hljs-comment">#使用database.py创建的Base类创建SQLAlchemy模型</span><br><span class="hljs-comment">#可以理解为这个是与真正的数据库相关联的类</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">Base</span>):</span><br>    <span class="hljs-comment">#对应的是数据库中的表名</span><br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-comment">#设置表的属性名，使用Column设置，定义了属性的类型</span><br>    id = Column(Integer,primary_key=<span class="hljs-literal">True</span>,index=<span class="hljs-literal">True</span>)<br>    email = Column(String(<span class="hljs-number">32</span>),unique=<span class="hljs-literal">True</span>,index=<span class="hljs-literal">True</span>)<br>    hashed_password = Column(String(<span class="hljs-number">32</span>))<br>    is_active = Column(Boolean,default=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment">#设置关系，通过relationship设置，这个不是属性，在数据库中不需要有这一个字段</span><br>    <span class="hljs-comment">#当访问users.items时，会直接关联到Item表，可以直接获取到Item的字段数据</span><br>    <span class="hljs-comment">#后面的back_populates是反向查询，有这个Item表可以通过items.owner访问到User表的字段数据</span><br>    <span class="hljs-comment">#使用了back_populates,那么被关联的数据库也要显示的使用relationship</span><br>    <span class="hljs-comment">#这个其实我也还不是太懂</span><br>    items = relationship(<span class="hljs-string">&quot;Item&quot;</span>,back_populates=<span class="hljs-string">&quot;owner&quot;</span>)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>(<span class="hljs-params">Base</span>):</span><br>    __tablename__ = <span class="hljs-string">&quot;items&quot;</span><br><br>    id=Column(Integer,primary_key=<span class="hljs-literal">True</span>,index=<span class="hljs-literal">True</span>)<br>    title = Column(String(<span class="hljs-number">32</span>),index=<span class="hljs-literal">True</span>)<br>    description = Column(String(<span class="hljs-number">32</span>) , index=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment">#设置了外键，使用ForeignKey参数设置，里面填写关联的表和具体的属性</span><br>    <span class="hljs-comment">#注意这里是表名而不是上面的类名</span><br>    owner_id  = Column(Integer,ForeignKey(<span class="hljs-string">&quot;users.id&quot;</span>))<br><br>    owner = relationship(<span class="hljs-string">&quot;User&quot;</span>,back_populates=<span class="hljs-string">&quot;items&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>通过数据库配置文件中的基类来创建模型类。</strong></p><h2 id="schemas-py"><a href="#schemas-py" class="headerlink" title="schemas.py"></a>schemas.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, List<br><br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemBase</span>(<span class="hljs-params">BaseModel</span>):</span><br>    title:str<br>    description:Optional[str]=<span class="hljs-literal">None</span><br><br><br><span class="hljs-comment">#这个是用来创建Item的类，可以理解为前端传过来的要新增的数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemCreate</span>(<span class="hljs-params">ItemBase</span>):</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment">#继承自ItemBase</span><br><span class="hljs-comment">#Pydantic风格是声明类型，所以用的是:</span><br><span class="hljs-comment">#SQLAlchemy风格是定义属性，所以用的是=</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>(<span class="hljs-params">ItemBase</span>):</span><br>    id: int<br>    owner_id: int<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>:</span><br>        orm_mode=<span class="hljs-literal">True</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBase</span>(<span class="hljs-params">BaseModel</span>):</span><br>    email:str<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCreate</span>(<span class="hljs-params">UserBase</span>):</span><br>    password:str<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">UserBase</span>):</span><br>    id: int<br>    is_active: bool<br>    items: List[Item]=[]<br><br>    <span class="hljs-comment">#Config类用来给Pydantic提供配置信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>:</span><br>        <span class="hljs-comment">#orm_mode出了可以让Pydantic读取字典类型的数据，还支持Pydantic读取属性数据，比如SQLAlchemy模型的数据</span><br>        <span class="hljs-comment">#这样我们就可以在路径操作函数中直接返回SQLAlchemy数据模型，没有这个配置项是不支持的</span><br>        orm_mode = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>定义请求参数模型验证与响应模型验证的Pydantic模型，其中响应模型中设置orm_mode=True参数，表示与ORM模型兼容，因为后续中返回的数据库查询是orm模型，通过设置这个参数可以将orm模型通过pydantic模型进行验证。</strong></p><h2 id="crud-py"><a href="#crud-py" class="headerlink" title="crud.py"></a>crud.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> models, schemas<br><br><br><span class="hljs-comment">#通过id查询用户</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span>(<span class="hljs-params">db:Session,user_id: int</span>):</span><br>    <span class="hljs-comment">#返回的是models.User(其实就是users表)中的全部属性，并且条件是user_id = users中的id</span><br>    <span class="hljs-keyword">return</span> db.query(models.User).filter(models.User.id==user_id).first()<br><br><span class="hljs-comment">#通过email查询用户</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user_by_email</span>(<span class="hljs-params">db:Session,email:str</span>):</span><br>    <span class="hljs-comment">#条件是邮箱相等</span><br>    <span class="hljs-keyword">return</span>  db.query(models.User).filter(models.User.email == email).first()<br><br><span class="hljs-comment">#查询多个用户</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_users</span>(<span class="hljs-params">db:Session,skip:int = <span class="hljs-number">0</span>,limit:int =<span class="hljs-number">100</span></span>):</span><br>    <span class="hljs-comment">#offset表示偏移量，0表示不偏移,1表示偏移1条数据，即从第二条开始</span><br>    <span class="hljs-comment">#limit表示表示限定数量</span><br>    <span class="hljs-comment">#从第一条开始,查询100条数据，返回的是个列表</span><br>    <span class="hljs-keyword">return</span> db.query(models.User).offset(skip).limit(limit).all()<br><br><span class="hljs-comment">#增加数据</span><br><span class="hljs-comment">#将前端传过来的数据保存到数据库</span><br><span class="hljs-comment">#传过来的数据是Pydantic模型，需要先转换为SQLAlchemy模型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">db:Session,user:schemas.UserCreate</span>):</span><br>    <span class="hljs-comment">#密码哈希化(伪造)</span><br>    fake_hashed_password = user.password+<span class="hljs-string">&quot;pty123&quot;</span><br>    <span class="hljs-comment">#user是Pydantic模型的，重新创建db_user,db_user是SQLALchemy类型的</span><br>    db_user = models.User(email=user.email,hashed_password=fake_hashed_password)<br>    <span class="hljs-comment">#添加到数据库</span><br>    db.add(db_user)<br>    <span class="hljs-comment">#提交</span><br>    db.commit()<br>    <span class="hljs-comment">#刷新</span><br>    db.refresh(db_user)<br>    <span class="hljs-keyword">return</span> db_user<br><br><span class="hljs-comment">#查询多个项目</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_items</span>(<span class="hljs-params">db:Session,skip:int = <span class="hljs-number">0</span>,limit :int=<span class="hljs-number">100</span></span>):</span><br>    <span class="hljs-keyword">return</span> db.query(models.Item).offset(skip).limit(limit).all()<br><br><br><span class="hljs-comment">#增加数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user_item</span>(<span class="hljs-params">db:Session,item:schemas.ItemCreate,user_id:int</span>):</span><br>    db_item = models.Item(**item.dict(),owner_id = user_id)<br>    db.add(db_item)<br>    db.commit()<br>    db.refresh(db_item)<br>    <span class="hljs-keyword">return</span> db_item<br></code></pre></td></tr></table></figure><p><strong>通过传入数据库连接以及参数等进行数据库操作，包括创建用户、查询用户等，返回的是orm模型对象。</strong></p><h2 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends,HTTPException<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> schemas, crud, models<br><span class="hljs-keyword">from</span> .database <span class="hljs-keyword">import</span> SessionLocal, engine<br><br><span class="hljs-comment">#创建数据库，就算你没有自己创建表，orm会根据models中的类自动创建表</span><br>models.Base.metadata.create_all(bind=engine)<br><br>app=FastAPI()<br><br><span class="hljs-comment">#Dependency</span><br><span class="hljs-comment">#每一个请求完毕后都需要关闭当前的数据库会话，不同请求使用不同的数据库会话</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_db</span>():</span><br>    db=SessionLocal()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db<br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br><br><span class="hljs-meta">@app.post(&quot;/users/&quot;,response_model=schemas.User)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_user</span>(<span class="hljs-params">user:schemas.UserCreate,db:Session=Depends(<span class="hljs-params">get_db</span>)</span>):</span><br>    <span class="hljs-keyword">return</span> crud.create_user(db,user)<br><br><span class="hljs-meta">@app.get(&quot;/user/&#123;user_id&#125;&quot;,response_model=schemas.User)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_user</span>(<span class="hljs-params">user_id: int,db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):</span><br>    db_user =crud.get_user(db,user_id)<br>    <span class="hljs-keyword">if</span> db_user <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span>  HTTPException(status_code=<span class="hljs-number">404</span>,detail=<span class="hljs-string">&quot;User not found&quot;</span>)<br>    <span class="hljs-keyword">return</span> db_user<br><br><span class="hljs-comment">#这里返回多个对象，需要使用List，一开始没用，报错了</span><br><span class="hljs-meta">@app.get(&quot;/users/&quot;,response_model=List[schemas.User])</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_usres</span>(<span class="hljs-params">skip: int=<span class="hljs-number">0</span>,limit :int=<span class="hljs-number">100</span>,db:Session = Depends(<span class="hljs-params">get_db</span>)</span>):</span><br>  <span class="hljs-keyword">return</span>  crud.get_users(db,skip,limit)<br></code></pre></td></tr></table></figure><p><strong>主文件进行数据库初始化、FastAPI实例创建以及处理各种请求。</strong></p><h2 id="SQLAlchemy的查询语句"><a href="#SQLAlchemy的查询语句" class="headerlink" title="SQLAlchemy的查询语句"></a>SQLAlchemy的查询语句</h2><h3 id="查询执行器"><a href="#查询执行器" class="headerlink" title="查询执行器"></a>查询执行器</h3><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">all()</td><td align="center">返回一个元素为查询结果的列表</td></tr><tr><td align="center">count()</td><td align="center">返回查询结果的数量</td></tr><tr><td align="center">first()</td><td align="center">返回第一个结果或None</td></tr><tr><td align="center">first_or_404()</td><td align="center">返回第一个结果或404</td></tr><tr><td align="center">get(主键)</td><td align="center">返回主键对应的对象或None</td></tr><tr><td align="center">get_or_404(主键)</td><td align="center">返回主键对应的对象或404</td></tr><tr><td align="center">paginate(页码，每页条数)</td><td align="center">返回一个分页查询结果</td></tr></tbody></table><h3 id="查询过滤器"><a href="#查询过滤器" class="headerlink" title="查询过滤器"></a>查询过滤器</h3><table><thead><tr><th align="center">过滤器</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">filter_by(字段名=值)</td><td align="center">等值查询</td></tr><tr><td align="center">filter(函数引用/比较运算)</td><td align="center">函数或比较查询</td></tr><tr><td align="center">limit(限定条数)</td><td align="center">限定返回结果数量</td></tr><tr><td align="center">offset(偏移条数)</td><td align="center">偏移1即从第二条开始查询</td></tr><tr><td align="center">order_by(排序字段)</td><td align="center">对查询结果根据字段进行排序</td></tr><tr><td align="center">options()</td><td align="center">针对原查询限定查询的字段</td></tr></tbody></table><h2 id="relationship"><a href="#relationship" class="headerlink" title="relationship"></a>relationship</h2><p>在构建SQLAlchemy模型的时候，relationship我觉得有点难，可以看一下这篇博客，感觉讲的比较详细。</p><p><a href="https://www.cnblogs.com/goldsunshine/p/9269880.html">sqlalchemy外键和relationship查询</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在看fastapi的官方文档，然后感觉sql部分挺难的，于是写下一篇博客来记录下。&lt;/p&gt;
&lt;h2 id=&quot;安装工具&quot;&gt;&lt;a href=&quot;#安装工具&quot; class=&quot;headerlink&quot; title=&quot;安装工具&quot;&gt;&lt;/a&gt;安装工具&lt;/h2&gt;&lt;p&gt;首先要安装两个东西&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install sqlalchemy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install pymysql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前者是一个ORM框架，在ORM中，你创建一个类就会通过SQLAlchemy将其自动转成一张表，在类中的每一个属性就会转成表中的字段。&lt;/p&gt;
&lt;p&gt;后者是用来连接数据库的&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
</feed>
