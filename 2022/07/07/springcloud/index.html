

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="努力最坏的结果不过是大器晚成">
  <meta name="author" content="pty">
  <meta name="keywords" content="">
  
  <title>springcloud - Pety&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"placement":"right"},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"follow_dnt":true}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Pety's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Pety</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/message.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="springcloud">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-07 01:52" pubdate>
        July 7, 2022 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      320
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">springcloud</h1>
            
            <div class="markdown-body">
              <h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185642516.png" srcset="/img/loading.gif" lazyload alt="image-20220428185642516"></p>
<p><strong>优点：</strong>架构简单，部署成本低</p>
<p><strong>缺点：</strong>耦合度高（维护困难、升级困难）</p>
<h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185707634.png" srcset="/img/loading.gif" lazyload alt="image-20220428185707634"></p>
<p><strong>优点：</strong>降低服务耦合，有利于服务升级和拓展</p>
<p><strong>缺点：</strong>服务调用关系错综复杂</p>
<p>分布式架构虽然降低了服务耦合，但是服务拆分时也有<strong>很多问题需要思考</strong>：</p>
<ul>
<li>服务拆分的粒度如何界定？</li>
<li>服务之间如何调用？</li>
<li>服务的调用关系如何管理？</li>
</ul>
<p><strong>人们需要制定一套行之有效的标准来约束分布式架构。</strong></p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185738700.png" srcset="/img/loading.gif" lazyload alt="image-20220428185738700"></p>
<p>微服务的上述特性<strong>其实是在给分布式架构制定一个标准</strong>，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p>
<p><strong>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</strong></p>
<p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p>
<p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>
<p>其中常见的组件包括：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185807546.png" srcset="/img/loading.gif" lazyload alt="image-20220428185807546"></p>
<p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185819931.png" srcset="/img/loading.gif" lazyload alt="image-20220428185819931"></p>
<h2 id="内容知识"><a href="#内容知识" class="headerlink" title="内容知识"></a>内容知识</h2><p>需要学习的微服务知识内容</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185933999.png" srcset="/img/loading.gif" lazyload alt="image-20220428185933999"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428185914756.png" srcset="/img/loading.gif" lazyload alt="image-20220428185914756"></p>
<h2 id="技术栈对比"><a href="#技术栈对比" class="headerlink" title="技术栈对比"></a>技术栈对比</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220428190002468.png" srcset="/img/loading.gif" lazyload alt="image-20220428190002468"></p>
<h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><p><strong>服务拆分注意事项</strong></p>
<p>单一职责：不同微服务，不要重复开发相同业务</p>
<p>数据独立：不要访问其它微服务的数据库</p>
<p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090745.png"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090745.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>cloud-demo：父工程，管理依赖</p>
<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
</ul>
<p>要求：</p>
<ul>
<li>订单微服务和用户微服务都必须有<strong>各自的数据库</strong>，相互独立</li>
<li>订单服务和用户服务<strong>都对外暴露 Restful 的接口</strong></li>
<li>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</li>
</ul>
<p>微服务项目下，打开 idea 中的 Service，可以很方便的启动。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090750.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090750.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>启动完成后，访问 <a target="_blank" rel="noopener" href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>正如上面的服务拆分要求中所提到，</p>
<blockquote>
<p>订单服务如果需要查询用户信息，<strong>只能调用用户服务的 Restful 接口</strong>，不能查询用户数据库</p>
</blockquote>
<p>因此我们需要知道 Java 如何去发送 http 请求，Spring 提供了一个 RestTemplate 工具，只需要把它创建出来即可。（即注入 Bean）</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090814.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>发送请求，自动序列化为 Java 对象。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090846.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>启动完成后，访问：<a target="_blank" rel="noopener" href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090909.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在上面代码的 url 中，我们可以发现调用服务的地址采用硬编码，这在后续的开发中肯定是不理想的，这就需要<strong>服务注册中心</strong>（Eureka）来帮我们解决这个事情。</p>
<h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>最广为人知的注册中心就是 Eureka，其结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901090919.png"><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090919.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>order-service 如何得知 user-service 实例地址？</strong></p>
<ul>
<li>user-service 服务实例启动后，将自己的信息注册到 eureka-server(Eureka服务端)，叫做<strong>服务注册</strong></li>
<li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service 根据服务名称，拉取实例地址列表，这个叫<strong>服务发现</strong>或服务拉取</li>
</ul>
<p><strong>order-service 如何从多个 user-service 实例中选择具体的实例？</strong></p>
<ul>
<li>order-service从实例列表中利用<strong>负载均衡算法</strong>选中一个实例地址，向该实例地址发起远程调用</li>
</ul>
<p><strong>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</strong></p>
<ul>
<li>user-service 会<strong>每隔一段时间(默认30秒)向 eureka-server 发起请求</strong>，报告自己状态，称为<strong>心跳</strong></li>
<li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service 拉取服务时，，可以拉取到最新的信息，将故障实例排除了</li>
</ul>
<h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p><strong>搭建 eureka-server</strong></p>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>编写启动类</strong></p>
<p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xn2001.eureka;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>编写配置文件</strong></p>
<p>编写一个 application.yml 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p>
<p>启动完成后，访问 <a target="_blank" rel="noopener" href="http://localhost:10086/">http://localhost:10086/</a></p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><blockquote>
<p>将 user-service、order-service 都注册到 eureka</p>
</blockquote>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>client</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在启动类上添加注解：<code>@EnableEurekaClient</code></p>
<p>在 application.yml 文件，添加下面的配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>      <span class="hljs-comment">#name：orderservice</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http:127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure>

<p>3个项目启动后，访问 <a target="_blank" rel="noopener" href="http://localhost:10086/">http://localhost:10086/</a></p>
<p>[<img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901090958.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901091005.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>4个项目启动后，访问 <a target="_blank" rel="noopener" href="http://localhost:10086/">http://localhost:10086/</a></p>
<h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h2><blockquote>
<p>在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</p>
</blockquote>
<p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p>
<p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。（后面会讲）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/20210901091216.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>spring 会自动帮助我们从 eureka-server 中，根据 userservice 这个服务名称，获取实例列表后去完成负载均衡。</p>
<h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><p>我们添加了 <code>@LoadBalanced</code> 注解，即可实现负载均衡功能，这是什么原理呢？</p>
<p><strong>SpringCloud 底层提供了一个名为 Ribbon 的组件，来实现负载均衡功能。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204718544.png" srcset="/img/loading.gif" lazyload alt="image-20220502204718544"></p>
<h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？为什么不需要获取ip和端口，这显然有人帮我们根据 service 名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p>
<p>我们进行源码跟踪：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204740323.png" srcset="/img/loading.gif" lazyload alt="image-20220502204740323"></p>
<p>这里的 <code>intercept()</code> 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>
<ul>
<li><code>request.getURI()</code>：获取请求uri，即 <a target="_blank" rel="noopener" href="http://user-service/user/8">http://user-service/user/8</a></li>
<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id <code>user-service</code></li>
<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求</li>
</ul>
<p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型</p>
<p>继续跟入 <code>execute()</code> 方法：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204800776.png" srcset="/img/loading.gif" lazyload alt="image-20220502204800776">ps://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901091330.png)</p>
<ul>
<li><code>getLoadBalancer(serviceId)</code>：根据服务id获取 <code>ILoadBalancer</code>，而 <code>ILoadBalancer</code> 会拿着服务 id 去 eureka 中获取服务列表。</li>
<li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。在图中<strong>可以看到获取了8082端口的服务</strong></li>
</ul>
<p>可以看到获取服务时，通过一个 <code>getServer()</code> 方法来做负载均衡:</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204807870.png" srcset="/img/loading.gif" lazyload alt="image-20220502204807870">210901091345.png)</p>
<p>我们继续跟入：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204829178.png" srcset="/img/loading.gif" lazyload alt="image-20220502204829178"></p>
<p>继续跟踪源码 <code>chooseServer()</code> 方法，发现这么一段代码：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204841773.png" srcset="/img/loading.gif" lazyload alt="image-20220502204841773"></p>
<p>我们看看这个 <code>rule</code> 是谁：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204854794.png" srcset="/img/loading.gif" lazyload alt="image-20220502204854794"></p>
<p>这里的 rule 默认值是一个 <code>RoundRobinRule</code> ，看类的介绍：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502204904472.png" srcset="/img/loading.gif" lazyload alt="image-20220502204904472"></p>
<p>负载均衡默认使用了轮训算法，当然我们也可以自定义。</p>
<h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的 <code>RestTemplate</code> 请求 <a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li>
<li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li>
<li>eureka 返回列表，localhost:8081、localhost:8082</li>
<li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li>
<li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205148614.png" srcset="/img/loading.gif" lazyload alt="image-20220502205148614"></p>
<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>内置负载均衡规则类</strong></th>
<th align="left"><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">RoundRobinRule</td>
<td align="left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td align="left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td align="left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td align="left"><strong>ZoneAvoidanceRule</strong></td>
<td align="left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td align="left">BestAvailableRule</td>
<td align="left">忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td align="left">RandomRule</td>
<td align="left">随机选择一个可用的服务器。</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td align="left">重试机制的选择逻辑</td>
</tr>
</tbody></table>
<p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p>
<h2 id="自定义策略"><a href="#自定义策略" class="headerlink" title="自定义策略"></a>自定义策略</h2><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p>
<p>1 代码方式在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205114259.png" srcset="/img/loading.gif" lazyload alt="image-20220502205114259"></p>
<p>2 配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给需要调用的微服务配置负载均衡规则，orderservice服务去调用userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：一般用默认的负载均衡规则，不做修改。</p>
<h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>当我们启动 orderservice，第一次访问时，时间消耗会大很多，这是因为 Ribbon 懒加载的机制。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205135263.png" srcset="/img/loading.gif" lazyload alt="image-20220502205135263"></p>
<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 项目启动时直接去拉取userservice的集群，多个用&quot;,&quot;隔开</span><br></code></pre></td></tr></table></figure>

<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p>SpringCloudAlibaba 推出了一个名为 Nacos 的注册中心，在国外也有大量的使用。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502205234666.png" srcset="/img/loading.gif" lazyload alt="image-20220502205234666"></p>
<p>解压启动 Nacos，详细请看 <a target="_blank" rel="noopener" href="https://www.xn2001.com/archives/661.html">Nacos安装指南</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">startup</span><span class="hljs-selector-class">.cmd</span> <span class="hljs-selector-tag">-m</span> <span class="hljs-selector-tag">standalone</span><br></code></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8848/nacos/">http://localhost:8848/nacos/</a></p>
<h2 id="服务注册-1"><a href="#服务注册-1" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里上来就直接服务注册，很多东西可能有疑惑，其实 Nacos 本身就是一个 SprintBoot 项目，这点你从启动的控制台打印就可以看出来，所以就不再需要去额外搭建一个像 Eureka 的注册中心。</p>
<p><strong>引入依赖</strong></p>
<p>在 cloud-demo 父工程中引入 SpringCloudAlibaba 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在 user-service 和 order-service 中的pom文件中引入 nacos-discovery 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>配置nacos地址</strong></p>
<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址： </p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure>

<p><strong>还需要配置服务名称</strong></p>
<p>项目重新启动后，可以看到三个服务都被注册进了 Nacos</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214602344.png" srcset="/img/loading.gif" lazyload alt="image-20220502214602344"></p>
<p>浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/order/101%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%9F%E6%AD%A3%E5%B8%B8%E3%80%82">http://localhost:8080/order/101，正常访问，同时负载均衡也正常。</a></p>
<h2 id="分级存储模型"><a href="#分级存储模型" class="headerlink" title="分级存储模型"></a>分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos就将同一机房内的实例，划分为一个<strong>集群</strong>。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214517868.png" srcset="/img/loading.gif" lazyload alt="image-20220502214517868"></p>
<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。<strong>当本集群内不可用时，才访问其它集群。</strong>例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p>
<h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>接下来我们给 user-service <strong>配置集群</strong></p>
<p>修改 user-service 的 application.yml 文件，添加集群配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称 HZ杭州</span><br></code></pre></td></tr></table></figure>

<p>重启两个 user-service 实例后，我们再去启动一个上海集群的实例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<br></code></pre></td></tr></table></figure>

<p>查看 nacos 控制台：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214544922.png" srcset="/img/loading.gif" lazyload alt="image-20220502214544922"></p>
<h2 id="NacosRule"><a href="#NacosRule" class="headerlink" title="NacosRule"></a>NacosRule</h2><p>Ribbon的默认实现 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡，我们把规则改成 <strong>NacosRule</strong> 即可。我们是用 orderservice 调用 userservice，所以在 orderservice 配置规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">iRule</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//默认为轮询规则，这里自定义为随机规则</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRule();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，你同样可以使用配置的形式来完成，具体参考上面的 Ribbon 栏目。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment">#负载均衡规则 </span><br></code></pre></td></tr></table></figure>

<p>然后，再对 orderservice 配置集群。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br></code></pre></td></tr></table></figure>

<p>现在我启动了四个服务，分别是：</p>
<ul>
<li>orderservice - HZ</li>
<li>userservice - HZ</li>
<li>userservice1 - HZ</li>
<li>userservice2 - SH</li>
</ul>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/order/101">http://localhost:8080/order/101</a></p>
<p>在访问中我们发现，只有同在一个 HZ 集群下的 userservice、userservice1 会被调用，并且是随机的。</p>
<p>我们试着把 userservice、userservice2 停掉。依旧可以访问。</p>
<p>在 userservice3 控制台可以看到发出了一串的警告，因为 orderservice 本身是在 HZ 集群的，这波 HZ 集群没有了 userservice，就会去别的集群找。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214629993.png" srcset="/img/loading.gif" lazyload alt="image-20220502214629993"></p>
<h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos 提供了<strong>权重配置来控制访问频率</strong>，0~1 之间，权重越大则访问频率越高，权重修改为 0，则该实例永远不会被访问。</p>
<p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214643631.png" srcset="/img/loading.gif" lazyload alt="image-20220502214643631"></p>
<p>在弹出的编辑窗口，修改权重</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214655845.png" srcset="/img/loading.gif" lazyload alt="image-20220502214655845"></p>
<p>另外，在服务升级的时候，有一种较好的方案：我们也可以通过调整权重来进行平滑升级，例如：先把 userservice 权重调节为 0，让用户先流向 userservice2、userservice3，升级 userservice后，再把权重从 0 调到 0.1，让一部分用户先体验，用户体验稳定后就可以往上调权重啦。</p>
<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p>
<ul>
<li>Nacos 中可以有多个 namespace</li>
<li>namespace 下可以有 group、service 等</li>
<li>不同 namespace 之间<strong>相互隔离</strong>，例如不同 namespace 的服务互相不可见</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214708111.png" srcset="/img/loading.gif" lazyload alt="image-20220502214708111"></p>
<h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public(保留空间)：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214721702.png" srcset="/img/loading.gif" lazyload alt="image-20220502214721702"></p>
<p>我们可以点击页面新增按钮，添加一个 namespace：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214733491.png" srcset="/img/loading.gif" lazyload alt="image-20220502214733491"></p>
<p>然后，填写表单：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214750406.png" srcset="/img/loading.gif" lazyload alt="image-20220502214750406"></p>
<p>就能在页面看到一个新的 namespace：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214801507.png" srcset="/img/loading.gif" lazyload alt="image-20220502214801507"></p>
<h3 id="配置namespace"><a href="#配置namespace" class="headerlink" title="配置namespace"></a>配置namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p>
<p>例如，修改 order-service 的 application.yml 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间ID</span><br></code></pre></td></tr></table></figure>

<p>重启 order-service 后，访问控制台。</p>
<p><strong>public</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214821277.png" srcset="/img/loading.gif" lazyload alt="image-20220502214821277"></p>
<p><strong>dev</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214833255.png" srcset="/img/loading.gif" lazyload alt="image-20220502214833255"></p>
<p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220502214845028.png" srcset="/img/loading.gif" lazyload alt="image-20220502214845028"></p>
<h2 id="临时实例"><a href="#临时实例" class="headerlink" title="临时实例"></a>临时实例</h2><p>Nacos 的服务实例分为两种类型：</p>
<ul>
<li><strong>临时实例</strong>：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</li>
<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 设置为非临时实例</span><br></code></pre></td></tr></table></figure>

<p>另外，Nacos 集群<strong>默认采用AP方式(可用性)**，当集群中存在非临时实例时，</strong>采用CP模式(一致性)**；而 Eureka 采用AP方式，不可切换。（这里说的是 CAP 原理，后面会写到）</p>
<h1 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p>
<p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。<strong>我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200723770.png" srcset="/img/loading.gif" lazyload alt="image-20220503200723770"></p>
<p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，<strong>实现配置的热更新。</strong></p>
<h2 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h2><p>在 Nacos 控制面板中添加配置文件</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200736172.png" srcset="/img/loading.gif" lazyload alt="image-20220503200736172"></p>
<p>然后在弹出的表单中，填写配置信息：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200754869.png" srcset="/img/loading.gif" lazyload alt="image-20220503200754869"></p>
<p><strong>注意：</strong>项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置(例如数据库连接)还是保存在微服务本地比较好。这里的后缀名最好写<code>.yaml</code>。</p>
<h2 id="拉取配置"><a href="#拉取配置" class="headerlink" title="拉取配置"></a>拉取配置</h2><p>首先我们需要了解 Nacos 读取配置文件的环节是在哪一步，在没加入 Nacos 配置之前，获取配置是这样：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200813407.png" srcset="/img/loading.gif" lazyload alt="image-20220503200813407"></p>
<p>加入 Nacos 配置，它的读取是在 application.yml 之前的：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200824188.png" srcset="/img/loading.gif" lazyload alt="image-20220503200824188"></p>
<p>这时候如果把 nacos 地址放在 application.yml 中，显然是不合适的，<strong>Nacos 就无法根据地址去获取配置了。</strong></p>
<p>因此，nacos 地址必须放在优先级最高的 bootstrap.yml 文件。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200923259.png" srcset="/img/loading.gif" lazyload alt="image-20220503200923259"></p>
<p><strong>引入 nacos-config 依赖</strong></p>
<p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>添加 bootstrap.yml</strong></p>
<p>然后，在 user-service 中添加一个 bootstrap.yml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure>

<p>根据 spring.cloud.nacos.server-addr 获取 nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p>
<p>在这个例子例中，就是去读取 <code>userservice-dev.yaml</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201041580.png" srcset="/img/loading.gif" lazyload alt="image-20220503201041580"></p>
<p>使用代码来验证是否拉取成功</p>
<p>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置并使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String dateformat;<br><br><span class="hljs-meta">@GetMapping(&quot;now&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">now</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//格式化时间</span><br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503200944583.png" srcset="/img/loading.gif" lazyload alt="image-20220503200944583"></p>
<p>启动服务后，访问：<a target="_blank" rel="noopener" href="http://localhost:8081/user/now">http://localhost:8081/user/now</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201114911.png" srcset="/img/loading.gif" lazyload alt="image-20220503201114911"></p>
<h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p>
<p>有两种方式：1. 用 <code>@value</code> 读取配置时，搭配 <code>@RefreshScope</code>；2. 直接用 <code>@ConfigurationProperties</code> 读取配置</p>
<h3 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h3><p>方式一：在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201128313.png" srcset="/img/loading.gif" lazyload alt="image-20220503201128313"></p>
<h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>方式二：使用 <code>@ConfigurationProperties</code> 注解读取配置文件，就不需要加 <code>@RefreshScope</code> 注解。</p>
<p>在 user-service 服务中，添加一个 PatternProperties 类，读取 <code>patterrn.dateformat</code> 属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatternProperties</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String dateformat;<br>&#125;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> PatternProperties patternProperties;<br><br><span class="hljs-meta">@GetMapping(&quot;now2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">now2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//格式化时间</span><br>    <span class="hljs-keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.dateformat));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实在服务启动时，nacos 会读取多个配置文件，例如：</p>
<ul>
<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>
<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li>
</ul>
<p>这里的 <code>[spring.application.name].yaml</code> 不包含环境，<strong>因此可以被多个环境共享</strong>。</p>
<p><strong>添加一个环境共享配置</strong></p>
<p>我们在 nacos 中添加一个 userservice.yaml 文件：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220503201156476.png" srcset="/img/loading.gif" lazyload alt="image-20220503201156476"></p>
<p><strong>在 user-service 中读取共享配置</strong></p>
<p>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092314.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092314.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在 user-service 服务中，修改 UserController，添加一个方法：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092331.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092331.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>运行两个 UserApplication，使用不同的profile</strong></p>
<p>修改 UserApplication2 这个启动项，改变其profile值：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092345.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092345.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092338.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092338.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>这样，UserApplication(8081) 使用的 profile 是 dev，UserApplication2(8082) 使用的 profile 是test</p>
<p>启动 UserApplication 和 UserApplication2</p>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092400.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092400.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092419.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092419.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</p>
<p>上面的都是同一个微服务下，<strong>那么不同微服务之间可以环境共享吗？</strong></p>
<p>通过下面的两种方式来指定：</p>
<ul>
<li>extension-configs</li>
<li>shared-configs</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">extends-configs:</span> <span class="hljs-comment"># 多微服务间共享的配置列表</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">common.yaml</span> <span class="hljs-comment"># 要共享的配置文件id</span><br><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 多微服务间共享的配置列表</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">common.yaml</span> <span class="hljs-comment"># 要共享的配置文件id</span><br></code></pre></td></tr></table></figure>

<h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>当 nacos、服务本地同时<strong>出现相同属性时</strong>，优先级有高低之分。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092501.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092501.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>更细致的配置</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092520.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092520.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>我们以前利用 RestTemplate 发起远程调用的代码：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092616.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092616.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护</li>
</ul>
<p>Feign 是一个声明式的 http 客户端，官方地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p>其作用就是帮助我们<strong>优雅的实现 http 请求的发送</strong>，解决上面提到的问题。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092639.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092639.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p><strong>引入依赖</strong></p>
<p>我们在 order-service 引入 feign 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>添加注解</strong></p>
<p>在 order-service 启动类添加注解开启 Feign</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092704.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092704.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>请求接口</strong></p>
<p>在 order-service 中新建一个接口，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.order.client;<br><br><span class="hljs-keyword">import</span> cn.itcast.order.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>@FeignClient(&quot;userservice&quot;)</code>：其中参数填写的是微服务名</p>
<p><code>@GetMapping(&quot;/user/&#123;id&#125;&quot;)</code>：其中参数填写的是请求路径</p>
<p>这个客户端主要是基于 SpringMVC 的注解 <code>@GetMapping</code> 来声明远程调用的信息</p>
<p>Feign 可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserClient userClient;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">queryOrderAndUserById</span><span class="hljs-params">(Long orderId)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.查询订单</span><br>    Order order = orderMapper.findById(orderId);<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 2021/8/20 使用feign远程调用</span><br>    User user = userClient.findById(order.getUserId());<br>    <span class="hljs-comment">// 3. 将用户信息封装进订单</span><br>    order.setUser(user);<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> order;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>Feign 可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">作用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>feign.Logger.Level</strong></td>
<td align="left">修改日志级别</td>
<td align="left">包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td align="left">feign.codec.Decoder</td>
<td align="left">响应结果的解析器</td>
<td align="left">http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td align="left">feign.codec.Encoder</td>
<td align="left">请求参数编码</td>
<td align="left">将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td align="left">feign.Contract</td>
<td align="left">支持的注解格式</td>
<td align="left">默认是SpringMVC的注解</td>
</tr>
<tr>
<td align="left">feign.Retryer</td>
<td align="left">失败重试机制</td>
<td align="left">请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。下面以日志为例来演示如何自定义配置。</p>
<p>基于配置文件修改 feign 的日志级别可以针对单个服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure>

<p><strong>也可以针对所有服务：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure>

<p>而日志的级别分为四种：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据</li>
</ul>
<p>也可以基于 <strong>Java 代码</strong>来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultFeignConfiguration</span>  </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.<span class="hljs-function">Level <span class="hljs-title">feignLogLevel</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要<strong>全局生效</strong>，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure>

<p>如果是<strong>局部生效</strong>，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> <br></code></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现有：</p>
<ul>
<li><strong>URLConnection</strong>：默认实现，不支持连接池</li>
<li><strong>Apache HttpClient</strong> ：支持连接池</li>
<li><strong>OKHttp</strong>：支持连接池</li>
</ul>
<p>因此提高 Feign 性能的主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection</p>
<p>另外，日志级别应该尽量用 basic/none，可以有效提高性能。</p>
<p><strong>这里我们用 Apache 的HttpClient来演示连接池。</strong></p>
<p>在 order-service 的 pom 文件中引入 HttpClient 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>配置连接池</strong></p>
<p>在 order-service 的 application.yml 中添加配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure>

<p>在 FeignClientFactoryBean 中的 loadBalance 方法中打断点</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092729.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092729.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 HttpClient</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092737.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092737.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p>
<p>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明</p>
<p>2）Feign 客户端、Controller 都集成该接口</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092803.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092803.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>优点</p>
<ul>
<li>简单</li>
<li>实现了代码共享</li>
</ul>
<p>缺点</p>
<ul>
<li>服务提供方、服务消费方紧耦合</li>
<li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li>
</ul>
<h3 id="抽取方式"><a href="#抽取方式" class="headerlink" title="抽取方式"></a>抽取方式</h3><p>将 FeignClient 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p>
<p>例如：将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092811.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092811.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>接下来我们就用该方法在代码中实现</p>
<p><strong>首先创建一个 module，命名为 feign-api</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092835.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092835.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p>在 feign-api 中然后引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>order-service中的 UserClient、User 都复制到 feign-api 项目中</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092848.png"><img src="https://cdn.jsdelivr.net/gh/lexinhu/Image/img/2021/20210901092848.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>在order-service中使用 feign-api</strong></p>
<p>首先，删除 order-service 中的 UserClient、User</p>
<p>在 order-service 中引入 feign-api</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xn2001.feign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>修改注解</strong></p>
<p>当定义的 FeignClient 不在 SpringBootApplication 的扫描包范围下时，这些 FeignClient 就不能使用。</p>
<p>修改 order-service 启动类上的 @EnableFeignClients 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.xn2001.feign.clients&quot;)</span><br></code></pre></td></tr></table></figure>

<h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<p>Gateway 网关是我们服务的守门神，<strong>所有微服务的统一入口。</strong></p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li>请求路由</li>
<li>权限控制</li>
<li>限流</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173727591.png" srcset="/img/loading.gif" lazyload alt="image-20220521173727591"></p>
<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>
<p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>
<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>
<p>在 SpringCloud 中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>Zuul 是基于 Servlet 实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring5 中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>
<h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol>
<li>创建 SpringBoot 工程 gateway，引入网关依赖</li>
<li>编写启动类</li>
<li>编写基础配置和路由规则</li>
<li>启动网关服务进行测试</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos服务发现依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>创建 application.yml 文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure>

<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>
<p>上面的例子中，我们将 <code>/user/**</code> 开头的请求，代理到 <code>lb://userservice</code>，其中 lb 是负载均衡(LoadBalance)，根据服务名拉取服务列表，实现负载均衡。</p>
<p>重启网关，访问 <a target="_blank" rel="noopener" href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合 <code>/user/**</code> 规则，请求转发到 uri：<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173845186.png" srcset="/img/loading.gif" lazyload alt="image-20220521173845186"></p>
<p>多个 predicates 的话，要同时满足规则，下文有例子。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173917312.png" srcset="/img/loading.gif" lazyload alt="image-20220521173917312"></p>
<p>路由配置包括：</p>
<ol>
<li>路由id：路由的唯一标示</li>
<li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li>
<li>路由断言（predicates）：判断路由的规则</li>
<li>路由过滤器（filters）：对请求或响应做处理</li>
</ol>
<h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件。</p>
<p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">After</td>
<td align="left">是某个时间点后的请求</td>
<td align="left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td align="left">Before</td>
<td align="left">是某个时间点之前的请求</td>
<td align="left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td align="left">Between</td>
<td align="left">是某两个时间点之前的请求</td>
<td align="left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">请求必须包含某些cookie</td>
<td align="left">- Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td align="left">Header</td>
<td align="left">请求必须包含某些header</td>
<td align="left">- Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">请求必须是访问某个host（域名）</td>
<td align="left">- Host=<code>**.somehost.org</code>, <code>**.anotherhost.org</code></td>
</tr>
<tr>
<td align="left">Method</td>
<td align="left">请求方式必须是指定方式</td>
<td align="left">- Method=GET,POST</td>
</tr>
<tr>
<td align="left">Path</td>
<td align="left">请求路径必须符合指定规则</td>
<td align="left">- Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td align="left">Query</td>
<td align="left">请求参数必须包含指定参数</td>
<td align="left">- Query=name, Jack或者- Query=name</td>
</tr>
<tr>
<td align="left">RemoteAddr</td>
<td align="left">请求者的ip必须是指定范围</td>
<td align="left">- RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td align="left">Weight</td>
<td align="left">权重处理</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p>
</blockquote>
<p>一般的，我们只需要掌握 Path，加上官方文档的例子，就可以应对各种工作场景了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">predicates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/order/**</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">After=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure>

<p>像这样的规则，现在是 2021年8月22日01:32:42，很明显 After 条件不满足，可以不会转发，路由不起作用。</p>
<h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173935022.png" srcset="/img/loading.gif" lazyload alt="image-20220521173935022"></p>
<p>Spring提供了31种不同的路由过滤器工厂。</p>
<blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">AddRequestHeader</td>
<td align="left">给当前请求添加一个请求头</td>
</tr>
<tr>
<td align="left">RemoveRequestHeader</td>
<td align="left">移除请求中的一个请求头</td>
</tr>
<tr>
<td align="left">AddResponseHeader</td>
<td align="left">给响应结果中添加一个响应头</td>
</tr>
<tr>
<td align="left">RemoveResponseHeader</td>
<td align="left">从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td align="left">RequestRateLimiter</td>
<td align="left">限制请求的流量</td>
</tr>
</tbody></table>
<p>下面我们以 AddRequestHeader 为例：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174021064.png" srcset="/img/loading.gif" lazyload alt="image-20220521174021064"></p>
<p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：<code>sign=xn2001.com is eternal</code></p>
<p>只需要修改 gateway 服务的 application.yml文件，添加路由过滤即可。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=sign,</span> <span class="hljs-string">xn2001.com</span> <span class="hljs-string">is</span> <span class="hljs-string">eternal</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure>

<p>如何验证，我们修改 userservice 中的一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="hljs-meta">@RequestHeader(value = &quot;sign&quot;, required = false)</span> String sign)</span> </span>&#123;<br>    log.warn(sign);<br>    <span class="hljs-keyword">return</span> userService.queryById(id);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重启两个服务，访问：<a target="_blank" rel="noopener" href="http://localhost:10010/user/1">http://localhost:10010/user/1</a></p>
<p>可以看到控制台打印出了这个请求头</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174034929.png" srcset="/img/loading.gif" lazyload alt="image-20220521174034929"></p>
<p>当然，Gateway 也是有<strong>全局过滤器</strong>的，如果要<strong>对所有的路由都生效</strong>，则可以将过滤器工厂写到 default-filters 下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=sign,</span> <span class="hljs-string">xn2001.com</span> <span class="hljs-string">is</span> <span class="hljs-string">eternal</span> <span class="hljs-comment"># 添加请求头</span><br></code></pre></td></tr></table></figure>

<h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上面介绍的过滤器工厂，网关提供了 31 种，但每一种过滤器的作用都是固定的。<strong>如果我们希望拦截请求，做自己的业务逻辑则没办法实现</strong>。</p>
<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，<strong>与 GatewayFilter 的作用一样</strong>。区别在于 GlobalFilter 的逻辑可以<strong>写代码来自定义规则</strong>；而 GatewayFilter 通过配置定义，处理逻辑是固定的。</p>
<p><strong>需求：</strong>定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件</p>
<ul>
<li>参数中是否有 authorization</li>
<li>authorization 参数值是否为 admin</li>
</ul>
<p>如果同时满足则放行，否则拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>    <span class="hljs-comment">// 测试：http://localhost:10010/order/101?authorization=admin</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取第一个 authorization 参数</span><br>        String authorization = exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(authorization))&#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 设置拦截状态码信息</span><br>        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>        <span class="hljs-comment">// 设置拦截</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置过滤器优先级，值越低优先级越高</span><br>    <span class="hljs-comment">// 也可以使用 @Order 注解</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="过滤器顺序"><a href="#过滤器顺序" class="headerlink" title="过滤器顺序"></a>过滤器顺序</h2><p>请求进入网关会碰到三类过滤器：DefaultFilter、当前路由的过滤器、GlobalFilter；</p>
<p>请求路由后，会将三者合并到一个过滤器链（集合）中，排序后依次执行每个过滤器.</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521174102554.png" srcset="/img/loading.gif" lazyload alt="image-20220521174102554"></p>
<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个 int 类型的 order 值，<strong>order 值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter 通过实现 Ordered 接口，或者使用 @Order 注解来指定 order 值，由我们自己指定。</li>
<li>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从1递增。</li>
<li>当过滤器的 order 值一样时，<strong>会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li>
</ul>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>不了解跨域问题的同学可以百度了解一下；在 Gateway 网关中解决跨域问题还是比较方便的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 allowedOrigins: “*” 允许所有网站</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure>



<h1 id="ELasticsearch搜索引擎"><a href="#ELasticsearch搜索引擎" class="headerlink" title="ELasticsearch搜索引擎"></a>ELasticsearch搜索引擎</h1><p>ELasticsearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容，可以用来实现搜索、日志统计、分析、系统监控等功能。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><strong>首先，倒排索引的概念是基于 MySQL 这样的正向索引而言的。</strong></p>
<p>那么我们先讲何为正向索引。例如给下表（tb_goods）中的 id 创建索引</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135704943.png" srcset="/img/loading.gif" lazyload alt="image-20220522135704943"></p>
<p>如果是根据 id 查询，那么直接走索引，查询速度非常快。</p>
<p>但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：</p>
<ol>
<li>用户搜索数据，条件是 title 符合 <code>&quot;%手机%&quot;</code></li>
<li>逐行获取数据，比如 id 为 1 的数据</li>
<li>判断数据中的 title 是否符合用户搜索条件</li>
<li>如果符合则放入结果集，不符合则丢弃。然后回到步骤1</li>
</ol>
<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是。。。</p>
<p>而倒排索引中有两个非常重要的概念：</p>
<ul>
<li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档 id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引</li>
</ul>
<p>如图：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135727991.png" srcset="/img/loading.gif" lazyload alt="image-20220522135727991"></p>
<p><strong>倒排索引的搜索流程</strong>如下（以搜索”华为手机”为例）</p>
<ol>
<li>用户输入条件<code>&quot;华为手机&quot;</code>进行搜索</li>
<li>对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code></li>
<li>拿着词条在倒排索引中查找，可以得到包含词条的文档 id 有 1、2、3</li>
<li>拿着文档 id 到正向索引中查找具体文档</li>
</ol>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135742748.png" srcset="/img/loading.gif" lazyload alt="image-20220522135742748"></p>
<p><strong>虽然要先查询倒排索引，再查询正向索引，但是词条和文档id 都建立了索引，查询速度非常快！无需全表扫描。</strong></p>
<p>为什么一个叫做正向索引，一个叫做倒排索引呢？</p>
<p><strong>正向索引</strong>是最传统的，根据 id 索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong></p>
<p><strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据得到的文档 id 获取该文档。是<strong>根据词条找文档的过程</strong></p>
<h2 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h2><p>elasticsearch 是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 json 格式后存储在 elasticsearch</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135806235.png" srcset="/img/loading.gif" lazyload alt="image-20220522135806235"></p>
<p>而 JSON 文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p>
<h2 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h2><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135826088.png" srcset="/img/loading.gif" lazyload alt="image-20220522135826088"></p>
<p>因此，我们可以把索引当做是数据库中的表。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p>
<p><strong>mysql 与 elasticsearch</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL</strong></th>
<th align="left"><strong>Elasticsearch</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Table</td>
<td align="left">Index</td>
<td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td align="left">Row</td>
<td align="left">Document</td>
<td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td align="left">Column</td>
<td align="left">Field</td>
<td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td align="left">Schema</td>
<td align="left">Mapping</td>
<td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td align="left">SQL</td>
<td align="left">DSL</td>
<td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody></table>
<ul>
<li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li>
<li>Elasticsearch：擅长海量数据的搜索、分析、计算</li>
</ul>
<p>因此在企业中，往往是两者结合使用：</p>
<ul>
<li>对安全性要求较高的写操作，使用 MySQL 实现</li>
<li>对查询性能要求较高的搜索需求，使用 ELasticsearch 实现</li>
<li>两者再基于某种方式，实现数据的同步，保证一致性</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522135845119.png" srcset="/img/loading.gif" lazyload alt="image-20220522135845119"></p>
<h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>IK分词器包含两种模式：</p>
<ul>
<li><code>ik_smart</code>：智能切分，粗粒度</li>
<li><code>ik_max_word</code>：最细切分，细粒度</li>
</ul>
<h2 id="扩展词词典"><a href="#扩展词词典" class="headerlink" title="扩展词词典"></a>扩展词词典</h2><p>在上面的IK分词器我们可以随着热点词来扩展，可以自己添加，比如 ”钟老师应该是一个热点词“，另外你也可以配置一些停用掉的敏感词，让其不进行分词。</p>
<p>打开IK分词器 config 目录是 <code>IKAnalyzer.cfg.xml</code>，添加一个文件名，我们以 <code>ext.dic</code> 文件名为例。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140038286.png" srcset="/img/loading.gif" lazyload alt="image-20220522140038286"></p>
<p>我们去创建 <code>ext.dic</code> ，在其中添加热点词就好了，一个词一行。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140052838.png" srcset="/img/loading.gif" lazyload alt="image-20220522140052838"></p>
<p>重启elasticsearch。</p>
<h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><h3 id="Mapping属性映射"><a href="#Mapping属性映射" class="headerlink" title="Mapping属性映射"></a>Mapping属性映射</h3><p>索引库就类似数据库表，<strong>mapping 映射就类似表的结构</strong></p>
<p>我们要向 es 中存储数据，必须先创建“库”和“表”</p>
<p>mapping 是对索引库中文档的约束，常见的 mapping 属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float、</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li><strong>index：是否创建索引，默认为 true</strong></li>
<li>analyzer：使用哪种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<p>我们以需要存储下面的 JSON 为例来讲解</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">&quot;weight&quot;</span>: <span class="hljs-number">52.1</span>,<br>    <span class="hljs-attr">&quot;isMarried&quot;</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;钟老师真菜&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;jialna@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;score&quot;</span>: [<span class="hljs-number">99.1</span>, <span class="hljs-number">99.5</span>, <span class="hljs-number">98.9</span>],<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;湖&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;心&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先对应的每个字段映射（mapping）情况如下：</p>
<ul>
<li>age：类型为 integer；参与搜索，index 为 true；无需分词器</li>
<li>weight：类型为 float；参与搜索，index 为 true；无需分词器</li>
<li>isMarried：类型为boolean；参与搜索，index 为 true；无需分词器</li>
<li>info：类型为字符串，需要分词，因此是 text；参与搜索，index为true；分词器可以用 ik_smart</li>
<li>email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，index 为 false；无需分词器</li>
<li>score：虽然是数组，<strong>但是我们只看元素的类型</strong>，类型为 float；参与搜索，index 为 true；无需分词器</li>
<li>name：类型为 object，需要定义多个子属性<ul>
<li>name.firstName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li>
<li>name.lastName：类型为字符串，不需要分词，keyword；参与搜索，index 为 true；无需分词器</li>
</ul>
</li>
</ul>
<h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p>上面我们了解了 Mapping 属性映射，接下来我们就去看看如何创建索引库及映射。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;字段名&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;字段名2&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-string">&quot;false&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;字段名3&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;子字段&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// ...略</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>PUT /hotel<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;name&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;address&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;price&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;score&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;brand&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;city&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;copy_to&quot;</span>: <span class="hljs-string">&quot;all&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;starName&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;business&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;location&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;geo_point&quot;</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;pic&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-literal">false</span><br>      &#125;,<br>      <span class="hljs-attr">&quot;all&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>特殊字段说明：</p>
<ul>
<li>location：地理坐标，里面包含精度、纬度</li>
<li>all：一个组合字段，其目的是将多字段的值利用 <code>copy_to</code> 合并，提供给用户搜索，这样一来就只需要搜索一个字段就可以得到结果，性能更好。</li>
</ul>
<blockquote>
<p>ES中支持两种地理坐标数据类型：</p>
<ul>
<li>geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：”32.8752345, 120.2981576”</li>
<li>geo_shape：有多个 geo_point 组成的复杂几何图形。例如一条直线，”LINESTRING (-77.03653 38.897676, -77.009051 38.889939)”</li>
</ul>
</blockquote>
<h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改 mapping</strong></p>
<p>虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，不会对倒排索引产生影响。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_mapping<br>&#123;<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;新字段名&quot;</span>:&#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名<br></code></pre></td></tr></table></figure>

<h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /数据库名<br></code></pre></td></tr></table></figure>

<h2 id="DSL文档操作"><a href="#DSL文档操作" class="headerlink" title="DSL文档操作"></a>DSL文档操作</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br>&#123;<br>    <span class="hljs-attr">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-attr">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-attr">&quot;字段3&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;子属性1&quot;</span>: <span class="hljs-string">&quot;值3&quot;</span>,<br>        <span class="hljs-attr">&quot;子属性2&quot;</span>: <span class="hljs-string">&quot;值4&quot;</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>POST /xn2001/_doc/1<br>&#123;<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;我不会Java&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;jialna@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;钟&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;弟弟&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>修改文档有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p><strong>全量修改</strong>是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的 id 删除文档</li>
<li>新增一个相同 id 的文档</li>
</ul>
<p><strong>注意</strong>：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就是变成了新增操作</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /&#123;索引库名&#125;/_doc/id<br>&#123;<br>    <span class="hljs-attr">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-attr">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-comment">// ... 略</span><br>&#125;<br>PUT /xn2001/_doc/1<br>&#123;<br>    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;我也不会敲代码&quot;</span>,<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;3300123589@qq.com&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;firstName&quot;</span>: <span class="hljs-string">&quot;弟弟&quot;</span>,<br>        <span class="hljs-attr">&quot;lastName&quot;</span>: <span class="hljs-string">&quot;钟&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>增量修改</strong>是只修改指定 id 匹配的文档中的部分字段</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /&#123;索引库名&#125;/_update/文档id<br>&#123;<br>    <span class="hljs-attr">&quot;doc&quot;</span>: &#123;<br>         <span class="hljs-attr">&quot;字段名&quot;</span>: <span class="hljs-string">&quot;新的值&quot;</span>,<br>    &#125;<br>&#125;<br>POST /heima/_update/1<br>&#123;<br>  <span class="hljs-attr">&quot;doc&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;update@qq.com&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /&#123;索引库名称&#125;/_doc/&#123;id&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /&#123;索引库名&#125;/_doc/&#123;id&#125;<br></code></pre></td></tr></table></figure>

<h2 id="RestClient文档操作"><a href="#RestClient文档操作" class="headerlink" title="RestClient文档操作"></a>RestClient文档操作</h2><p>ES 官方提供了各种不同语言的客户端，用来操作 ES。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ES。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<h3 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h3><p>在 elasticsearch 提供的 API 中，elasticsearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 elasticsearch 的连接。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>SpringBoot 默认的 ES 版本是 7.6.2，我们需要覆盖默认的ES版本</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>初始化 RestHighLevelClient，初始化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">RestHighLevelClient client = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure>

<p>我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 <code>@BeforeEach</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/19 17:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelIndexTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.restHighLevelClient);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//指定索引库名</span><br>    CreateIndexRequest hotel = <span class="hljs-keyword">new</span> CreateIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">//写入JSON数据，这里是Mapping映射</span><br>    hotel.source(HotelConstants.MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">//创建索引库</span><br>    restHighLevelClient.indices().create(hotel, RequestOptions.DEFAULT);<br>&#125;<br><br><span class="hljs-comment">//具体的json数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelConstants</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String MAPPING_TEMPLATE = <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    DeleteIndexRequest hotel = <span class="hljs-keyword">new</span> DeleteIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    restHighLevelClient.indices().delete(hotel,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断索引库"><a href="#判断索引库" class="headerlink" title="判断索引库"></a>判断索引库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">existHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    GetIndexRequest hotel = <span class="hljs-keyword">new</span> GetIndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-keyword">boolean</span> exists = restHighLevelClient.indices().exists(hotel, RequestOptions.DEFAULT);<br>    System.out.println(exists);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/9/19 17:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelDocumentTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testInit</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.restHighLevelClient);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createHotelIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Hotel hotel = hotelService.getById(<span class="hljs-number">61083L</span>);<br>        HotelDoc hotelDoc = <span class="hljs-keyword">new</span> HotelDoc(hotel);<br>        <span class="hljs-comment">// 1.准备Request对象</span><br>        IndexRequest hotelIndex = <span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());<br>        <span class="hljs-comment">// 2.准备Json文档</span><br>        hotelIndex.source(JSON.toJSONString(hotelDoc), XContentType.JSON);<br>        <span class="hljs-comment">// 3.发送请求</span><br>        restHighLevelClient.index(hotelIndex, RequestOptions.DEFAULT);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    GetRequest hotel = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求，得到响应</span><br>    GetResponse hotelResponse = restHighLevelClient.get(hotel, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.解析响应结果</span><br>    String hotelDocSourceAsString = hotelResponse.getSourceAsString();<br>    <span class="hljs-comment">// 4.json转实体类</span><br>    HotelDoc hotelDoc = JSON.parseObject(hotelDocSourceAsString, HotelDoc.class);<br>    System.out.println(hotelDoc);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    DeleteRequest hotel = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    restHighLevelClient.delete(hotel,RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><p>前面我们说过，修改文档有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p>在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID</p>
<ul>
<li>如果新增时，ID已经存在，则修改</li>
<li>如果新增时，ID不存在，则新增</li>
</ul>
<p>所以全量修改写法与新增文档一样，下面我们主要是介绍增量修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testUpdateDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    UpdateRequest request = <span class="hljs-keyword">new</span> UpdateRequest(<span class="hljs-string">&quot;hotel&quot;</span>, <span class="hljs-string">&quot;61083&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.doc(<br>        <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-string">&quot;952&quot;</span>,<br>        <span class="hljs-string">&quot;starName&quot;</span>, <span class="hljs-string">&quot;四钻&quot;</span><br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    restHighLevelClient.update(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h3><p>案例需求：利用 <code>BulkRequest</code> 批量将数据库数据导入到索引库中。</p>
<ul>
<li>利用 mybatis-plus 查询酒店数据</li>
<li>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</li>
<li>利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档</li>
</ul>
<p>批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。</p>
<p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140530912.png" srcset="/img/loading.gif" lazyload alt="image-20220522140530912"></p>
<p>利用这一点，我们可以写出自己需要的代码，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testBulk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    BulkRequest bulkRequest = <span class="hljs-keyword">new</span> BulkRequest();<br>    List&lt;Hotel&gt; hotelList = hotelService.list();<br>    hotelList.forEach(item -&gt; &#123;<br>        HotelDoc hotelDoc = <span class="hljs-keyword">new</span> HotelDoc(item);<br>        bulkRequest.add(<span class="hljs-keyword">new</span> IndexRequest(<span class="hljs-string">&quot;hotel&quot;</span>)<br>                .id(hotelDoc.getId().toString())<br>                .source(JSON.toJSONString(hotelDoc), XContentType.JSON));<br>    &#125;);<br>    restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>总之，在 Java 代码中，client 针对操作索引库还是文档，基本都是一样的代码</p>
<p>restHighLevelClient.indices().xxx，代表操作索引库</p>
<p>restHighLevelClient.xxx，代表操作文档</p>
<p>而其中所需要的参数，我们直接通过 <strong>ctrl+p</strong> 这样的快捷键去查看就可以，不需要单独记住。</p>
<h2 id="DSL文档查询"><a href="#DSL文档查询" class="headerlink" title="DSL文档查询"></a>DSL文档查询</h2><p>Elasticsearch 提供了基于 JSON 的 DSL(<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>)来定义查询。常见的查询类型包括：</p>
<p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p>
<p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p>
<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
<p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：</p>
<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
<p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p>
<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
<p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>
<ul>
<li>bool</li>
<li>function_score</li>
</ul>
<hr>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 查询所有</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>使用场景：全文检索查询的基本流程如下：</p>
<ul>
<li>对用户搜索的内容做分词，得到词条</li>
<li>根据词条去倒排索引库中匹配，得到文档id</li>
<li>根据文档id找到文档，返回给用户</li>
</ul>
<p>比较常用的场景包括：</p>
<ul>
<li>商城的输入框搜索</li>
<li>百度输入框搜索</li>
</ul>
<p>常见的全文检索查询包括：</p>
<ul>
<li>match 查询：单字段查询</li>
<li>multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件</li>
</ul>
<p>match 查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>mulit_match 查询语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span>,<br>      <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;FIELD1&quot;</span>, <span class="hljs-string">&quot; FIELD12&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为我们将 brand、name、business 值都利用 <strong>copy_to</strong> 复制到了 <strong>all</strong> 字段中，你根据三个字段搜索，和根据 all字段搜索效果是一样的。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;all&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br>GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;query&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span>,<br>      <span class="hljs-attr">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;brand&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>搜索字段越多，对查询性能影响越大，因此建议采用 copy_to 将多个字段合并为一个，然后使用单字段查询的方式。</strong></p>
<h3 id="精准查询"><a href="#精准查询" class="headerlink" title="精准查询"></a>精准查询</h3><p>精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以<strong>不会</strong>对搜索条件分词。</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
<h4 id="term查询"><a href="#term查询" class="headerlink" title="term查询"></a>term查询</h4><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p>
<p>语法说明：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// term查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;VALUE&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;brand&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;7天酒店&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>
<p>基本语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// range查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 这里的gte代表大于等于，gt则代表大于</span><br>        <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">20</span> <span class="hljs-comment">// lte代表小于等于，lt则代表小于</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522140701446.png" srcset="/img/loading.gif" lazyload alt="image-20220522140701446"></p>
<p>精确查询常见的有哪些？</p>
<ul>
<li>term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段</li>
<li>range 查询：根据数值范围查询，可以是数值、日期的范围</li>
</ul>
<h3 id="地理坐标查询"><a href="#地理坐标查询" class="headerlink" title="地理坐标查询"></a>地理坐标查询</h3><p>地理坐标查询，其实就是根据经纬度查询，官方文档：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p>
<p>常见的使用场景包括：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
<li>微信：搜索我附近的人</li>
</ul>
<blockquote>
<p>矩形范围查询</p>
</blockquote>
<p>矩形范围查询，也就是 <code>geo_bounding_box</code> 查询，查询坐标落在某个矩形范围的所有文档</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164127368.png" srcset="/img/loading.gif" lazyload alt="image-20220522164127368"></p>
<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_bounding_box查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;geo_bounding_box&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;top_left&quot;</span>: &#123; <span class="hljs-comment">// 左上点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span>: <span class="hljs-number">31.1</span>,<br>          <span class="hljs-attr">&quot;lon&quot;</span>: <span class="hljs-number">121.5</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;bottom_right&quot;</span>: &#123; <span class="hljs-comment">// 右下点</span><br>          <span class="hljs-attr">&quot;lat&quot;</span>: <span class="hljs-number">30.9</span>,<br>          <span class="hljs-attr">&quot;lon&quot;</span>: <span class="hljs-number">121.7</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>附近查询</p>
</blockquote>
<p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档</p>
<p>在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164158386.png" srcset="/img/loading.gif" lazyload alt="image-20220522164158386"></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// geo_distance 查询</span><br>GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;geo_distance&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;distance&quot;</span>: <span class="hljs-string">&quot;15km&quot;</span>, <span class="hljs-comment">// 半径</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;31.21,121.5&quot;</span> <span class="hljs-comment">// 圆心</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还可以根据距离排序</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;location&quot;</span>: <span class="hljs-string">&quot;31.034661,121.612282&quot;</span>, <span class="hljs-comment">//圆心</span><br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">//排序</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">//单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;hits&quot; : [<br>    &#123;<br>        <span class="hljs-attr">&quot;_index&quot;</span> : <span class="hljs-string">&quot;hotel&quot;</span>,<br>        <span class="hljs-attr">&quot;_type&quot;</span> : <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-attr">&quot;_id&quot;</span> : <span class="hljs-string">&quot;2056298828&quot;</span>,<br>        <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>            ...<br>        &#125;,<br>        &quot;sort&quot; : [<br>            <span class="hljs-number">4.8541199685347785</span> <span class="hljs-comment">//这里的结果为离圆心的距离</span><br>        ]<br>    &#125;,<br></code></pre></td></tr></table></figure>

<p>注意：输出结果中的 <strong>sort</strong> 为距离，比较常用。</p>
<p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的</p>
<h3 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h3><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>
<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>
</ul>
<h3 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h3><blockquote>
<p>这部分内容作为了解即可。</p>
</blockquote>
<p>当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。例如，我们搜索 “虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">17.850193</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;虹桥如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">12.259849</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;外滩如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;_score&quot;</span> : <span class="hljs-number">11.91091</span>,<br>    <span class="hljs-attr">&quot;_source&quot;</span> : &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;迪士尼如家酒店真不错&quot;</span>,<br>    &#125;<br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<h3 id="算分函数查询"><a href="#算分函数查询" class="headerlink" title="算分函数查询"></a>算分函数查询</h3><p>根据相关度打分是比较合理的需求，但有时候也不能够满足我们的需求。</p>
<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁给的钱多排名就越靠前。</p>
<p><strong>要想认为控制相关性算分，就需要利用 elasticsearch 中的 function score 查询了。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164427295.png" srcset="/img/loading.gif" lazyload alt="image-20220522164427295"></p>
<p>function score 查询中包含四部分内容：</p>
<ul>
<li><strong>原始查询</strong>条件：query 部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li>
<li><strong>过滤条件</strong>：filter 部分，符合该条件的文档才会<strong>重新算分</strong></li>
<li><strong>算分函数</strong>：符合 filter 条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul>
<li>weight：函数结果是常量</li>
<li>field_value_factor：以文档中的某个字段值作为函数结果</li>
<li>random_score：以随机数作为函数结果</li>
<li>script_score：自定义算分函数算法</li>
</ul>
</li>
<li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul>
<li>multiply：相乘</li>
<li>replace：用 function score 替换 query score</li>
<li>sum、avg、max、min</li>
</ul>
</li>
</ul>
<p>function score 的运行流程如下：</p>
<ol>
<li>根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li>
<li>根据<strong>过滤条件</strong>，过滤文档</li>
<li>符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li>
<li>将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li>
</ol>
<p>因此，其中的关键点是</p>
<ul>
<li>过滤条件：决定哪些文档的算分被修改</li>
<li>算分函数：决定函数算分的算法</li>
<li>运算模式：决定最终算分结果</li>
</ul>
<p>例如：我们给“如家”这个品牌的酒店排名靠前一些</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;function_score&quot;</span>: &#123;<br>      &quot;query&quot;: &#123;  .... &#125;, // 原始查询，可以是任意条件<br>      &quot;functions&quot;: [ // 算分函数<br>        &#123;<br>          <span class="hljs-attr">&quot;filter&quot;</span>: &#123; <span class="hljs-comment">// 满足的条件，品牌必须是如家</span><br>            <span class="hljs-attr">&quot;term&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;如家&quot;</span><br>            &#125;<br>          &#125;,<br>          <span class="hljs-attr">&quot;weight&quot;</span>: <span class="hljs-number">10</span> <span class="hljs-comment">// 算分权重为10</span><br>        &#125;<br>      ],<br>      &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试，在未添加算分函数时，如家得分如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164516047.png" srcset="/img/loading.gif" lazyload alt="image-20220522164516047"></p>
<p>添加了算分函数后，如家得分就提升了</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164530125.png" srcset="/img/loading.gif" lazyload alt="image-20220522164530125"></p>
<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有</p>
<ul>
<li>must：必须匹配每个子查询，类似“与”</li>
<li>should：选择性匹配子查询，类似“或”</li>
<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>
<li>filter：必须匹配，<strong>不参与算分</strong></li>
</ul>
<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤</p>
<p><strong>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool查询了。</strong></p>
<p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p>
<ul>
<li>搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分</li>
<li>其它过滤条件，采用 filter 查询，不参与算分</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;must&quot;</span>: [<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;city&quot;</span>: <span class="hljs-string">&quot;上海&quot;</span> &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;should&quot;</span>: [<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;皇冠假日&quot;</span> &#125;&#125;,<br>        &#123;<span class="hljs-attr">&quot;term&quot;</span>: &#123;<span class="hljs-attr">&quot;brand&quot;</span>: <span class="hljs-string">&quot;华美达&quot;</span> &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;must_not&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;range&quot;</span>: &#123; <span class="hljs-attr">&quot;price&quot;</span>: &#123; <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-number">500</span> &#125; &#125;&#125;<br>      ],<br>      <span class="hljs-attr">&quot;filter&quot;</span>: [<br>        &#123; <span class="hljs-attr">&quot;range&quot;</span>: &#123;<span class="hljs-attr">&quot;score&quot;</span>: &#123; <span class="hljs-attr">&quot;gte&quot;</span>: <span class="hljs-number">45</span> &#125; &#125;&#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。</p>
<ul>
<li>名称搜索，属于全文检索查询，应该参与算分，放到 must 中</li>
<li>价格不高于 400，用 range 查询，属于过滤条件，不参与算分，放到 must_not 中</li>
<li>周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分，放到 filter 中</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164728363.png" srcset="/img/loading.gif" lazyload alt="image-20220522164728363"></p>
<p>bool 查询的几种逻辑关系</p>
<ul>
<li>must：必须匹配的条件，可以理解为“与”</li>
<li>should：选择性匹配的条件，可以理解为“或”</li>
<li>must_not：必须不匹配的条件，不参与打分</li>
<li>filter：必须匹配的条件，不参与打分</li>
</ul>
<h2 id="搜索结果处理"><a href="#搜索结果处理" class="headerlink" title="搜索结果处理"></a>搜索结果处理</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>elasticsearch 默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等</p>
<p>keyword、数值、日期类型排序的语法基本一致。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>  <span class="hljs-comment">// 排序字段、排序方式ASC、DESC</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序。</p>
<p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164754555.png" srcset="/img/loading.gif" lazyload alt="image-20220522164754555"></p>
<p>地理坐标排序略有不同</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;FIELD&quot;</span> : <span class="hljs-string">&quot;纬度，经度&quot;</span>, <span class="hljs-comment">// 文档中geo_point类型的字段名、目标坐标点</span><br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <span class="hljs-comment">// 排序方式</span><br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <span class="hljs-comment">// 排序的距离单位</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;_geo_distance&quot;</span> : &#123;<br>          <span class="hljs-attr">&quot;location&quot;</span>: <span class="hljs-string">&quot;31.034661,121.612282&quot;</span>, <br>          <span class="hljs-attr">&quot;order&quot;</span> : <span class="hljs-string">&quot;asc&quot;</span>, <br>          <span class="hljs-attr">&quot;unit&quot;</span> : <span class="hljs-string">&quot;km&quot;</span> <br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>取你的位置的经纬度的方式：<a target="_blank" rel="noopener" href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat</a></p>
</blockquote>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>elasticsearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。</p>
<p>elasticsearch 通过修改 from、size 参数来控制要返回的分页结果：</p>
<ul>
<li>from：从第几个文档开始</li>
<li>size：总共查询几个文档</li>
</ul>
<p>类似于mysql中的<code>limit ?, ?</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>深度分页问题</p>
</blockquote>
<p>现在，我要查询990~1000的数据，查询逻辑要这么写</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-number">990</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 期望获取的文档总数</span><br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<span class="hljs-attr">&quot;price&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span>&#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p>
<p>注意：elasticsearch 内部分页时，必须先查询 0~1000条，然后截取其中的 990 ~ 1000 的这10条</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164937837.png" srcset="/img/loading.gif" lazyload alt="image-20220522164937837"></p>
<p>查询TOP1000，如果 es 是单点模式，这并无太大影响。</p>
<p>但是 elasticsearch 将来一定是集群，例如我集群有5个节点，我要查询 TOP1000 的数据，并不是每个节点查询200条就可以了。节点A的 TOP200，在另一个节点可能排到10000名以外了。</p>
<p><strong>因此要想获取整个集群的 TOP1000，必须先查询出每个节点的 TOP1000，汇总结果后，重新排名，重新截取 TOP1000。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522164952750.png" srcset="/img/loading.gif" lazyload alt="image-20220522164952750"></p>
<p><strong>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此 elasticsearch 会禁止from+ size 超过10000的请求。</strong></p>
<p>针对深度分页，ES提供了两种解决方案，<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p>
<ul>
<li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li>
<li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li>
</ul>
<hr>
<p>分页查询的常见实现方案以及优缺点</p>
<ul>
<li><code>from + size</code><ul>
<li>优点：支持随机翻页</li>
<li>缺点：深度分页问题，默认查询上限（from + size）是10000</li>
<li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li>
</ul>
</li>
<li><code>after search</code><ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：只能向后逐页查询，不支持随机翻页</li>
<li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li>
</ul>
</li>
<li><code>scroll</code><ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>
<li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li>
</ul>
</li>
</ul>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165015423.png" srcset="/img/loading.gif" lazyload alt="image-20220522165015423"></p>
<p>高亮显示的实现分为两步：</p>
<ul>
<li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /hotel/_search<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: <span class="hljs-string">&quot;TEXT&quot;</span> <span class="hljs-comment">// 查询条件，高亮一定要使用全文检索查询</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;highlight&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;fields&quot;</span>: &#123; <span class="hljs-comment">// 指定要高亮的字段</span><br>      <span class="hljs-attr">&quot;FIELD&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;em&gt;&quot;</span>,  <span class="hljs-comment">// 用来标记高亮字段的前置标签</span><br>        <span class="hljs-attr">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span> <span class="hljs-comment">// 用来标记高亮字段的后置标签</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>
<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>
<li>如果要对非搜索字段高亮，则需要添加一个属性：<code>required_field_match=false</code></li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165033153.png" srcset="/img/loading.gif" lazyload alt="image-20220522165033153"></p>
<blockquote>
<p>DSL 总体结构如下：</p>
</blockquote>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165048231.png" srcset="/img/loading.gif" lazyload alt="image-20220522165048231"></p>
<h2 id="RestClient文档查询"><a href="#RestClient文档查询" class="headerlink" title="RestClient文档查询"></a>RestClient文档查询</h2><h3 id="发起查询请求"><a href="#发起查询请求" class="headerlink" title="发起查询请求"></a>发起查询请求</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165109299.png" srcset="/img/loading.gif" lazyload alt="image-20220522165109299"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/10/16 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelSearchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match_All</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        request.source()<br>                .query(QueryBuilders.matchAllQuery());<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一步，创建<code>SearchRequest</code>对象，指定索引库名</li>
<li>第二步，利用<code>request.source()</code>构建 DSL，DSL 中可以包含查询、分页、排序、高亮等<ul>
<li><code>query()</code>：代表查询条件，利用 <code>QueryBuilders.matchAllQuery()</code> 构建一个 match_all 查询的 DSL</li>
</ul>
</li>
<li>第三步，利用 <code>client.search()</code> 发送请求，得到响应</li>
</ul>
<p>关键的 API 有两个，一个是 <code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165155892.png" srcset="/img/loading.gif" lazyload alt="image-20220522165155892"></p>
<p>另一个是 <code>QueryBuilders</code>，其中包含 match、term、function_score、bool 等各种查询</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165215501.png" srcset="/img/loading.gif" lazyload alt="image-20220522165215501"></p>
<h3 id="解析查询响应"><a href="#解析查询响应" class="headerlink" title="解析查询响应"></a>解析查询响应</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165233745.png" srcset="/img/loading.gif" lazyload alt="image-20220522165233745"></p>
<p>Elasticsearch 返回的结果是一个 JSON 字符串，结构包含</p>
<ul>
<li><code>hits</code>：命中的结果<ul>
<li><code>total</code>：总条数，其中的value是具体的总条数值</li>
<li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li>
<li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个 json 对象<ul>
<li><code>_source</code>：文档中的原始数据，也是 json 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下</p>
<ul>
<li><code>SearchHits</code>：通过 <code>response.getHits()</code> 获取，就是 json 中的最外层的 hits，代表命中的结果<ul>
<li><code>SearchHits.getTotalHits().value</code>：获取总条数信息</li>
<li><code>SearchHits.getHits()</code>：获取 SearchHit 数组，也就是文档数组<ul>
<li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的 <code>_source</code>，也就是原始的 json 文档数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 乐心湖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/10/16 17:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HotelSearchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IHotelService hotelService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match_All</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>        request.source()<br>                .query(QueryBuilders.matchAllQuery());<br>        SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>        SearchHits searchHits = response.getHits();<br>        System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>        SearchHit[] hits = searchHits.getHits();<br>        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>            String sourceAsString = hit.getSourceAsString();<br>            HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>            System.out.println(hotelDoc);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>                HttpHost.create(<span class="hljs-string">&quot;http://192.168.211.128:9200&quot;</span>)<br>        ));<br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h3><p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165256103.png" srcset="/img/loading.gif" lazyload alt="image-20220522165256103"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source()<br>            .query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>,<span class="hljs-string">&quot;如家&quot;</span>));<br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multiMatchQuery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    request.source()<br>            .query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;如家&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;brand&quot;</span>));<br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询主要是两者</p>
<ul>
<li>term：词条精确匹配</li>
<li>range：范围查询</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165330608.png" srcset="/img/loading.gif" lazyload alt="image-20220522165330608"></p>
<h3 id="布尔查询-1"><a href="#布尔查询-1" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询是用 must、must_not、filter等方式组合其它查询，代码示例如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165341669.png" srcset="/img/loading.gif" lazyload alt="image-20220522165341669"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    request.source()<br>            .query(<br>                    QueryBuilders.boolQuery()<br>                            .must(QueryBuilders.termQuery(<span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>))<br>                            .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">300</span>))<br>            );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="排序、分页"><a href="#排序、分页" class="headerlink" title="排序、分页"></a>排序、分页</h3><p>搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 <code>request.source()</code> 来设置。</p>
<p>对应的API如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165400398.png" srcset="/img/loading.gif" lazyload alt="image-20220522165400398"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPageAndSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 页码，每页大小</span><br>    <span class="hljs-keyword">int</span> page = <span class="hljs-number">1</span>, size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 2.2.排序 sort</span><br>    request.source().sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>    <span class="hljs-comment">// 2.3.分页 from、size</span><br>    request.source().from((page - <span class="hljs-number">1</span>) * size).size(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    System.out.println(<span class="hljs-string">&quot;hits.getTotalHits().条数 = &quot;</span> + searchHits.getTotalHits().value);<br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        String sourceAsString = hit.getSourceAsString();<br>        HotelDoc hotelDoc = JSON.parseObject(sourceAsString, HotelDoc.class);<br>        System.out.println(hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h3><ul>
<li>查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。</li>
<li>结果解析：结果除了要解析 <code>_source</code> 文档数据，还要解析高亮结果</li>
</ul>
<p><strong>高亮请求的构建 API</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165415263.png" srcset="/img/loading.gif" lazyload alt="image-20220522165415263"></p>
<p>上述代码省略了查询条件部分，但是高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;hotel&quot;</span>);<br>    <span class="hljs-comment">// 2.准备DSL</span><br>    <span class="hljs-comment">// 2.1.query</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;如家&quot;</span>));<br>    <span class="hljs-comment">// 2.2.高亮</span><br>    request.source().highlighter(<span class="hljs-keyword">new</span> HighlightBuilder().field(<span class="hljs-string">&quot;name&quot;</span>).requireFieldMatch(<span class="hljs-keyword">false</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    SearchResponse response = client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response); <span class="hljs-comment">//代码在下文</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>高亮结果解析</strong></p>
<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>
<p>因此解析高亮的代码需要额外处理：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220522165433204.png" srcset="/img/loading.gif" lazyload alt="image-20220522165433204"></p>
<ul>
<li>第一步：从结果中获取 source。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json 字符串，需要反序列为 HotelDoc 对象</li>
<li>第二步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个 Map，key 是高亮字段名称，值是HighlightField 对象，代表高亮值</li>
<li>第三步：从 map 中根据高亮字段名称，获取高亮字段值对象 HighlightField</li>
<li>第四步：从 HighlightField 中获取 Fragments，并且转为字符串。<strong>这部分是真正的高亮字符串</strong></li>
<li>第五步：用高亮的结果替换 HotelDoc 中的非高亮结果</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> </span>&#123;<br>    <span class="hljs-comment">// 4.解析响应</span><br>    SearchHits searchHits = response.getHits();<br>    <span class="hljs-comment">// 4.1.获取总条数</span><br>    <span class="hljs-keyword">long</span> total = searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 4.2.文档数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-comment">// 4.3.遍历</span><br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 获取文档source</span><br>        String json = hit.getSourceAsString();<br>        <span class="hljs-comment">// 反序列化</span><br>        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);<br>        <span class="hljs-comment">// 获取高亮结果</span><br>        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;<br>            <span class="hljs-comment">// 根据字段名获取高亮结果</span><br>            HighlightField highlightField = highlightFields.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (highlightField != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 获取高亮值</span><br>                String name = highlightField.getFragments()[<span class="hljs-number">0</span>].string();<br>                <span class="hljs-comment">// 覆盖非高亮结果</span><br>                hotelDoc.setName(name);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;hotelDoc = &quot;</span> + hotelDoc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

























<h1 id="Sentine流量组件"><a href="#Sentine流量组件" class="headerlink" title="Sentine流量组件"></a>Sentine流量组件</h1><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><blockquote>
<p>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</p>
</blockquote>
<p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183034937.png" srcset="/img/loading.gif" lazyload alt="image-20220520183034937"></p>
<p>如图，如果服务提供者I 发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I 的业务似乎不受影响。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183059877.png" srcset="/img/loading.gif" lazyload alt="image-20220520183059877"></p>
<p>但是，依赖服务I 的业务请求被阻塞，则 tomcat 的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183114168.png" srcset="/img/loading.gif" lazyload alt="image-20220520183114168"></p>
<p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，<strong>从而导致所有其它服务都不可用</strong>。</p>
<p>综上，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，这就是雪崩问题。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183129914.png" srcset="/img/loading.gif" lazyload alt="image-20220520183129914"></p>
<p>解决雪崩问题的常见方式有四种</p>
<ol>
<li>超时处理</li>
<li>线程隔离</li>
<li>降级熔断</li>
<li>限流</li>
</ol>
<blockquote>
<p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p>
<p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p>
</blockquote>
<p>1.超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183203519.png" srcset="/img/loading.gif" lazyload alt="image-20220520183203519"></p>
<p>2.线程隔离</p>
<p>是一种舱壁模式，如下图，船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此也叫线程隔离。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183217487.png" srcset="/img/loading.gif" lazyload alt="image-20220520183217487"></p>
<p>3.降级熔断</p>
<p>是一种断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p>
<p>断路器会统计访问某个服务的请求数量，异常比例。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183301761.png" srcset="/img/loading.gif" lazyload alt="image-20220520183301761"></p>
<p>当发现访问服务 D 的请求异常比例过高时，认为服务 D 有导致雪崩的风险，会拦截访问服务 D 的一切请求，形成熔断。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183317450.png" srcset="/img/loading.gif" lazyload alt="image-20220520183317450"></p>
<p>4.限流</p>
<p><strong>流量控制</strong>：限制业务访问的 QPS，避免服务因流量的突增而故障。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183330199.png" srcset="/img/loading.gif" lazyload alt="image-20220520183330199"></p>
<p>在 SpringCloud 当中支持多种服务保护技术</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li>
</ul>
<p>早期比较流行的是 Hystrix 框架，但目前国内实用最广泛的还是阿里巴巴的 Sentinel 框架，这里我们做下对比：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>Sentinel</strong></th>
<th align="left"><strong>Hystrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">隔离策略</td>
<td align="left">信号量隔离</td>
<td align="left">线程池隔离/信号量隔离</td>
</tr>
<tr>
<td align="left">熔断降级策略</td>
<td align="left">基于慢调用比例或异常比例</td>
<td align="left">基于失败比率</td>
</tr>
<tr>
<td align="left">实时指标实现</td>
<td align="left">滑动窗口</td>
<td align="left">滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td align="left">规则配置</td>
<td align="left">支持多种数据源</td>
<td align="left">支持多种数据源</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">多个扩展点</td>
<td align="left">插件的形式</td>
</tr>
<tr>
<td align="left">基于注解的支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">限流</td>
<td align="left">基于 QPS，支持基于调用关系的限流</td>
<td align="left">有限的支持</td>
</tr>
<tr>
<td align="left">流量整形</td>
<td align="left">支持慢启动、匀速排队模式</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">系统自适应保护</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">控制台</td>
<td align="left">开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td align="left">不完善</td>
</tr>
<tr>
<td align="left">常见框架的适配</td>
<td align="left">Servlet、Spring Cloud、Dubbo、gRPC 等</td>
<td align="left">Servlet、Spring Cloud Netflix</td>
</tr>
</tbody></table>
<h2 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h2><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p>
<p>Sentinel 具有以下特征</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h2 id="整合Sentinel"><a href="#整合Sentinel" class="headerlink" title="整合Sentinel"></a>整合Sentinel</h2><p>下载后 jar 包后，运行代码：<code>java -jar sentinel-dashboard-1.8.1.jar</code></p>
<p>如果要修改 Sentinel 的默认端口、账户、密码，可以通过下列配置：</p>
<table>
<thead>
<tr>
<th align="left"><strong>配置项</strong></th>
<th align="left"><strong>默认值</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">server.port</td>
<td align="left">8080</td>
<td align="left">服务端口</td>
</tr>
<tr>
<td align="left">sentinel.dashboard.auth.username</td>
<td align="left">sentinel</td>
<td align="left">默认用户名</td>
</tr>
<tr>
<td align="left">sentinel.dashboard.auth.password</td>
<td align="left">sentinel</td>
<td align="left">默认密码</td>
</tr>
</tbody></table>
<p>例如，修改端口：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改其他配置也在配置项前面添加-D，注意不要在最后添加，会不起作用</span><br><span class="hljs-comment"># 也可以使用java -jar sentinel-dashboard-1.8.1.jar --server.port=9090 修改端口</span><br>java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar<br></code></pre></td></tr></table></figure>

<p>访问 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 页面，就可以看到 Sentinel 的控制台了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183712354.png" srcset="/img/loading.gif" lazyload alt="image-20220520183712354"></p>
<p>账号和密码默认都是：sentinel</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183727720.png" srcset="/img/loading.gif" lazyload alt="image-20220520183727720"></p>
<p>此时空白一片，还需要我们来整合进 SpringCloud</p>
<p>准备好我们的项目，在资料中，结构如下：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183803497.png" srcset="/img/loading.gif" lazyload alt="image-20220520183803497"></p>
<p>我们在 order-service 中整合 Sentinel，并连接 Sentinel 的控制台，步骤如下</p>
<p>1）引入 Sentinel 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sentinel--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2）配置控制台</p>
<p>修改 application.yml 文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure>

<p>3）访问 order-service 的任意端点</p>
<p>打开浏览器，访问 <a target="_blank" rel="noopener" href="http://localhost:10010/order/101%EF%BC%8C%E5%A4%9A%E8%AE%BF%E9%97%AE%E5%87%A0%E6%AC%A1%EF%BC%8C%E5%A4%9A%E7%82%B9%E5%87%A0%E6%AC%A1%E5%88%B7%E6%96%B0%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A6%E5%8F%91">http://localhost:10010/order/101，多访问几次，多点几次刷新，这样才能触发</a> Sentinel 的监控。</p>
<p>然后再访问 Sentinel 的控制台，查看效果。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183830014.png" srcset="/img/loading.gif" lazyload alt="image-20220520183830014"></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>雪崩问题虽有四种方案，但是<strong>限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。</strong>学过毛中特的都知道，《预判风险所在是防范风险的前提》，我们先学习流量控制。</p>
<h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>当请求进入微服务时，首先会访问 DispatcherServlet，然后进入 Controller、Service、Mapper，这样的一个调用链就叫做 <strong>簇点链路</strong>。</p>
<p><strong>簇点链路中被监控的每一个接口就是一个资源</strong>。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点（Endpoint，也就是 Controller 中的方法），因此 SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源。</p>
<p>例如，我们刚才访问的 order-service 中的 OrderController 中的端点：/order/{orderId}</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183901596.png" srcset="/img/loading.gif" lazyload alt="image-20220520183901596"></p>
<p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p>
<ul>
<li>流控：流量控制</li>
<li>降级：降级熔断</li>
<li>热点：热点参数限流，是限流的一种</li>
<li>授权：请求的权限控制</li>
</ul>
<p>点击资源 /order/{orderId} 后面的流控按钮，就可以弹出表单。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183920103.png" srcset="/img/loading.gif" lazyload alt="image-20220520183920103"></p>
<p>表单中可以填写限流规则，如下</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183935131.png" srcset="/img/loading.gif" lazyload alt="image-20220520183935131"></p>
<p>其含义是限制 /order/{orderId} 这个资源的单机 QPS 为 1，即每秒只允许 1 次请求，超出的请求会被拦截并报错。</p>
<blockquote>
<p>需求：给 /order/{orderId} 这个资源设置流控规则，QPS 不能超过 5，然后测试。</p>
</blockquote>
<p>1）首先在 sentinel 控制台添加限流规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520183948014.png" srcset="/img/loading.gif" lazyload alt="image-20220520183948014"></p>
<p>2）利用 jmeter 测试</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184005873.png" srcset="/img/loading.gif" lazyload alt="image-20220520184005873"></p>
<p>20 个用户，2 秒内运行完，这样的话 QPS 就是 10，超过了我们在 sentinel 设置的 5</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184026072.png" srcset="/img/loading.gif" lazyload alt="image-20220520184026072"></p>
<p>可以看到，成功的请求每次只有 5 个。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184048177.png" srcset="/img/loading.gif" lazyload alt="image-20220520184048177"></p>
<h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong></p>
<h4 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h4><ul>
<li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式<ul>
<li>直接对当前资源限流</li>
</ul>
</li>
<li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流<ul>
<li>相当于高优先级资源触发阈值，对低优先级资源限流。</li>
</ul>
</li>
<li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流<ul>
<li>是针对请求来源的限流</li>
</ul>
</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184103693.png" srcset="/img/loading.gif" lazyload alt="image-20220520184103693"></p>
<p>上面我们测试的就是直接模式，默认就是直接模式。</p>
<h4 id="关联模式"><a href="#关联模式" class="headerlink" title="关联模式"></a>关联模式</h4><p>统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。</p>
<p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184127009.png" srcset="/img/loading.gif" lazyload alt="image-20220520184127009"></p>
<p>例如：配置规则，<strong>当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源。</strong></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184142345.png" srcset="/img/loading.gif" lazyload alt="image-20220520184142345"></p>
<p>我们去程序中模拟：</p>
<ul>
<li>在 OrderController 新建两个端点：/order/query 和 /order/update，无需实现业务</li>
<li>配置流控规则，当 /order/ update 资源被访问的 QPS 超过 5 时，对 /order/query 请求限流</li>
</ul>
<p>1）定义 /order/query 端点，模拟订单查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）定义 /order/update 端点，模拟订单更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;更新订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重启服务，查看 Sentinel 控制台的簇点链路。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184209929.png" srcset="/img/loading.gif" lazyload alt="image-20220520184209929"></p>
<p>3）配置流控规则</p>
<p>想要对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询 /order/query 限流</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184223704.png" srcset="/img/loading.gif" lazyload alt="image-20220520184223704"></p>
<p>在表单中填写流控规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184240617.png" srcset="/img/loading.gif" lazyload alt="image-20220520184240617"></p>
<h4 id="链路模式"><a href="#链路模式" class="headerlink" title="链路模式"></a>链路模式</h4><p>只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p>
<p>例如有两条请求链路</p>
<ul>
<li>/test1 –&gt; /common</li>
<li>/test2 –&gt; /common</li>
</ul>
<p>如果只希望统计从 /test2 进入到 /common 的请求，则可以这样配置</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184302231.png" srcset="/img/loading.gif" lazyload alt="image-20220520184302231"></p>
<p><strong>实战案例</strong></p>
<p>有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p>
<ol>
<li>在 OrderService 中添加一个 queryGoods 方法，不用实现业务</li>
<li>在 OrderController 中，改造 /order/query 端点，调用 OrderService 中的 queryGoods 方法</li>
<li>在 OrderController 中添加一个 /order/save 端点，调用 OrderService 的 queryGoods 方法</li>
<li>给 queryGoods 设置限流规则，从 /order/query 进入 queryGoods 的方法限制 QPS 必须小于 2</li>
</ol>
<p>1）添加查询商品方法</p>
<p>在order-service服务中，给 OrderService 类添加一个 queryGoods 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryGoods</span><span class="hljs-params">()</span></span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）查询订单时，查询商品</p>
<p>在 order-service 的 OrderController 中，修改 /order/query 端点的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;查询订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询订单成功&quot;</span>;<br>&#125;  <br></code></pre></td></tr></table></figure>

<p>3）新增订单，查询商品</p>
<p>在 order-service 的 OrderController 中，修改 /order/save 端点，模拟新增订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 查询商品</span><br>    orderService.queryGoods();<br>    <span class="hljs-comment">// 查询订单</span><br>    System.out.println(<span class="hljs-string">&quot;新增订单&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;新增订单成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4）给查询商品添加资源标记</p>
<p>默认情况下，OrderService 中的方法是不被 Sentinel 监控的，需要我们自己通过注解来标记要监控的方法。</p>
<p>给 OrderService 的 queryGoods 方法添加 <code>@SentinelResource</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SentinelResource(&quot;goods&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryGoods</span><span class="hljs-params">()</span></span>&#123;<br>    System.err.println(<span class="hljs-string">&quot;查询商品&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>链路模式中，是对不同来源的两个链路做监控。但是 Sentinel 默认会给进入 SpringMVC 的所有请求设置同一个 root 资源，会导致链路模式失效。我们需要关闭这种对 SpringMVC 的资源聚合，修改 order-service 服务的 application.yml 文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭context整合</span><br></code></pre></td></tr></table></figure>

<p>重启服务，访问 /order/query 和 /order/save，可以查看到 Sentinel 的簇点链路规则中，出现了新的资源</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184341995.png" srcset="/img/loading.gif" lazyload alt="image-20220520184341995"></p>
<p>5）添加流控规则</p>
<p>点击 goods 资源后面的流控按钮，在弹出的表单中填写下面信息</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184356116.png" srcset="/img/loading.gif" lazyload alt="image-20220520184356116"></p>
<p>只统计从 /order/query 进入 /goods 的资源，QPS 阈值为 2，超出则被限流。</p>
<h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h2><h3 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h3><p>细心的小伙伴会发现在流控的高级选项中，还有一个流控效果选项，前面我们的测试都是基本快速失败的。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184416829.png" srcset="/img/loading.gif" lazyload alt="image-20220520184416829"></p>
<p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种</p>
<ul>
<li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出 FlowException 异常，是默认的处理方式。</li>
<li>Warm Up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</li>
<li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</li>
</ul>
<h3 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h3><p>阈值一般是一个微服务能承担的最大 QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将 QPS 跑到最大值，可能导致服务瞬间宕机。</p>
<p>Warm Up 也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值初始值是 <code>maxThreshold / coldFactor</code>，持续指定时长后，逐渐提高到 maxThreshold 值。而 coldFactor 的默认值是 3.</p>
<p>例如，我设置 QPS 的 maxThreshold 为 10，预热时间为 5 秒，那么初始阈值就是 10 / 3 = 3，然后在 5 秒后逐渐增长到 10</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184435351.png" srcset="/img/loading.gif" lazyload alt="image-20220520184435351"></p>
<p><strong>案例</strong>：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用 Warm Up 效果，预热时长为 5 秒。</p>
<p>1）配置流控规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184540453.png" srcset="/img/loading.gif" lazyload alt="image-20220520184540453"></p>
<p>用官方的话讲，该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。</p>
<h3 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h3><p>当请求超过 QPS 阈值时，「快速失败」和 「Warm Up」会拒绝新的请求并抛出异常。</p>
<p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p>
<p>例如：QPS = 5，意味着每 200ms 处理一个队列中的请求；timeout = 2000，意味着<strong>预期等待时长</strong>超过 2000ms 的请求会被拒绝并抛出异常。</p>
<p>比如现在一下子来了 12 个请求，因为每 200ms 执行一个请求，那么预期等待时长就是：</p>
<ul>
<li>第6个请求的<strong>预期等待时长</strong> = 200 * (6 - 1) = 1000ms</li>
<li>第12个请求的预期等待时长 = 200 * (12-1) = 2200ms</li>
</ul>
<p>又比如下图：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184551503.png" srcset="/img/loading.gif" lazyload alt="image-20220520184551503"></p>
<p>现在，第 1 秒同时接收到 10 个请求，但第 2 秒只有 1 个请求，此时 QPS 的曲线这样的</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184614143.png" srcset="/img/loading.gif" lazyload alt="image-20220520184614143"></p>
<p>如果使用排队等待的流控效果，所有进入的请求都要排队，以固定的 200ms 的间隔执行，QPS 会变的很平滑</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184630104.png" srcset="/img/loading.gif" lazyload alt="image-20220520184630104"></p>
<p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<p><strong>案例</strong>：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用排队等待的流控效果，超时时长设置为 5s</p>
<p>1）添加流控规则</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184650487.png" srcset="/img/loading.gif" lazyload alt="image-20220520184650487"></p>
<h2 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而「热点参数限流」是<strong>分别统计参数值相同的请求</strong>，判断是否超过 QPS 阈值。</p>
<h3 id="全局参数限流"><a href="#全局参数限流" class="headerlink" title="全局参数限流"></a>全局参数限流</h3><p>例如，一个根据 id 查询商品的接口</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184712832.png" srcset="/img/loading.gif" lazyload alt="image-20220520184712832"></p>
<p>访问 /goods/{id} 的请求中，id 参数值会有变化，「热点参数限流」会根据参数值分别统计 QPS，统计结果：</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184725180.png" srcset="/img/loading.gif" lazyload alt="image-20220520184725180"></p>
<p>当 id=1 的请求触发阈值被限流时，id值不为1的请求则不受影响。</p>
<p>配置示例：对 hot 这个资源的 0 号参数（也就是第一个参数）做统计，每 1s <strong>相同参数值</strong>的请求数不能超过 5</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184740039.png" srcset="/img/loading.gif" lazyload alt="image-20220520184740039"></p>
<h3 id="热点参数限流-1"><a href="#热点参数限流-1" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>假设上面的例子是一个商品查询接口，那么刚才的配置中，对这个接口的所有商品一视同仁，QPS 都限定为 5</p>
<p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的 QPS 限制与其它商品不一样，高一些。那就需要配置「热点参数限流」的高级选项了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184755485.png" srcset="/img/loading.gif" lazyload alt="image-20220520184755485"></p>
<p>结合上一个配置，这里的含义是对 0 号的 long 类型参数限流，每 1 个相同参数的 QPS 不能超过 5，有如下两个例外</p>
<ul>
<li>如果参数值是 100，则每 1s 允许的 QPS 为 10</li>
<li>如果参数值是 101，则每 1s 允许的 QPS 为 15</li>
</ul>
<p><strong>案例需求</strong>：给 /order/{orderId} 这个资源添加「热点参数限流」，规则如下</p>
<ul>
<li>默认的热点参数规则是每 1s 请求量不超过 2</li>
<li>给 102 这个参数设置例外：每 1s 请求量不超过 4</li>
<li>给 103 这个参数设置例外：每 1s 请求量不超过 10</li>
</ul>
<p><strong>注意事项</strong>：热点参数限流对默认的 SpringMVC 资源无效，需要利用 <code>@SentinelResource</code> 注解标记资源。</p>
<p>1）标记资源</p>
<p>给 order-service 中的 OrderController 中的 /order/{orderId} 资源添加注解</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184809515.png" srcset="/img/loading.gif" lazyload alt="image-20220520184809515"></p>
<p>2）热点参数限流规则</p>
<p>访问该接口，可以看到我们标记的 hot 资源出现了</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184821804.png" srcset="/img/loading.gif" lazyload alt="image-20220520184821804"></p>
<p>点击左侧菜单中<strong>热点规则</strong>菜单</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184835734.png" srcset="/img/loading.gif" lazyload alt="image-20220520184835734"></p>
<p>点击左侧菜单中<strong>热点规则</strong>菜单</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184856244.png" srcset="/img/loading.gif" lazyload alt="image-20220520184856244"></p>
<p>点击新增，填写表单</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184910985.png" srcset="/img/loading.gif" lazyload alt="image-20220520184910985"></p>
<h2 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级</h2><p>限流只是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p>
<p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p>
<p><strong>线程隔离</strong>：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184930101.png" srcset="/img/loading.gif" lazyload alt="image-20220520184930101"></p>
<p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220520184941897.png" srcset="/img/loading.gif" lazyload alt="image-20220520184941897"></p>
<p>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong>发起远程调用时做线程隔离、或者服务熔断。</p>
<p>而我们的微服务远程调用都是基于 Feign 来完成的，因此我们需要将 Feign 与 Sentinel 整合，在 Feign 里面实现线程隔离和服务熔断。</p>
<h2 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel</h2><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合 Feign 和 Sentinel</p>
<p>修改配置，开启 Sentinel 功能，修改 OrderService 的 application.yml 文件，开启 Feign 的 Sentinel 功能</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对sentinel的支持</span><br></code></pre></td></tr></table></figure>

<p>服务降级：访问失败后，服务</p>
<p><strong>编写失败降级逻辑代码</strong>，业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p>
<p>给 FeignClient 编写失败后的降级逻辑</p>
<p>①方式一：FallbackClass，但无法对远程调用的异常做处理。</p>
<p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p>
<p>这里我们演示方式二的失败降级处理。</p>
<p><strong>步骤一</strong>：在 feing-api 项目中定义类，实现 FallbackFactory</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172651031.png" srcset="/img/loading.gif" lazyload alt="image-20220521172651031"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xn2001.feign.clients.fallback;<br><br><span class="hljs-keyword">import</span> com.xn2001.feign.clients.UserClient;<br><span class="hljs-keyword">import</span> com.xn2001.feign.pojo.User;<br><span class="hljs-keyword">import</span> feign.hystrix.FallbackFactory;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/5/9 14:24</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserClientFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FallbackFactory</span>&lt;<span class="hljs-title">UserClient</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserClient <span class="hljs-title">create</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> userClient -&gt; &#123;<br>           log.error(<span class="hljs-string">&quot;查询用户失败&quot;</span>,throwable);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>       &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤二</strong>：在 feing-api 项目中的 DefaultFeignConfiguration 类中将 UserClientFallbackFactory 注册为一个Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserClientFallbackFactory <span class="hljs-title">userClientFallbackFactory</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserClientFallbackFactory();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>步骤三</strong>：在 feing-api 项目中的 UserClient 接口中使用 UserClientFallbackFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重启后，访问一次订单查询业务，然后查看 Sentinel 控制台，可以看到新的簇点链路</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172853837.png" srcset="/img/loading.gif" lazyload alt="image-20220521172853837"></p>
<h2 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h2><p>线程隔离（舱壁模式）有两种方式实现</p>
<ul>
<li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果。</li>
<li>信号量隔离（Sentinel默认采用）：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</li>
</ul>
<p>两者的优缺点</p>
<ul>
<li>线程池隔离：基于线程池模式，有额外开销，但隔离控制更强</li>
<li>信号量隔离：基于计数器模式，简单，开销小</li>
</ul>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172910064.png" srcset="/img/loading.gif" lazyload alt="image-20220521172910064"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521172923462.png" srcset="/img/loading.gif" lazyload alt="image-20220521172923462"></p>
<p><strong>Sentinel 使用的是信号量隔离</strong>，而 Hystrix 则两种线程隔离都可以，18 年Hystrix已经停止更新。</p>
<p>如何使用呢，在添加限流规则时，可以选择两种阈值类型</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173012300.png" srcset="/img/loading.gif" lazyload alt="image-20220521173012300"></p>
<ul>
<li>QPS：就是每秒的请求数，之前已经演示过。</li>
<li>线程数：是该资源能使用的 Tomcat 线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</li>
</ul>
<p><strong>案例需求</strong>：给 order-service 服务中的 UserClient 的查询用户接口设置流控规则，线程数不能超过 2，然后利用 JMeter 测试。</p>
<p>1）配置隔离规则，选择 feign 接口后面的流控按钮</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173029388.png" srcset="/img/loading.gif" lazyload alt="image-20220521173029388"></p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173038565.png" srcset="/img/loading.gif" lazyload alt="image-20220521173038565"></p>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h2><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p>
<p>断路器控制熔断和放行是通过状态机来完成的，如下图就是一个断路器的状态机</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173059233.png" srcset="/img/loading.gif" lazyload alt="image-20220521173059233"></p>
<p>状态机包括三个状态</p>
<ul>
<li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。会去判断是否达到熔断条件，这一步我们叫做「熔断策略」，达到该条件则切换到 open 状态，打开断路器。</li>
<li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open 状态 5 秒后会进入 half-open 状态。</li>
<li>half-open：半开状态，会一段时间放行一次请求，根据执行结果来判断接下来的操作。请求成功：则切换到 closed 状态；请求失败：则切换到 open 状态。</li>
</ul>
<p>断路器熔断策略有三种：慢调用、异常比例、异常数</p>
<h4 id="慢调用"><a href="#慢调用" class="headerlink" title="慢调用"></a>慢调用</h4><p>业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p>
<p>例如下图，设置 RT 超过 500ms 的调用是慢调用，统计最近 10000ms 内的请求，如果请求量超过 10 次，并且慢调用比例不低于 0.5，则触发熔断，熔断时长为 5s，然后进入 half-open 状态，放行一次请求做测试。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173115082.png" srcset="/img/loading.gif" lazyload alt="image-20220521173115082"></p>
<p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，慢调用的 RT 阈值为 50ms，统计时间为 1s ，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s；</p>
<p>1）设置慢调用</p>
<p>修改 user-service 中的 /user/{id} 这个接口的业务。通过休眠模拟一个延迟时间。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173127987.png" srcset="/img/loading.gif" lazyload alt="image-20220521173127987"></p>
<p>2）设置熔断规则</p>
<p>下面，给 feign 接口设置降级规则，超过 50ms 的请求都会被认为是慢请求。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173148541.png" srcset="/img/loading.gif" lazyload alt="image-20220521173148541"></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p>
<p>例如，异常比例设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 0.4，则触发熔断。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173223974.png" srcset="/img/loading.gif" lazyload alt="image-20220521173223974"></p>
<p>异常数设置如下，统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 2 次，则触发熔断。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173239882.png" srcset="/img/loading.gif" lazyload alt="image-20220521173239882"></p>
<p><strong>案例需求</strong>：给 UserClient 的查询用户接口设置降级规则，统计时间为 1s，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s</p>
<p>1）设置异常请求</p>
<p>首先，修改 user-service 中的 /user/{id} 这个接口的业务。手动抛出异常，以触发异常比例的熔断，也就是说，id 为 2时，就会触发异常。</p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173259839.png" srcset="/img/loading.gif" lazyload alt="image-20220521173259839"></p>
<p>2）设置熔断规则</p>
<p>在 5 次请求中，只要异常比例超过 0.4，也就是有 2 次以上的异常，就会触发熔断。            </p>
<p><img src="https://pety.oss-cn-shenzhen.aliyuncs.com/img/image-20220521173314778.png" srcset="/img/loading.gif" lazyload alt="image-20220521173314778"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/13/RPC/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RPC</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/29/Jemeter/">
                        <span class="hidden-mobile">JMeter压力测试</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js" ></script>



  <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>



  <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
